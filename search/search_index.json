{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"_ _ | | | | _ _ _____ _| |_ _ _| |__ ___ | | | |/ _ \\ \\ /\\ / / __| | | | '_ \\ / _ \\ | |_| | __/\\ V V /| |_| |_| | |_) | __/ \\__, |\\___| \\_/\\_/ \\__|\\__,_|_.__/ \\___| __/ | |___/ Terminal based YouTube player and downloader. No Youtube API key required. Forked from mps-youtube Installation \u00b6 Stable Version \u00b6 Using pip \u00b6 Install using pip install yewtube Run using, yt . Enjoy! Using pipx (Recommended) \u00b6 Install pipx using pip install pipx Install yewtube using pipx install yewtube Now, type yt That's it. Latest Version \u00b6 Using pip \u00b6 Install using pip install git+https://github.com/iamtalhaasghar/yewtube.git Run using, yt . Enjoy! Using pipx \u00b6 Install pipx using pip install pipx Install yewtube using pipx install git+https://github.com/iamtalhaasghar/yewtube.git Now, type yt That's it. What's new in yewtube? \u00b6 No Youtube API Key required Run audio in VLC with no GUI See complete and up-to-date changelog here . These features are still inherited from mps-youtube . - Search and play audio/video from YouTube - Search tracks of albums by album title - Search and import YouTube playlists - Create and save local playlists - Download audio/video - Convert to mp3 & other formats (requires ffmpeg or avconv) - View video comments - Works with Python 3.x - Works with Windows, Linux and Mac OS X - Requires mplayer, mpv or VLC This project is based on mps-youtube and mps-youtube is based on mps , a terminal based program to search, stream and download music. This implementation uses YouTube as a source of content and can play and download video as well as audio. The pafy library handles interfacing with YouTube. mps-youtube wiki yewtube wiki Screenshots \u00b6 Search: A standard search is performed by entering / followed by search terms. You can play all of the search results by giving 1- as input Repeating song/songs can be done with song_number[loop] , for example: 1[3] or 4-6[2] Local Playlists: Search result items can easily be stored in local playlists. YouTube Playlists: YouTube playlists can be searched and played or saved as local playlists. A playlist search is performed by // followed by search term. Download: Content can be downloaded in various formats and resolutions. Comments: A basic comments browser is available to view YouTube user comments. Music Album Matching: An album title can be specified and yewtube will attempt to find matches for each track of the album, based on title and duration. Type help search for more info. Customisation: Search results can be customised to display additional fields and ordered by various criteria. This configuration was set up using the following commands set order views set columns user:14 date comments rating likes dislikes category:9 views Type help config for help on configuration options Upgrading \u00b6 If installed using pipx \u00b6 pipx upgrade yewtube If installed using pip \u00b6 pip install --upgrade yewtube Usage \u00b6 yewtube is run on the command line using the command: yt Enter h from within the program for help. How to Contribute \u00b6 Contributions are welcomed! However, please check out the contribution page before making a contribution.","title":"Overview"},{"location":"#installation","text":"","title":"Installation"},{"location":"#stable-version","text":"","title":"Stable Version"},{"location":"#using-pip","text":"Install using pip install yewtube Run using, yt . Enjoy!","title":"Using pip"},{"location":"#using-pipx-recommended","text":"Install pipx using pip install pipx Install yewtube using pipx install yewtube Now, type yt That's it.","title":"Using pipx (Recommended)"},{"location":"#latest-version","text":"","title":"Latest Version"},{"location":"#using-pip_1","text":"Install using pip install git+https://github.com/iamtalhaasghar/yewtube.git Run using, yt . Enjoy!","title":"Using pip"},{"location":"#using-pipx","text":"Install pipx using pip install pipx Install yewtube using pipx install git+https://github.com/iamtalhaasghar/yewtube.git Now, type yt That's it.","title":"Using pipx"},{"location":"#whats-new-in-yewtube","text":"No Youtube API Key required Run audio in VLC with no GUI See complete and up-to-date changelog here . These features are still inherited from mps-youtube . - Search and play audio/video from YouTube - Search tracks of albums by album title - Search and import YouTube playlists - Create and save local playlists - Download audio/video - Convert to mp3 & other formats (requires ffmpeg or avconv) - View video comments - Works with Python 3.x - Works with Windows, Linux and Mac OS X - Requires mplayer, mpv or VLC This project is based on mps-youtube and mps-youtube is based on mps , a terminal based program to search, stream and download music. This implementation uses YouTube as a source of content and can play and download video as well as audio. The pafy library handles interfacing with YouTube. mps-youtube wiki yewtube wiki","title":"What's new in yewtube?"},{"location":"#screenshots","text":"Search: A standard search is performed by entering / followed by search terms. You can play all of the search results by giving 1- as input Repeating song/songs can be done with song_number[loop] , for example: 1[3] or 4-6[2] Local Playlists: Search result items can easily be stored in local playlists. YouTube Playlists: YouTube playlists can be searched and played or saved as local playlists. A playlist search is performed by // followed by search term. Download: Content can be downloaded in various formats and resolutions. Comments: A basic comments browser is available to view YouTube user comments. Music Album Matching: An album title can be specified and yewtube will attempt to find matches for each track of the album, based on title and duration. Type help search for more info. Customisation: Search results can be customised to display additional fields and ordered by various criteria. This configuration was set up using the following commands set order views set columns user:14 date comments rating likes dislikes category:9 views Type help config for help on configuration options","title":"Screenshots"},{"location":"#upgrading","text":"","title":"Upgrading"},{"location":"#if-installed-using-pipx","text":"pipx upgrade yewtube","title":"If installed using pipx"},{"location":"#if-installed-using-pip","text":"pip install --upgrade yewtube","title":"If installed using pip"},{"location":"#usage","text":"yewtube is run on the command line using the command: yt Enter h from within the program for help.","title":"Usage"},{"location":"#how-to-contribute","text":"Contributions are welcomed! However, please check out the contribution page before making a contribution.","title":"How to Contribute"},{"location":"changelog/","text":"Changelog \u00b6 v2.8.0 (2022-02-28) \u00b6 Feature \u00b6 helptext: Help changelog ( 0643941 ) setup: Extras dependencies for mpris ( 936e890 ) Fix \u00b6 37 use set pages command to config how many search result pages to show ( 2baec5f ) \u00b6 44 dont run init when importing mps_youtube ( a072c22 ) \u00b6 mpris: Handle no data on time-pos ( 8bb29d3 ) 39 key error 'data' ( 834ed5b ) \u00b6 38 improved help menu responsiveness ( 972b4ef ) \u00b6 35 remove api key instructions ( 4f1fee3 ) \u00b6 24 colorama support for windows ( 9cf2616 ) \u00b6 v2.7.0 (2022-02-19) \u00b6 Feature \u00b6 Use yewtube over tor using torsocks \ud83d\udd25 ( 1e9c4ce ) v2.6.9 (2022-02-19) \u00b6 Fix \u00b6 28 show changelog with help new command ( d52b65d ) \u00b6 v2.6.8 (2022-02-19) \u00b6 Fix \u00b6 fixed #26 album search working now without youtube api ( 9c3ae03 ) v2.6.7 (2022-02-19) \u00b6 Fix \u00b6 Check for app updates ( eabfb52 ) Don't crash if playlists / history file has invalid youtube id fixed #24 ( 323d5d8 ) v2.6.6 (2022-02-18) \u00b6 Fix \u00b6 Playlists are working again fixed #18 ( bfceee4 ) Buffersize warning ( d185c3f ) g: Mpv msglevel ( 062b125 ) v2.6.5 (2022-02-17) \u00b6 Fix \u00b6 Default player priority is vlc > mpv > mplayer on first install fixed #16 ( 35409eb ) mplayer: _get_mplayer_version ( ab21c5d ) Bring back requirements.txt to life ( ff6e59d ) util.uea_pad: Handle AttributeError on t.split ( 1643266 ) v2.6.4 (2022-02-16) \u00b6 Fix \u00b6 Duplicate changelog and readme files ( 0265ef7 ) v2.6.3 (2022-02-16) \u00b6 Fix \u00b6 Welcome from semantic release python ( c237a68 ) yewtube was forked from mps-youtube \u00b6 Features \u00b6 was made to work without YouTube API v3 play music in vlc with no gui Version 0.2.8 17 February 2018 Features: \u00b6 Lastfm scrobbling (@rien333) (#758) splaylist and suser commands for Spotify (@ritiek) (#678) Autoplay support (@nikhilweee) (#594) genpl command (@nishanthkarthik) (#642) video_format configuration setting (@Vrihub) (#656) live command for live streams (@Razesdark) (#635) Add time column (@akaWolf) (#582) Add video ID column (@Razesdark) (#627) Allow filtering search by duration (@jas32096) (#548) Allow filtering search by date (@jas32096) (#553) Add history recent to display history without duplicates (@srvanrell) (#510) --no-textart to disable ascii art (for screenreaders) (@Gongreg) (#517) set_title option to disable setting window title (@ardrabczyk) (#498) Add s command for getting stream information (@ritiek) (#675) Add option to disable mpris (@hrnr) (#728) Generate playlist from video description (@Razesdark) (#649) Enhancements: \u00b6 Store playlists as m3u files instead of binary (@kraetzin) (#682) Show replies when displaying comments (@paulfertser) (#677) Use https urls for album art (@vszakats) (#574) When using \"repeat\" with mpv, keep player running (@ritiek) (#660) Display artist/album in mpris using lastfm (@vn-ki) (#739) Use channel.list API for user search (@Razesdark) (#628) Maintain volume across songs with mpv (@Razesdark) (#720) Prevent mpris from crashing the main process (@hrnr) (#728) Bug fixes: \u00b6 Fix mpris seeking with recent mpv vesions (@mg6) (#687) Fix removing video from multi-page playlist (@kraetzin) (#695) Skip unavailable tracks (@ritiek) (#734) Correctly display minutes/seconds (@Laxa) (#748) Handle null time-pos from mpv (@pritambaral) (#519) Fix da/dv command regex (@Vrihub) (#691) Skip channels in video/playlist searches (@ritiek) (#664) Fix divide by zero error (@ids1024) (#620) Use git log v0.2.7.1..v0.2.8 to see all changes, including various minor fixes, documentation changes, etc. not included here. Version 0.2.7.1 6 July 2016 Bug fixes: \u00b6 Fix pickle error (@ids1024) (#503) Install LICENSE, README.md, and CHANGELOG as package_data (@ids1024) Update youtube-dl in py2exe build (@ids1024) Version 0.2.7 27 June 2016 Features: \u00b6 Setting for default audio format (@nishanthkarthik) (#71 #466 #467) Search history with history command (@kraetzin) (#344 #472) Add syntax for repeating a track several times (@ghallak) (#437 #490) Reverse command (@kraetzin) (#422 #473) New daurl <url> command (@maricn) (#402) Enhancements: \u00b6 Pass --no-ytdl to mpv (@ids1024) (#492) Do not suppress mpv output in debug mode (@ids1024) Print traceback in debug mode (@ids1024) Speed up checkupdate by avoiding redirects (@ids1024) (#454) Pass --play-and-exit if vlc is used as a player (@ids1024)` Bug fixes: \u00b6 Fix error with python 3.3 (@ids1024) (#414) Fix maxres bug (@ids1024) (#430) Fix playlist cache bug in info command (@ids1024) (#468) Fix usersearch argument error (@ids1024) (#469 #482) Fix progress bar with new mpv versions (@ids1024) (#470 #485) Fix syntax error with set command (@ids1024) (#419) Fix syntax error with -w, -f, -a (@ids1024) (#420) Fix clipboard support (@ids1024) (#461) Fix mpv version checking on windows (@ids1024) (#397) Add youtube_dl as dependency to Dockerfile (@PI-Victor) (#481) Internal api changes: \u00b6 The code is now split between several files (@ids1024) (#208) Add initial content api, for now only used for comments (@ids1024) Begin documenting internal apis using sphinx (@ids1024) Version 0.2.6 1 January 2016 Features: - Add browserplay command to play video in browser (rjvani) (#355 #390) - Make url command support multiple url, and allow loading urls from file (paulnicolet) (#90 #391) - Make youtube id available to download command (ids1024) (#375) - Make pagination work properly for all lists of songs (local playlists, etc.) and make them all support the dump command (ids1024) (#201) - Show warning when adding duplicate track to playlist (BensonQiu) (#374 #383) Bug fixes: - Support playlists longer than 200 items (ids1024) (#192) - Make dapl download complete playlist (JKatzwinkel) (#294 #325) - Use pyperclip instead of xerox, fixing clipboard on linux (ids1024) (#311) - Fix error message on windows when video title has & (ids1024) (#321) - Run notifier command in background (hrnr) (#339) - Correctly handle -v option of play (TimoDritschler) (#352) - Make it possible to use a pager with --help (livingBEEF) (#349) - Allow mplayer for https streams if version is new enough (ids1024 Evidlo paddatrapper) (#315 #336 #317) - Use mpv.com instead of mpv.exe on windows (ids1024) Internal API changes: - Split code into several files (still a work in progress) (ids1024) (#208) - Use a python decorator to declare commands (ids1024) - Create a paginatesongs() function for handling the pagination and dump command uniformly as mentioned in features (#399) (ids1024) - Various others There have been various other small bug fixes and internal API changes. Use git log v0.2.5..0.2.6 to see all of them. Version 0.2.5 1 June 2015 Support python 3 only (will not run with python 2) Fix progress bar bug on Windows (#215, #223) Fix bug in playlist search (#282) Add user_order setting for separate order of user searches (lol768) (#277) Add mix command (lol768) (#241, #283) Add page count with total number of pages and current page (JKatzwinkel) Fix UnicodeEncodeError on non-unicode terminals Install .desktop in setup.py so it does not have to be installed manually required for Ubuntu sound menu support Version 0.2.4 13 May 2015 Fix issue with rate-limiting in \"album\" command (#217) Implement support for MPRIS (hrnr and ids1024) (#191, #210) Fix display issue with small terminal width (#215) Use version 3 of the youtube api (JKatzwinkel, ids1024, and lol768) (#256) version 2 was disabled by youtube and no longer works Version 0.2.3 17 February 2015 Fix issue with opening old playlist file (#214) Fix issue with \"set\" command Metadata tagging of downloaded audio files requires ffmpeg or avconv early implementation, uses YouTube video title, needs more work Version 0.2.2 14 February 2015 Implement skip to previous track (ids1024) #175 #18 #14 Use > and < keys for next and prev track, q for quit (was ctrl-c) mpv / mplayer input.conf can be imported to use custom keymappings Implement optional external download application (ids1024 and np1) #198 #132 enter \"help dl-command\" for more info Show stream quality on status line (Brebiche38) #134 #163 Implement support for creating Windows builds with py2exe (ids1024) #190 Use setup.py in py2exe branch Fix progress bar for mpv 0.7 (ids1024) #155 #161 Resolves issues with playback looping Fix mps-youtube does not run on FreeBSD (nivit) Fix YouTube comments overshoot window size Fix issue with audio remux when using d download command Version 0.2.1 27 November 2014 [Bugfix] - Detect installed player on installation (#149) Version 0.2.0 25 November 2014 Auto detect terminal window size Transcode audio to MP3 and other formats (requires ffmpeg or avconv) Enabled da and dv commands for playlist search results Added dapl and dvpl to download YouTube playlist audio/video by url/id to a separate subdirectory (mtahmed) #110 Progress indicator now works with mpv (previously only mplayer) Added option to show system notifications (Alex Nisnevich) #95 (can be used with libnotify - notify-send on linux) Added overwrite true/false option for downloads (mtahmed) #93 (skips download if downloaded file already exists) Added copy to clipboard feature #97 (requires python xerox module and xclip on linux or pywin32 on windows) Remux audio downloads for better file compatibility (#135) [Bugfix] - Accept two-character length usernames (#99) [Bugfix] - Expand ~ character in download directory setting (punchagan) [Bugfix] - Don't truncate filename (YoussF) #122 [Bugfix] - Exit with correct status code Version 0.01.46 May 18 2014 Added c to view comments for a video (first 50 comments, no reply-comments) Added feature to match album tracks using MusicBrainz (vixus0) To search albums, enter \"album\" optionally followed by album title Custom formatted search result list using \"set columns\" command Optionally shows: rating, likes, dislikes, views, user, date, category and comments (number of) in search results Added \"set order \" command for specifying search result ordering Added \"set console-width\" for setting output width (default 80) Added uploaded date in video info display (request #64) Added likes / dislikes in video info display Version 0.01.44 Mar 27 2014 Added max_res config item for selecting video resolution (request 56) Added window_size and window_pos for selecting size / position of player Improved handling of playlist file read/write (issue 66) Revert to lower quality on unavailable/corrupt streams (issue 65) Enabled multiple invocation commands (comma separated) (request 61) Eg: mpsyt //the doors, 1, shuffle, 1-3-a, quit Improved url caching Added shuffle command (no arguments, shuffles displayed items) Handle 'video not available in your country' during multiple downloads Fix UnicodeDecodeError in mplayer progress parsing (issue 58) Fix UnicodeEncodeError under Windows with Python 2.7 (issue 59) Version 0.01.41 Mar 14 2014 new configuration option, max_results - sets number of returned results (1 - 50) pl now accepts YouTube playlist id's as well as url's Fix error in download of .m4a files when mplayer is set as player. Added option for downloading multiple items eg. da 1-4 or dv 3,5,6 Version 0.01.40 Mar 11 2014 Bugfix release, corrects UnicodeDecode error Version 0.01.39 Mar 10 2014 Features: - Added time / progress bar indicator. Big thanks to Thomas L\u00c9VEIL! (mplayer only) - Added command to retrieve YouTube user playlists; userpl {username} or upl {username} - Added command to retrieve related videos; r{number} - playurl now respects -f, -w, and -a flags (fullscreen, window or audio) - Implemented input history persistence (uses readline, linux only) - Implemented non-interactive mode for command line invocation with playurl - Implemented less interactive mode for command line invocation with dlurl Changes: - // or .. prefix to search for YouTube playlists (was plsearch / pls) Help / Documentation: - help will show relevant help topic page e.g., help dlurl - Documented configuration options (\"set\" commands) - Re-authored some help categories - Changed help to help , removed menu from help pages Bugfixes - mplayer / mpv window now displays content title instead of url - Fixed issue with Python3 terminal output on playback ctrl-c interrupt - Fixed issue with debug mode not logging to file - Changed year format in YT playlist result screen to last two digits. (Under some environments it was showing 4-digit years) Version 0.01.38 Mar 5 2014 Added i for YT playlist information display Added stream url preloading for first item of opened YT playlists Added last-updated date to YT playlist search result list Fixed UnicodeError when run in non-UTF8 environments Added more verbosity to --version command line option Added --debug command line option (logs to /mpsyt.log) Version 0.01.37 Mar 2 2014 Excluded YouTube paid videos from search results Added \"pl \" command to open YouTube playlist url Added \"plsearch \" command to search for YouTube playlists Added \"dump\" command to show entire YT playlist (useful for saving locally) Added \"undump\" command to undo dump (re-paginates YT playlist items) Added \"u \" command to list uploads by uploader of Added \"url \" command for retrieving a specific YT video Added \"playurl \" command for directly playing a YT video Added \"dlurl \" command for directly downloading a YT video Changed command to list user uploads, new syntax is \"user \" Added mpsyt --version flag for printing version info Added mpsyt --help flag for printing help text Fixed indentation bug when scrolling through readline history Version 0.01.36 Feb 27 2014 Wait for preloading item if it is selected while preloading Fix bug where -a audio override is sometimes ignored Version 0.01.35 Feb 25 2014 Faster opening of audio streams with mpv (--demuxer-lavf-o=fflags=+ignid argument added for m4a streams) Faster opening of audio streams with mplayer (reject m4a streams, prefer ogg streams) (fallback to video stream and suppress video when no ogg available) Version 0.01.34 Feb 22 2014 Fix bug: fails when no playlist file exists Version 0.01.33 Feb 22 2014 Changed structure of playlist file. Now consumes KB's rather than MB's Same playlist file shared between Python2.7+ and Python3+ (was separate) Improved display alignment for Russian text Preload of url fails silently on unobtainable items (previously crashed) Added prompt to mux audio on m4v download (experimental) Version 0.01.32 Feb 17 2014 Improve display alignment with certain unicode characters Fix crash when using 'set' command on Windows (thomasleveil) Version 0.01.31 Feb 13 2014 Migrate location of config directory to reflect new name (~/.config/mps-youtube)","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#v280-2022-02-28","text":"","title":"v2.8.0 (2022-02-28)"},{"location":"changelog/#feature","text":"helptext: Help changelog ( 0643941 ) setup: Extras dependencies for mpris ( 936e890 )","title":"Feature"},{"location":"changelog/#fix","text":"","title":"Fix"},{"location":"changelog/#37-use-set-pages-command-to-config-how-many-search-result-pages-to-show-2baec5f","text":"","title":"37 use set pages command to config how many search result pages to show (2baec5f)"},{"location":"changelog/#44-dont-run-init-when-importing-mps_youtube-a072c22","text":"mpris: Handle no data on time-pos ( 8bb29d3 )","title":"44 dont run init when importing mps_youtube (a072c22)"},{"location":"changelog/#39-key-error-data-834ed5b","text":"","title":"39 key error 'data' (834ed5b)"},{"location":"changelog/#38-improved-help-menu-responsiveness-972b4ef","text":"","title":"38 improved help menu responsiveness (972b4ef)"},{"location":"changelog/#35-remove-api-key-instructions-4f1fee3","text":"","title":"35 remove api key instructions (4f1fee3)"},{"location":"changelog/#24-colorama-support-for-windows-9cf2616","text":"","title":"24 colorama support for windows (9cf2616)"},{"location":"changelog/#v270-2022-02-19","text":"","title":"v2.7.0 (2022-02-19)"},{"location":"changelog/#feature_1","text":"Use yewtube over tor using torsocks \ud83d\udd25 ( 1e9c4ce )","title":"Feature"},{"location":"changelog/#v269-2022-02-19","text":"","title":"v2.6.9 (2022-02-19)"},{"location":"changelog/#fix_1","text":"","title":"Fix"},{"location":"changelog/#28-show-changelog-with-help-new-command-d52b65d","text":"","title":"28 show changelog with help new command (d52b65d)"},{"location":"changelog/#v268-2022-02-19","text":"","title":"v2.6.8 (2022-02-19)"},{"location":"changelog/#fix_2","text":"fixed #26 album search working now without youtube api ( 9c3ae03 )","title":"Fix"},{"location":"changelog/#v267-2022-02-19","text":"","title":"v2.6.7 (2022-02-19)"},{"location":"changelog/#fix_3","text":"Check for app updates ( eabfb52 ) Don't crash if playlists / history file has invalid youtube id fixed #24 ( 323d5d8 )","title":"Fix"},{"location":"changelog/#v266-2022-02-18","text":"","title":"v2.6.6 (2022-02-18)"},{"location":"changelog/#fix_4","text":"Playlists are working again fixed #18 ( bfceee4 ) Buffersize warning ( d185c3f ) g: Mpv msglevel ( 062b125 )","title":"Fix"},{"location":"changelog/#v265-2022-02-17","text":"","title":"v2.6.5 (2022-02-17)"},{"location":"changelog/#fix_5","text":"Default player priority is vlc > mpv > mplayer on first install fixed #16 ( 35409eb ) mplayer: _get_mplayer_version ( ab21c5d ) Bring back requirements.txt to life ( ff6e59d ) util.uea_pad: Handle AttributeError on t.split ( 1643266 )","title":"Fix"},{"location":"changelog/#v264-2022-02-16","text":"","title":"v2.6.4 (2022-02-16)"},{"location":"changelog/#fix_6","text":"Duplicate changelog and readme files ( 0265ef7 )","title":"Fix"},{"location":"changelog/#v263-2022-02-16","text":"","title":"v2.6.3 (2022-02-16)"},{"location":"changelog/#fix_7","text":"Welcome from semantic release python ( c237a68 )","title":"Fix"},{"location":"changelog/#yewtube-was-forked-from-mps-youtube","text":"","title":"yewtube was forked from mps-youtube"},{"location":"changelog/#features","text":"was made to work without YouTube API v3 play music in vlc with no gui Version 0.2.8 17 February 2018","title":"Features"},{"location":"changelog/#features_1","text":"Lastfm scrobbling (@rien333) (#758) splaylist and suser commands for Spotify (@ritiek) (#678) Autoplay support (@nikhilweee) (#594) genpl command (@nishanthkarthik) (#642) video_format configuration setting (@Vrihub) (#656) live command for live streams (@Razesdark) (#635) Add time column (@akaWolf) (#582) Add video ID column (@Razesdark) (#627) Allow filtering search by duration (@jas32096) (#548) Allow filtering search by date (@jas32096) (#553) Add history recent to display history without duplicates (@srvanrell) (#510) --no-textart to disable ascii art (for screenreaders) (@Gongreg) (#517) set_title option to disable setting window title (@ardrabczyk) (#498) Add s command for getting stream information (@ritiek) (#675) Add option to disable mpris (@hrnr) (#728) Generate playlist from video description (@Razesdark) (#649)","title":"Features:"},{"location":"changelog/#enhancements","text":"Store playlists as m3u files instead of binary (@kraetzin) (#682) Show replies when displaying comments (@paulfertser) (#677) Use https urls for album art (@vszakats) (#574) When using \"repeat\" with mpv, keep player running (@ritiek) (#660) Display artist/album in mpris using lastfm (@vn-ki) (#739) Use channel.list API for user search (@Razesdark) (#628) Maintain volume across songs with mpv (@Razesdark) (#720) Prevent mpris from crashing the main process (@hrnr) (#728)","title":"Enhancements:"},{"location":"changelog/#bug-fixes","text":"Fix mpris seeking with recent mpv vesions (@mg6) (#687) Fix removing video from multi-page playlist (@kraetzin) (#695) Skip unavailable tracks (@ritiek) (#734) Correctly display minutes/seconds (@Laxa) (#748) Handle null time-pos from mpv (@pritambaral) (#519) Fix da/dv command regex (@Vrihub) (#691) Skip channels in video/playlist searches (@ritiek) (#664) Fix divide by zero error (@ids1024) (#620) Use git log v0.2.7.1..v0.2.8 to see all changes, including various minor fixes, documentation changes, etc. not included here. Version 0.2.7.1 6 July 2016","title":"Bug fixes:"},{"location":"changelog/#bug-fixes_1","text":"Fix pickle error (@ids1024) (#503) Install LICENSE, README.md, and CHANGELOG as package_data (@ids1024) Update youtube-dl in py2exe build (@ids1024) Version 0.2.7 27 June 2016","title":"Bug fixes:"},{"location":"changelog/#features_2","text":"Setting for default audio format (@nishanthkarthik) (#71 #466 #467) Search history with history command (@kraetzin) (#344 #472) Add syntax for repeating a track several times (@ghallak) (#437 #490) Reverse command (@kraetzin) (#422 #473) New daurl <url> command (@maricn) (#402)","title":"Features:"},{"location":"changelog/#enhancements_1","text":"Pass --no-ytdl to mpv (@ids1024) (#492) Do not suppress mpv output in debug mode (@ids1024) Print traceback in debug mode (@ids1024) Speed up checkupdate by avoiding redirects (@ids1024) (#454) Pass --play-and-exit if vlc is used as a player (@ids1024)`","title":"Enhancements:"},{"location":"changelog/#bug-fixes_2","text":"Fix error with python 3.3 (@ids1024) (#414) Fix maxres bug (@ids1024) (#430) Fix playlist cache bug in info command (@ids1024) (#468) Fix usersearch argument error (@ids1024) (#469 #482) Fix progress bar with new mpv versions (@ids1024) (#470 #485) Fix syntax error with set command (@ids1024) (#419) Fix syntax error with -w, -f, -a (@ids1024) (#420) Fix clipboard support (@ids1024) (#461) Fix mpv version checking on windows (@ids1024) (#397) Add youtube_dl as dependency to Dockerfile (@PI-Victor) (#481)","title":"Bug fixes:"},{"location":"changelog/#internal-api-changes","text":"The code is now split between several files (@ids1024) (#208) Add initial content api, for now only used for comments (@ids1024) Begin documenting internal apis using sphinx (@ids1024) Version 0.2.6 1 January 2016 Features: - Add browserplay command to play video in browser (rjvani) (#355 #390) - Make url command support multiple url, and allow loading urls from file (paulnicolet) (#90 #391) - Make youtube id available to download command (ids1024) (#375) - Make pagination work properly for all lists of songs (local playlists, etc.) and make them all support the dump command (ids1024) (#201) - Show warning when adding duplicate track to playlist (BensonQiu) (#374 #383) Bug fixes: - Support playlists longer than 200 items (ids1024) (#192) - Make dapl download complete playlist (JKatzwinkel) (#294 #325) - Use pyperclip instead of xerox, fixing clipboard on linux (ids1024) (#311) - Fix error message on windows when video title has & (ids1024) (#321) - Run notifier command in background (hrnr) (#339) - Correctly handle -v option of play (TimoDritschler) (#352) - Make it possible to use a pager with --help (livingBEEF) (#349) - Allow mplayer for https streams if version is new enough (ids1024 Evidlo paddatrapper) (#315 #336 #317) - Use mpv.com instead of mpv.exe on windows (ids1024) Internal API changes: - Split code into several files (still a work in progress) (ids1024) (#208) - Use a python decorator to declare commands (ids1024) - Create a paginatesongs() function for handling the pagination and dump command uniformly as mentioned in features (#399) (ids1024) - Various others There have been various other small bug fixes and internal API changes. Use git log v0.2.5..0.2.6 to see all of them. Version 0.2.5 1 June 2015 Support python 3 only (will not run with python 2) Fix progress bar bug on Windows (#215, #223) Fix bug in playlist search (#282) Add user_order setting for separate order of user searches (lol768) (#277) Add mix command (lol768) (#241, #283) Add page count with total number of pages and current page (JKatzwinkel) Fix UnicodeEncodeError on non-unicode terminals Install .desktop in setup.py so it does not have to be installed manually required for Ubuntu sound menu support Version 0.2.4 13 May 2015 Fix issue with rate-limiting in \"album\" command (#217) Implement support for MPRIS (hrnr and ids1024) (#191, #210) Fix display issue with small terminal width (#215) Use version 3 of the youtube api (JKatzwinkel, ids1024, and lol768) (#256) version 2 was disabled by youtube and no longer works Version 0.2.3 17 February 2015 Fix issue with opening old playlist file (#214) Fix issue with \"set\" command Metadata tagging of downloaded audio files requires ffmpeg or avconv early implementation, uses YouTube video title, needs more work Version 0.2.2 14 February 2015 Implement skip to previous track (ids1024) #175 #18 #14 Use > and < keys for next and prev track, q for quit (was ctrl-c) mpv / mplayer input.conf can be imported to use custom keymappings Implement optional external download application (ids1024 and np1) #198 #132 enter \"help dl-command\" for more info Show stream quality on status line (Brebiche38) #134 #163 Implement support for creating Windows builds with py2exe (ids1024) #190 Use setup.py in py2exe branch Fix progress bar for mpv 0.7 (ids1024) #155 #161 Resolves issues with playback looping Fix mps-youtube does not run on FreeBSD (nivit) Fix YouTube comments overshoot window size Fix issue with audio remux when using d download command Version 0.2.1 27 November 2014 [Bugfix] - Detect installed player on installation (#149) Version 0.2.0 25 November 2014 Auto detect terminal window size Transcode audio to MP3 and other formats (requires ffmpeg or avconv) Enabled da and dv commands for playlist search results Added dapl and dvpl to download YouTube playlist audio/video by url/id to a separate subdirectory (mtahmed) #110 Progress indicator now works with mpv (previously only mplayer) Added option to show system notifications (Alex Nisnevich) #95 (can be used with libnotify - notify-send on linux) Added overwrite true/false option for downloads (mtahmed) #93 (skips download if downloaded file already exists) Added copy to clipboard feature #97 (requires python xerox module and xclip on linux or pywin32 on windows) Remux audio downloads for better file compatibility (#135) [Bugfix] - Accept two-character length usernames (#99) [Bugfix] - Expand ~ character in download directory setting (punchagan) [Bugfix] - Don't truncate filename (YoussF) #122 [Bugfix] - Exit with correct status code Version 0.01.46 May 18 2014 Added c to view comments for a video (first 50 comments, no reply-comments) Added feature to match album tracks using MusicBrainz (vixus0) To search albums, enter \"album\" optionally followed by album title Custom formatted search result list using \"set columns\" command Optionally shows: rating, likes, dislikes, views, user, date, category and comments (number of) in search results Added \"set order \" command for specifying search result ordering Added \"set console-width\" for setting output width (default 80) Added uploaded date in video info display (request #64) Added likes / dislikes in video info display Version 0.01.44 Mar 27 2014 Added max_res config item for selecting video resolution (request 56) Added window_size and window_pos for selecting size / position of player Improved handling of playlist file read/write (issue 66) Revert to lower quality on unavailable/corrupt streams (issue 65) Enabled multiple invocation commands (comma separated) (request 61) Eg: mpsyt //the doors, 1, shuffle, 1-3-a, quit Improved url caching Added shuffle command (no arguments, shuffles displayed items) Handle 'video not available in your country' during multiple downloads Fix UnicodeDecodeError in mplayer progress parsing (issue 58) Fix UnicodeEncodeError under Windows with Python 2.7 (issue 59) Version 0.01.41 Mar 14 2014 new configuration option, max_results - sets number of returned results (1 - 50) pl now accepts YouTube playlist id's as well as url's Fix error in download of .m4a files when mplayer is set as player. Added option for downloading multiple items eg. da 1-4 or dv 3,5,6 Version 0.01.40 Mar 11 2014 Bugfix release, corrects UnicodeDecode error Version 0.01.39 Mar 10 2014 Features: - Added time / progress bar indicator. Big thanks to Thomas L\u00c9VEIL! (mplayer only) - Added command to retrieve YouTube user playlists; userpl {username} or upl {username} - Added command to retrieve related videos; r{number} - playurl now respects -f, -w, and -a flags (fullscreen, window or audio) - Implemented input history persistence (uses readline, linux only) - Implemented non-interactive mode for command line invocation with playurl - Implemented less interactive mode for command line invocation with dlurl Changes: - // or .. prefix to search for YouTube playlists (was plsearch / pls) Help / Documentation: - help will show relevant help topic page e.g., help dlurl - Documented configuration options (\"set\" commands) - Re-authored some help categories - Changed help to help , removed menu from help pages Bugfixes - mplayer / mpv window now displays content title instead of url - Fixed issue with Python3 terminal output on playback ctrl-c interrupt - Fixed issue with debug mode not logging to file - Changed year format in YT playlist result screen to last two digits. (Under some environments it was showing 4-digit years) Version 0.01.38 Mar 5 2014 Added i for YT playlist information display Added stream url preloading for first item of opened YT playlists Added last-updated date to YT playlist search result list Fixed UnicodeError when run in non-UTF8 environments Added more verbosity to --version command line option Added --debug command line option (logs to /mpsyt.log) Version 0.01.37 Mar 2 2014 Excluded YouTube paid videos from search results Added \"pl \" command to open YouTube playlist url Added \"plsearch \" command to search for YouTube playlists Added \"dump\" command to show entire YT playlist (useful for saving locally) Added \"undump\" command to undo dump (re-paginates YT playlist items) Added \"u \" command to list uploads by uploader of Added \"url \" command for retrieving a specific YT video Added \"playurl \" command for directly playing a YT video Added \"dlurl \" command for directly downloading a YT video Changed command to list user uploads, new syntax is \"user \" Added mpsyt --version flag for printing version info Added mpsyt --help flag for printing help text Fixed indentation bug when scrolling through readline history Version 0.01.36 Feb 27 2014 Wait for preloading item if it is selected while preloading Fix bug where -a audio override is sometimes ignored Version 0.01.35 Feb 25 2014 Faster opening of audio streams with mpv (--demuxer-lavf-o=fflags=+ignid argument added for m4a streams) Faster opening of audio streams with mplayer (reject m4a streams, prefer ogg streams) (fallback to video stream and suppress video when no ogg available) Version 0.01.34 Feb 22 2014 Fix bug: fails when no playlist file exists Version 0.01.33 Feb 22 2014 Changed structure of playlist file. Now consumes KB's rather than MB's Same playlist file shared between Python2.7+ and Python3+ (was separate) Improved display alignment for Russian text Preload of url fails silently on unobtainable items (previously crashed) Added prompt to mux audio on m4v download (experimental) Version 0.01.32 Feb 17 2014 Improve display alignment with certain unicode characters Fix crash when using 'set' command on Windows (thomasleveil) Version 0.01.31 Feb 13 2014 Migrate location of config directory to reflect new name (~/.config/mps-youtube)","title":"Internal api changes:"},{"location":"contributing/","text":"Contributing for mps-youtube \u00b6 Contributions are very much appreciated! Pull requests should be based on and submitted to the \"develop\" branch. Please raise an issue to discuss what you plan to implement or change before you start if it is going to involve a lot of work on your part. Please keep pull requests specific, do not make many disparate changes or new features in one request. A separate pull request for each feature change is preferred. Please ensure your changes work in Python 3.3+ and Windows. Code conventions \u00b6 Maximum line length is 80 characters Follow the line-spacing style that is already in place. Ensure all functions and classes have a PEP257 compliant docstring and the code is PEP8 compliant. Documentation \u00b6 Install required extra docs package to setup mkdocs: pip install -e \".[docs]\" To run built-in dev server: mkdocs serve To deploy documentation to github page: mkdocs gh-deploy","title":"Contributing"},{"location":"contributing/#contributing-for-mps-youtube","text":"Contributions are very much appreciated! Pull requests should be based on and submitted to the \"develop\" branch. Please raise an issue to discuss what you plan to implement or change before you start if it is going to involve a lot of work on your part. Please keep pull requests specific, do not make many disparate changes or new features in one request. A separate pull request for each feature change is preferred. Please ensure your changes work in Python 3.3+ and Windows.","title":"Contributing for mps-youtube"},{"location":"contributing/#code-conventions","text":"Maximum line length is 80 characters Follow the line-spacing style that is already in place. Ensure all functions and classes have a PEP257 compliant docstring and the code is PEP8 compliant.","title":"Code conventions"},{"location":"contributing/#documentation","text":"Install required extra docs package to setup mkdocs: pip install -e \".[docs]\" To run built-in dev server: mkdocs serve To deploy documentation to github page: mkdocs gh-deploy","title":"Documentation"},{"location":"license/","text":"GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007 Copyright (C) 2007 Free Software Foundation, Inc. {http://fsf.org/} Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. Preamble The GNU General Public License is a free, copyleft license for software and other kinds of works. The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program--to make sure it remains free software for all its users. We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors. You can apply it to your programs, too. When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things. To protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights. Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others. For example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights. Developers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and/or modify it. For the developers' and authors' protection, the GPL clearly explains that there is no warranty for this free software. For both users' and authors' sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions. Some devices are designed to deny users access to install or run modified versions of the software inside them, although the manufacturer can do so. This is fundamentally incompatible with the aim of protecting users' freedom to change the software. The systematic pattern of such abuse occurs in the area of products for individuals to use, which is precisely where it is most unacceptable. Therefore, we have designed this version of the GPL to prohibit the practice for those products. If such problems arise substantially in other domains, we stand ready to extend this provision to those domains in future versions of the GPL, as needed to protect the freedom of users. Finally, every program is threatened constantly by software patents. States should not allow patents to restrict development and use of software on general-purpose computers, but in those that do, we wish to avoid the special danger that patents applied to a free program could make it effectively proprietary. To prevent this, the GPL assures that patents cannot be used to render the program non-free. The precise terms and conditions for copying, distribution and modification follow. TERMS AND CONDITIONS 0. Definitions. \"This License\" refers to version 3 of the GNU General Public License. \"Copyright\" also means copyright-like laws that apply to other kinds of works, such as semiconductor masks. \"The Program\" refers to any copyrightable work licensed under this License. Each licensee is addressed as \"you\". \"Licensees\" and \"recipients\" may be individuals or organizations. To \"modify\" a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a \"modified version\" of the earlier work or a work \"based on\" the earlier work. A \"covered work\" means either the unmodified Program or a work based on the Program. To \"propagate\" a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well. To \"convey\" a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying. An interactive user interface displays \"Appropriate Legal Notices\" to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion. 1. Source Code. The \"source code\" for a work means the preferred form of the work for making modifications to it. \"Object code\" means any non-source form of a work. A \"Standard Interface\" means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language. The \"System Libraries\" of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A \"Major Component\", in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it. The \"Corresponding Source\" for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work. The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source. The Corresponding Source for a work in source code form is that same work. 2. Basic Permissions. All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law. You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you. Conveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary. 3. Protecting Users' Legal Rights From Anti-Circumvention Law. No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures. When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures. 4. Conveying Verbatim Copies. You may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program. You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee. 5. Conveying Modified Source Versions. You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions: a) The work must carry prominent notices stating that you modified it, and giving a relevant date. b) The work must carry prominent notices stating that it is released under this License and any conditions added under section 7. This requirement modifies the requirement in section 4 to \"keep intact all notices\". c) You must license the entire work, as a whole, under this License to anyone who comes into possession of a copy. This License will therefore apply, along with any applicable section 7 additional terms, to the whole of the work, and all its parts, regardless of how they are packaged. This License gives no permission to license the work in any other way, but it does not invalidate such permission if you have separately received it. d) If the work has interactive user interfaces, each must display Appropriate Legal Notices; however, if the Program has interactive interfaces that do not display Appropriate Legal Notices, your work need not make them do so. A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an \"aggregate\" if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate. 6. Conveying Non-Source Forms. You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways: a) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by the Corresponding Source fixed on a durable physical medium customarily used for software interchange. b) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by a written offer, valid for at least three years and valid for as long as you offer spare parts or customer support for that product model, to give anyone who possesses the object code either (1) a copy of the Corresponding Source for all the software in the product that is covered by this License, on a durable physical medium customarily used for software interchange, for a price no more than your reasonable cost of physically performing this conveying of source, or (2) access to copy the Corresponding Source from a network server at no charge. c) Convey individual copies of the object code with a copy of the written offer to provide the Corresponding Source. This alternative is allowed only occasionally and noncommercially, and only if you received the object code with such an offer, in accord with subsection 6b. d) Convey the object code by offering access from a designated place (gratis or for a charge), and offer equivalent access to the Corresponding Source in the same way through the same place at no further charge. You need not require recipients to copy the Corresponding Source along with the object code. If the place to copy the object code is a network server, the Corresponding Source may be on a different server (operated by you or a third party) that supports equivalent copying facilities, provided you maintain clear directions next to the object code saying where to find the Corresponding Source. Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements. e) Convey the object code using peer-to-peer transmission, provided you inform other peers where the object code and Corresponding Source of the work are being offered to the general public at no charge under subsection 6d. A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work. A \"User Product\" is either (1) a \"consumer product\", which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, \"normally used\" refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product. \"Installation Information\" for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made. If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM). The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network. Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying. 7. Additional Terms. \"Additional permissions\" are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions. When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission. Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms: a) Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16 of this License; or b) Requiring preservation of specified reasonable legal notices or author attributions in that material or in the Appropriate Legal Notices displayed by works containing it; or c) Prohibiting misrepresentation of the origin of that material, or requiring that modified versions of such material be marked in reasonable ways as different from the original version; or d) Limiting the use for publicity purposes of names of licensors or authors of the material; or e) Declining to grant rights under trademark law for use of some trade names, trademarks, or service marks; or f) Requiring indemnification of licensors and authors of that material by anyone who conveys the material (or modified versions of it) with contractual assumptions of liability to the recipient, for any liability that these contractual assumptions directly impose on those licensors and authors. All other non-permissive additional terms are considered \"further restrictions\" within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying. If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms. Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way. 8. Termination. You may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11). However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10. 9. Acceptance Not Required for Having Copies. You are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so. 10. Automatic Licensing of Downstream Recipients. Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License. An \"entity transaction\" is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts. You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it. 11. Patents. A \"contributor\" is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor's \"contributor version\". A contributor's \"essential patent claims\" are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, \"control\" includes the right to grant patent sublicenses in a manner consistent with the requirements of this License. Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version. In the following three paragraphs, a \"patent license\" is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To \"grant\" such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party. If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. \"Knowingly relying\" means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid. If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it. A patent license is \"discriminatory\" if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007. Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law. 12. No Surrender of Others' Freedom. If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program. 13. Use with the GNU Affero General Public License. Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU Affero General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the special requirements of the GNU Affero General Public License, section 13, concerning interaction through a network will apply to the combination as such. 14. Revised Versions of this License. The Free Software Foundation may publish revised and/or new versions of the GNU General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU General Public License, you may choose any version ever published by the Free Software Foundation. If the Program specifies that a proxy can decide which future versions of the GNU General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program. Later license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version. 15. Disclaimer of Warranty. THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. 16. Limitation of Liability. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. 17. Interpretation of Sections 15 and 16. If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee. END OF TERMS AND CONDITIONS How to Apply These Terms to Your New Programs If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms. To do so, attach the following notices to the program. It is safest to attach them to the start of each source file to most effectively state the exclusion of warranty; and each file should have at least the \"copyright\" line and a pointer to where the full notice is found. {one line to give the program's name and a brief idea of what it does.} Copyright (C) {year} {name of author} This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see {http://www.gnu.org/licenses/}. Also add information on how to contact you by electronic and paper mail. If the program does terminal interaction, make it output a short notice like this when it starts in an interactive mode: <program> Copyright (C) <year> <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'. This is free software, and you are welcome to redistribute it under certain conditions; type `show c' for details. The hypothetical commands `show w' and `show c' should show the appropriate parts of the General Public License. Of course, your program's commands might be different; for a GUI interface, you would use an \"about box\". You should also get your employer (if you work as a programmer) or school, if any, to sign a \"copyright disclaimer\" for the program, if necessary. For more information on this, and how to apply and follow the GNU GPL, see {http://www.gnu.org/licenses/}. The GNU General Public License does not permit incorporating your program into proprietary programs. If your program is a subroutine library, you may consider it more useful to permit linking proprietary applications with the library. If this is what you want to do, use the GNU Lesser General Public License instead of this License. But first, please read {http://www.gnu.org/philosophy/why-not-lgpl.html}.","title":"License"},{"location":"reference/SUMMARY/","text":"mps_youtube __init__.py c.py cache.py commands __init__.py album_search.py config.py download.py generate_playlist.py lastfm.py local_playlist.py misc.py play.py search.py songlist.py spotify_playlist.py content.py contentquery.py description_parser.py g.py helptext.py history.py init.py listview __init__.py base.py livestream.py songtitle.py user.py main.py pafy.py paths.py player.py players GenericPlayer.py __init__.py mplayer.py mpv.py vlc.py playlist.py playlists.py screen.py streams.py terminalsize.py util.py","title":"SUMMARY"},{"location":"reference/__init__/","text":"","title":"__init__.py"},{"location":"reference/c/","text":"Module for holding colour code values. c ( colour , text ) \u00b6 Return coloured text. Source code in mps_youtube/c.py def c ( colour , text ): \"\"\" Return coloured text. \"\"\" colours = { 'r' : r , 'g' : g , 'y' : y , 'b' : b , 'p' : p } return colours [ colour ] + text + w charcount ( s ) \u00b6 Return number of characters in string, with ANSI color codes excluded. Source code in mps_youtube/c.py def charcount ( s ): \"\"\" Return number of characters in string, with ANSI color codes excluded. \"\"\" return len ( ansirx . sub ( '' , s ))","title":"c.py"},{"location":"reference/c/#mps_youtube.c.c","text":"Return coloured text. Source code in mps_youtube/c.py def c ( colour , text ): \"\"\" Return coloured text. \"\"\" colours = { 'r' : r , 'g' : g , 'y' : y , 'b' : b , 'p' : p } return colours [ colour ] + text + w","title":"c()"},{"location":"reference/c/#mps_youtube.c.charcount","text":"Return number of characters in string, with ANSI color codes excluded. Source code in mps_youtube/c.py def charcount ( s ): \"\"\" Return number of characters in string, with ANSI color codes excluded. \"\"\" return len ( ansirx . sub ( '' , s ))","title":"charcount()"},{"location":"reference/cache/","text":"load () \u00b6 Import cache file. Source code in mps_youtube/cache.py def load (): \"\"\" Import cache file. \"\"\" if os . path . isfile ( g . CACHEFILE ): try : with open ( g . CACHEFILE , \"rb\" ) as cf : cached = pickle . load ( cf ) # Note: will be none for yewtube 0.2.5 or earlier version = cached . get ( 'version' ) if 'streams' in cached : if version and version >= 1 : g . streams = cached [ 'streams' ] g . username_query_cache = cached [ 'userdata' ] else : g . streams = cached if 'pafy' in cached : pass #pafy.load_cache(cached['pafy']) dbg ( c . g + \" %s cached streams imported %s \" , str ( len ( g . streams )), c . w ) except ( EOFError , IOError ): dbg ( c . r + \"Cache file failed to open\" + c . w ) streams . prune () save () \u00b6 Save stream cache. Source code in mps_youtube/cache.py def save (): \"\"\" Save stream cache. \"\"\" caches = dict ( version = CACHE_VERSION , streams = g . streams , userdata = g . username_query_cache #,pafy=pafy.dump_cache() ) with open ( g . CACHEFILE , \"wb\" ) as cf : pickle . dump ( caches , cf , protocol = 2 ) dbg ( c . p + \"saved cache file: \" + g . CACHEFILE + c . w )","title":"cache.py"},{"location":"reference/cache/#mps_youtube.cache.load","text":"Import cache file. Source code in mps_youtube/cache.py def load (): \"\"\" Import cache file. \"\"\" if os . path . isfile ( g . CACHEFILE ): try : with open ( g . CACHEFILE , \"rb\" ) as cf : cached = pickle . load ( cf ) # Note: will be none for yewtube 0.2.5 or earlier version = cached . get ( 'version' ) if 'streams' in cached : if version and version >= 1 : g . streams = cached [ 'streams' ] g . username_query_cache = cached [ 'userdata' ] else : g . streams = cached if 'pafy' in cached : pass #pafy.load_cache(cached['pafy']) dbg ( c . g + \" %s cached streams imported %s \" , str ( len ( g . streams )), c . w ) except ( EOFError , IOError ): dbg ( c . r + \"Cache file failed to open\" + c . w ) streams . prune ()","title":"load()"},{"location":"reference/cache/#mps_youtube.cache.save","text":"Save stream cache. Source code in mps_youtube/cache.py def save (): \"\"\" Save stream cache. \"\"\" caches = dict ( version = CACHE_VERSION , streams = g . streams , userdata = g . username_query_cache #,pafy=pafy.dump_cache() ) with open ( g . CACHEFILE , \"wb\" ) as cf : pickle . dump ( caches , cf , protocol = 2 ) dbg ( c . p + \"saved cache file: \" + g . CACHEFILE + c . w )","title":"save()"},{"location":"reference/content/","text":"generate_playlist_display () \u00b6 Generate list of playlists. Source code in mps_youtube/content.py def generate_playlist_display (): \"\"\" Generate list of playlists. \"\"\" if not g . ytpls : g . message = c . r + \"No playlists found!\" return logo ( c . g ) + \" \\n\\n \" g . rprompt = page_msg ( g . current_page ) cw = getxy () . width fmtrow = \" %s%-5s %s %-12s %-8s %-2s%s \\n \" fmthd = \" %s%-5s %- {} s %-12s %-9s %-5s%s \\n \" . format ( cw - 36 ) head = ( c . ul , \"Item\" , \"Playlist\" , \"Author\" , \"Updated\" , \"Count\" , c . w ) out = \" \\n \" + fmthd % head for n , x in enumerate ( g . ytpls ): col = ( c . g if n % 2 == 0 else c . w ) length = x . get ( 'size' ) or \"?\" length = \" %4s \" % length title = x . get ( 'title' ) or \"unknown\" author = x . get ( 'author' ) or \"unknown\" updated = yt_datetime ( x . get ( 'updated' ))[ 1 ] title = uea_pad ( cw - 36 , title ) out += ( fmtrow % ( col , str ( n + 1 ), title , author [: 12 ], updated , str ( length ), c . w )) return out + \" \\n \" * ( 5 - len ( g . ytpls )) generate_songlist_display ( song = False , zeromsg = None ) \u00b6 Generate list of choices from a song list. Source code in mps_youtube/content.py def generate_songlist_display ( song = False , zeromsg = None ): \"\"\" Generate list of choices from a song list.\"\"\" # pylint: disable=R0914 if g . browse_mode == \"ytpl\" : return generate_playlist_display () max_results = getxy () . max_results if not g . model : g . message = zeromsg or \"Enter /search-term to search or [h]elp\" return logo ( c . g ) + \" \\n\\n \" g . rprompt = page_msg ( g . current_page ) have_meta = all ( x . ytid in g . meta for x in g . model ) user_columns = _get_user_columns () if have_meta else [] maxlength = max ( x . length for x in g . model ) lengthsize = 8 if maxlength > 35999 else 7 lengthsize = 6 if maxlength < 6000 else lengthsize reserved = 9 + lengthsize + len ( user_columns ) cw = getxy () . width cw -= 1 title_size = cw - sum ( 1 + x [ 'size' ] for x in user_columns ) - reserved before = [{ \"name\" : \"idx\" , \"size\" : 3 , \"heading\" : \"Num\" }, { \"name\" : \"title\" , \"size\" : title_size , \"heading\" : \"Title\" }] after = [{ \"name\" : \"length\" , \"size\" : lengthsize , \"heading\" : \"Length\" }] columns = before + user_columns + after for n , column in enumerate ( columns ): column [ 'idx' ] = n column [ 'sign' ] = \"-\" if not column [ 'name' ] == \"length\" else \"\" fmt = [ \"% {}{} s \" . format ( x [ 'sign' ], x [ 'size' ]) for x in columns ] fmtrow = fmt [ 0 : 1 ] + [ \" %s \" ] + fmt [ 2 :] fmt , fmtrow = \"\" . join ( fmt ) . strip (), \"\" . join ( fmtrow ) . strip () titles = tuple ([ x [ 'heading' ][: x [ 'size' ]] for x in columns ]) hrow = c . ul + fmt % titles + c . w out = \" \\n \" + hrow + \" \\n \" for n , x in enumerate ( g . model [: max_results ]): col = ( c . r if n % 2 == 0 else c . p ) if not song else c . b details = { 'title' : x . title , \"length\" : fmt_time ( x . length )} details = copy . copy ( g . meta [ x . ytid ]) if have_meta else details otitle = details [ 'title' ] details [ 'idx' ] = \" %2d \" % ( n + 1 ) details [ 'title' ] = uea_pad ( columns [ 1 ][ 'size' ], otitle ) #cat = details.get('category') or '-' #details['category'] = 'pafy.get_categoryname(cat)' details [ 'ytid' ] = x . ytid line = '' for z in columns : fieldsize , field , direction = z [ 'size' ], z [ 'name' ], \"<\" if z [ 'sign' ] == \"-\" else \">\" line += uea_pad ( fieldsize , details [ field ], direction ) if not columns [ - 1 ] == z : line += \" \" col = col if not song or song != g . model [ n ] else c . p line = col + line + c . w out += line + \" \\n \" return out + \" \\n \" * ( 5 - len ( g . model )) if not song else out logo ( col = None , version = '' ) \u00b6 Return text logo. Source code in mps_youtube/content.py def logo ( col = None , version = \"\" ): \"\"\" Return text logo. \"\"\" col = col if col else random . choice (( c . g , c . r , c . y , c . b , c . p , c . w )) logo_txt = r \"\"\" _ _ | | | | _ _ _____ _| |_ _ _| |__ ___ | | | |/ _ \\ \\ /\\ / / __| | | | '_ \\ / _ \\ | |_| | __/\\ V V /| |_| |_| | |_) | __/ \\__, |\\___| \\_/\\_/ \\__|\\__,_|_.__/ \\___| __/ | |___/ \"\"\" version = \" v\" + version if version else \"\" logo_txt = col + logo_txt + c . w + version lines = logo_txt . split ( \" \\n \" ) length = max ( len ( x ) for x in lines ) x , y , _ = getxy () indent = ( x - length - 1 ) // 2 newlines = ( y - 12 ) // 2 indent , newlines = ( 0 if x < 0 else x for x in ( indent , newlines )) lines = [ \" \" * indent + l for l in lines ] logo_txt = \" \\n \" . join ( lines ) + \" \\n \" * newlines return \"\" if g . debug_mode or g . no_textart else logo_txt page_msg ( page = 0 ) \u00b6 Format information about currently displayed page to a string. Source code in mps_youtube/content.py def page_msg ( page = 0 ): \"\"\" Format information about currently displayed page to a string. \"\"\" if isinstance ( g . content , PaginatedContent ): page_count = g . content . numPages () else : page_count = math . ceil ( g . result_count / getxy () . max_results ) if page_count > 1 : pagemsg = \" {}{} / {}{} \" #start_index = max_results * g.current_page return pagemsg . format ( '<' if page > 0 else '[' , \" %s%s%s \" % ( c . y , page + 1 , c . w ), page_count , '>' if page + 1 < page_count else ']' ) return None playlists_display () \u00b6 Produce a list of all playlists. Source code in mps_youtube/content.py def playlists_display (): \"\"\" Produce a list of all playlists. \"\"\" if not g . userpl : g . message = F ( \"no playlists\" ) return generate_songlist_display () if g . model else ( logo ( c . y ) + \" \\n\\n \" ) maxname = max ( len ( a ) for a in g . userpl ) out = \" {0} Local Playlists {1} \\n \" . format ( c . ul , c . w ) start = \" \" fmt = \" %s%s%-3s %-\" + str ( maxname + 3 ) + \"s %s %s%-7s%s %-5s%s \" head = ( start , c . b , \"ID\" , \"Name\" , c . b , c . b , \"Count\" , c . b , \"Duration\" , c . w ) out += \" \\n \" + fmt % head + \" \\n\\n \" for v , z in enumerate ( sorted ( g . userpl )): n , p = z , g . userpl [ z ] l = fmt % ( start , c . g , v + 1 , n , c . w , c . y , str ( len ( p )), c . y , p . duration , c . w ) + \" \\n \" out += l return out","title":"content.py"},{"location":"reference/content/#mps_youtube.content.generate_playlist_display","text":"Generate list of playlists. Source code in mps_youtube/content.py def generate_playlist_display (): \"\"\" Generate list of playlists. \"\"\" if not g . ytpls : g . message = c . r + \"No playlists found!\" return logo ( c . g ) + \" \\n\\n \" g . rprompt = page_msg ( g . current_page ) cw = getxy () . width fmtrow = \" %s%-5s %s %-12s %-8s %-2s%s \\n \" fmthd = \" %s%-5s %- {} s %-12s %-9s %-5s%s \\n \" . format ( cw - 36 ) head = ( c . ul , \"Item\" , \"Playlist\" , \"Author\" , \"Updated\" , \"Count\" , c . w ) out = \" \\n \" + fmthd % head for n , x in enumerate ( g . ytpls ): col = ( c . g if n % 2 == 0 else c . w ) length = x . get ( 'size' ) or \"?\" length = \" %4s \" % length title = x . get ( 'title' ) or \"unknown\" author = x . get ( 'author' ) or \"unknown\" updated = yt_datetime ( x . get ( 'updated' ))[ 1 ] title = uea_pad ( cw - 36 , title ) out += ( fmtrow % ( col , str ( n + 1 ), title , author [: 12 ], updated , str ( length ), c . w )) return out + \" \\n \" * ( 5 - len ( g . ytpls ))","title":"generate_playlist_display()"},{"location":"reference/content/#mps_youtube.content.generate_songlist_display","text":"Generate list of choices from a song list. Source code in mps_youtube/content.py def generate_songlist_display ( song = False , zeromsg = None ): \"\"\" Generate list of choices from a song list.\"\"\" # pylint: disable=R0914 if g . browse_mode == \"ytpl\" : return generate_playlist_display () max_results = getxy () . max_results if not g . model : g . message = zeromsg or \"Enter /search-term to search or [h]elp\" return logo ( c . g ) + \" \\n\\n \" g . rprompt = page_msg ( g . current_page ) have_meta = all ( x . ytid in g . meta for x in g . model ) user_columns = _get_user_columns () if have_meta else [] maxlength = max ( x . length for x in g . model ) lengthsize = 8 if maxlength > 35999 else 7 lengthsize = 6 if maxlength < 6000 else lengthsize reserved = 9 + lengthsize + len ( user_columns ) cw = getxy () . width cw -= 1 title_size = cw - sum ( 1 + x [ 'size' ] for x in user_columns ) - reserved before = [{ \"name\" : \"idx\" , \"size\" : 3 , \"heading\" : \"Num\" }, { \"name\" : \"title\" , \"size\" : title_size , \"heading\" : \"Title\" }] after = [{ \"name\" : \"length\" , \"size\" : lengthsize , \"heading\" : \"Length\" }] columns = before + user_columns + after for n , column in enumerate ( columns ): column [ 'idx' ] = n column [ 'sign' ] = \"-\" if not column [ 'name' ] == \"length\" else \"\" fmt = [ \"% {}{} s \" . format ( x [ 'sign' ], x [ 'size' ]) for x in columns ] fmtrow = fmt [ 0 : 1 ] + [ \" %s \" ] + fmt [ 2 :] fmt , fmtrow = \"\" . join ( fmt ) . strip (), \"\" . join ( fmtrow ) . strip () titles = tuple ([ x [ 'heading' ][: x [ 'size' ]] for x in columns ]) hrow = c . ul + fmt % titles + c . w out = \" \\n \" + hrow + \" \\n \" for n , x in enumerate ( g . model [: max_results ]): col = ( c . r if n % 2 == 0 else c . p ) if not song else c . b details = { 'title' : x . title , \"length\" : fmt_time ( x . length )} details = copy . copy ( g . meta [ x . ytid ]) if have_meta else details otitle = details [ 'title' ] details [ 'idx' ] = \" %2d \" % ( n + 1 ) details [ 'title' ] = uea_pad ( columns [ 1 ][ 'size' ], otitle ) #cat = details.get('category') or '-' #details['category'] = 'pafy.get_categoryname(cat)' details [ 'ytid' ] = x . ytid line = '' for z in columns : fieldsize , field , direction = z [ 'size' ], z [ 'name' ], \"<\" if z [ 'sign' ] == \"-\" else \">\" line += uea_pad ( fieldsize , details [ field ], direction ) if not columns [ - 1 ] == z : line += \" \" col = col if not song or song != g . model [ n ] else c . p line = col + line + c . w out += line + \" \\n \" return out + \" \\n \" * ( 5 - len ( g . model )) if not song else out","title":"generate_songlist_display()"},{"location":"reference/content/#mps_youtube.content.logo","text":"Return text logo. Source code in mps_youtube/content.py def logo ( col = None , version = \"\" ): \"\"\" Return text logo. \"\"\" col = col if col else random . choice (( c . g , c . r , c . y , c . b , c . p , c . w )) logo_txt = r \"\"\" _ _ | | | | _ _ _____ _| |_ _ _| |__ ___ | | | |/ _ \\ \\ /\\ / / __| | | | '_ \\ / _ \\ | |_| | __/\\ V V /| |_| |_| | |_) | __/ \\__, |\\___| \\_/\\_/ \\__|\\__,_|_.__/ \\___| __/ | |___/ \"\"\" version = \" v\" + version if version else \"\" logo_txt = col + logo_txt + c . w + version lines = logo_txt . split ( \" \\n \" ) length = max ( len ( x ) for x in lines ) x , y , _ = getxy () indent = ( x - length - 1 ) // 2 newlines = ( y - 12 ) // 2 indent , newlines = ( 0 if x < 0 else x for x in ( indent , newlines )) lines = [ \" \" * indent + l for l in lines ] logo_txt = \" \\n \" . join ( lines ) + \" \\n \" * newlines return \"\" if g . debug_mode or g . no_textart else logo_txt","title":"logo()"},{"location":"reference/content/#mps_youtube.content.page_msg","text":"Format information about currently displayed page to a string. Source code in mps_youtube/content.py def page_msg ( page = 0 ): \"\"\" Format information about currently displayed page to a string. \"\"\" if isinstance ( g . content , PaginatedContent ): page_count = g . content . numPages () else : page_count = math . ceil ( g . result_count / getxy () . max_results ) if page_count > 1 : pagemsg = \" {}{} / {}{} \" #start_index = max_results * g.current_page return pagemsg . format ( '<' if page > 0 else '[' , \" %s%s%s \" % ( c . y , page + 1 , c . w ), page_count , '>' if page + 1 < page_count else ']' ) return None","title":"page_msg()"},{"location":"reference/content/#mps_youtube.content.playlists_display","text":"Produce a list of all playlists. Source code in mps_youtube/content.py def playlists_display (): \"\"\" Produce a list of all playlists. \"\"\" if not g . userpl : g . message = F ( \"no playlists\" ) return generate_songlist_display () if g . model else ( logo ( c . y ) + \" \\n\\n \" ) maxname = max ( len ( a ) for a in g . userpl ) out = \" {0} Local Playlists {1} \\n \" . format ( c . ul , c . w ) start = \" \" fmt = \" %s%s%-3s %-\" + str ( maxname + 3 ) + \"s %s %s%-7s%s %-5s%s \" head = ( start , c . b , \"ID\" , \"Name\" , c . b , c . b , \"Count\" , c . b , \"Duration\" , c . w ) out += \" \\n \" + fmt % head + \" \\n\\n \" for v , z in enumerate ( sorted ( g . userpl )): n , p = z , g . userpl [ z ] l = fmt % ( start , c . g , v + 1 , n , c . w , c . y , str ( len ( p )), c . y , p . duration , c . w ) + \" \\n \" out += l return out","title":"playlists_display()"},{"location":"reference/contentquery/","text":"ContentQuery is an abstraction layer between the the pafy.call_gdata and the listViews. It lets you treat A query as a list of all the results, even though data is only queried when requested. ContentQuery \u00b6 A wrapper for pafy.call_gdata. I lets you treat a search as a list, but the results will only be fetched when needed. Source code in mps_youtube/contentquery.py class ContentQuery : \"\"\" A wrapper for pafy.call_gdata. I lets you treat a search as a list, but the results will only be fetched when needed. \"\"\" maxresults = 0 pdata = [] nextpagetoken = None datatype = None query = None api = None def __init__ ( self , datatype , api , query ): # Perform initial API call, setBoundaries # call parseData self . datatype = datatype self . query = query self . api = api self . pdata = [] self . _perform_api_call () def __getitem__ ( self , iid ): # Check if we already got the item or slice needed # Call and parse nextPage as long as you dont have the data # needed. last_id = iid . stop if iid . __class__ == slice else iid last_datapoint = min ( last_id , self . maxresults ) while len ( self . pdata ) < last_datapoint : self . _perform_api_call () return self . pdata [ iid ] def count ( self ): \"\"\" Returns how many items are in the list \"\"\" return self . maxresults def __len__ ( self ): return abs ( self . count ()) def _perform_api_call ( self ): # Include nextPageToken if it is set # qry = dict( # pageToken=self.nextpagetoken, # **(self.query) # ) if self.nextpagetoken else self.query # Run query util . dbg ( \"CQ.query\" , self . query ) data = pafy . channel_search ( self . query ) #pafy.call_gdata(self.api, qry) self . maxresults = len ( data ) #int(data.get(\"pageInfo\").get(\"totalResults\")) self . nextpagetoken = None #data.get(\"nextPageToken\") for obj in data : self . pdata . append ( self . datatype ( obj )) count ( self ) \u00b6 Returns how many items are in the list Source code in mps_youtube/contentquery.py def count ( self ): \"\"\" Returns how many items are in the list \"\"\" return self . maxresults","title":"contentquery.py"},{"location":"reference/contentquery/#mps_youtube.contentquery.ContentQuery","text":"A wrapper for pafy.call_gdata. I lets you treat a search as a list, but the results will only be fetched when needed. Source code in mps_youtube/contentquery.py class ContentQuery : \"\"\" A wrapper for pafy.call_gdata. I lets you treat a search as a list, but the results will only be fetched when needed. \"\"\" maxresults = 0 pdata = [] nextpagetoken = None datatype = None query = None api = None def __init__ ( self , datatype , api , query ): # Perform initial API call, setBoundaries # call parseData self . datatype = datatype self . query = query self . api = api self . pdata = [] self . _perform_api_call () def __getitem__ ( self , iid ): # Check if we already got the item or slice needed # Call and parse nextPage as long as you dont have the data # needed. last_id = iid . stop if iid . __class__ == slice else iid last_datapoint = min ( last_id , self . maxresults ) while len ( self . pdata ) < last_datapoint : self . _perform_api_call () return self . pdata [ iid ] def count ( self ): \"\"\" Returns how many items are in the list \"\"\" return self . maxresults def __len__ ( self ): return abs ( self . count ()) def _perform_api_call ( self ): # Include nextPageToken if it is set # qry = dict( # pageToken=self.nextpagetoken, # **(self.query) # ) if self.nextpagetoken else self.query # Run query util . dbg ( \"CQ.query\" , self . query ) data = pafy . channel_search ( self . query ) #pafy.call_gdata(self.api, qry) self . maxresults = len ( data ) #int(data.get(\"pageInfo\").get(\"totalResults\")) self . nextpagetoken = None #data.get(\"nextPageToken\") for obj in data : self . pdata . append ( self . datatype ( obj ))","title":"ContentQuery"},{"location":"reference/contentquery/#mps_youtube.contentquery.ContentQuery.count","text":"Returns how many items are in the list Source code in mps_youtube/contentquery.py def count ( self ): \"\"\" Returns how many items are in the list \"\"\" return self . maxresults","title":"count()"},{"location":"reference/description_parser/","text":"Module for trying to parse and retrieve song data from descriptions artist_from_title ( title ) \u00b6 Try to determine an artist by doing a search on the video and try to find the most common element by n number of times looking for the most common substring in a subset of the results from youtube Source code in mps_youtube/description_parser.py def artist_from_title ( title ): \"\"\" Try to determine an artist by doing a search on the video and try to find the most common element by n number of times looking for the most common substring in a subset of the results from youtube \"\"\" query = {} query [ 'q' ] = title query [ 'type' ] = 'video' query [ 'fields' ] = \"items(snippet(title))\" query [ 'maxResults' ] = 50 query [ 'part' ] = \"snippet\" results = None #pafy.call_gdata('search', query)['items'] titles = [ x [ 'snippet' ][ 'title' ] . upper () for x in results ] alts = {} for _ in range ( 100 ): random . shuffle ( titles ) subset = titles [: 10 ] string = long_substr ( subset ) . strip () if len ( string ) > 3 : alts [ string ] = alts . get ( string , 0 ) + 1 best_string = None if len ( alts ) == 1 : best_string = list ( alts . keys ())[ 0 ] . capitalize () else : best_guess = 99999 best_string = None for key in list ( alts . keys ()): current_guess = title . upper () . find ( key ) if current_guess < best_guess : best_guess = current_guess best_string = key . capitalize () best_string = re . sub ( r \"([^\\w]+)$\" , \"\" , best_string ) best_string = re . sub ( r \"^([^\\w]+)\" , \"\" , best_string ) return best_string calculate_certainty ( line ) \u00b6 Determine if a line contains a Source code in mps_youtube/description_parser.py def calculate_certainty ( line ): \"\"\" Determine if a line contains a \"\"\" certainty_indexes = [ { 'regex' : r \"(?:\\(?(?:\\d{0,4}:)?\\d{0,2}:\\d{0,2}\\)?(?: - )?){1,2}\" , 'weight' : 1 }, { 'regex' : r \"(([\\w&()\\[\\]'\\.\\/ ]+)([ ]?[-]+[ ]?)([\\w&()\\[\\]'\\.\\/ ]+))+\" , 'weight' : 0.75 }, { 'regex' : r \"^([\\d]+[. ]+)\" , 'weight' : 1 } ] certainty = 0.0 for method in certainty_indexes : if re . match ( method [ 'regex' ], line ): certainty += method [ 'weight' ] return certainty / len ( certainty_indexes ) has_artist ( text ) \u00b6 Determine if the str\u00ecng has artist or not Source code in mps_youtube/description_parser.py def has_artist ( text ): \"\"\" Determine if the str\u00ecng has artist or not \"\"\" regex = r \"(?:([\\w&()\\[\\]'\\.\\/ ]+)(?:[ ]?[-]+[ ]?)([\\w&()\\[\\]'\\.\\/ ]+))+\" return not re . match ( regex , text ) is_substr ( find , data ) \u00b6 Check if is substring Source code in mps_youtube/description_parser.py def is_substr ( find , data ): \"\"\" Check if is substring \"\"\" if len ( data ) < 1 and len ( find ) < 1 : return False for i , _ in enumerate ( data ): if find not in data [ i ]: return False return True long_substr ( data ) \u00b6 https://stackoverflow.com/a/2894073 Source code in mps_youtube/description_parser.py def long_substr ( data ): \"\"\" https://stackoverflow.com/a/2894073 \"\"\" substr = '' if len ( data ) > 1 and len ( data [ 0 ]) > 0 : for i in range ( len ( data [ 0 ])): for j in range ( len ( data [ 0 ]) - i + 1 ): if j > len ( substr ) and is_substr ( data [ 0 ][ i : i + j ], data ): substr = data [ 0 ][ i : i + j ] return substr parse ( text , title = 'Unknown' ) \u00b6 Main function Source code in mps_youtube/description_parser.py def parse ( text , title = \"Unknown\" ): \"\"\" Main function\"\"\" # Determine a certainty index for each line lines = [] for line in text . split ( ' \\n ' ): lines . append (( calculate_certainty ( line ), line )) # Get average from all strings certainty_average = sum ([ x [ 0 ] for x in lines ]) / len ( lines ) # Single out lines with above average certainty index lines = filter ( lambda a : a is not None , [ x if x [ 0 ] > certainty_average else None for x in lines ]) # Determine if they are artist combo strings or only title cmbs = [] for line in lines : is_ac = has_artist ( line [ 1 ]) cmbs . append ( strip_string ( line [ 1 ], is_ac )) # No or very few tracklists will ommit aritsts or add artist information # on only a few select number of tracks, therefore we count entries with # and without artist, and remove the anomalities IF the number of # anomalities are small enough counters = { 'has' : 0 , 'not' : 0 } for combo in cmbs : counters [ 'has' if combo [ 0 ] else 'not' ] += 1 dominant = 'has' if counters [ 'has' ] > counters [ 'not' ] else 'not' diff = abs ( counters [ 'has' ] - counters [ 'not' ]) if diff > sum ([ counters [ 'has' ], counters [ 'not' ]]): print ( \"Too many anomalities detected\" ) return [] if dominant == 'has' : cmbs = filter ( lambda a : a is not None , [ x if x [ 0 ] is not None else None for x in cmbs ]) else : arti = artist_from_title ( title ) cmbs = filter ( lambda a : a is not None , [( arti , x [ 1 ]) if x [ 0 ] is None else None for x in cmbs ]) return list ( cmbs ) strip_string ( text , single = False ) \u00b6 Strip an artist-combo string Source code in mps_youtube/description_parser.py def strip_string ( text , single = False ): \"\"\" Strip an artist-combo string \"\"\" # Removes timestamps ts_reg = r \"(?:\\(?(?:\\d{0,4}:)?\\d{1,2}:\\d{1,2}\\)?(?: - )?){1,2}\" text = re . sub ( ts_reg , \"\" , text ) # Removes Tracknumbers. text = re . sub ( r \"^([\\d]+[. ]+)\" , \"\" , text ) # Removes starting with non words text = re . sub ( r \"^[^\\w&()\\[\\]'\\.\\/]\" , \"\" , text , flags = re . MULTILINE ) artist , track = None , None if not single : rgex = r \"(?:([\\w&()\\[\\]'\\.\\/ ]+)(?:[ ]?[-]+[ ]?)([\\w&()\\[\\]'\\.\\/ ]+))+\" artist , track = ( re . findall ( rgex , text )[ 0 ]) else : track = text return artist , track","title":"description_parser.py"},{"location":"reference/description_parser/#mps_youtube.description_parser.artist_from_title","text":"Try to determine an artist by doing a search on the video and try to find the most common element by n number of times looking for the most common substring in a subset of the results from youtube Source code in mps_youtube/description_parser.py def artist_from_title ( title ): \"\"\" Try to determine an artist by doing a search on the video and try to find the most common element by n number of times looking for the most common substring in a subset of the results from youtube \"\"\" query = {} query [ 'q' ] = title query [ 'type' ] = 'video' query [ 'fields' ] = \"items(snippet(title))\" query [ 'maxResults' ] = 50 query [ 'part' ] = \"snippet\" results = None #pafy.call_gdata('search', query)['items'] titles = [ x [ 'snippet' ][ 'title' ] . upper () for x in results ] alts = {} for _ in range ( 100 ): random . shuffle ( titles ) subset = titles [: 10 ] string = long_substr ( subset ) . strip () if len ( string ) > 3 : alts [ string ] = alts . get ( string , 0 ) + 1 best_string = None if len ( alts ) == 1 : best_string = list ( alts . keys ())[ 0 ] . capitalize () else : best_guess = 99999 best_string = None for key in list ( alts . keys ()): current_guess = title . upper () . find ( key ) if current_guess < best_guess : best_guess = current_guess best_string = key . capitalize () best_string = re . sub ( r \"([^\\w]+)$\" , \"\" , best_string ) best_string = re . sub ( r \"^([^\\w]+)\" , \"\" , best_string ) return best_string","title":"artist_from_title()"},{"location":"reference/description_parser/#mps_youtube.description_parser.calculate_certainty","text":"Determine if a line contains a Source code in mps_youtube/description_parser.py def calculate_certainty ( line ): \"\"\" Determine if a line contains a \"\"\" certainty_indexes = [ { 'regex' : r \"(?:\\(?(?:\\d{0,4}:)?\\d{0,2}:\\d{0,2}\\)?(?: - )?){1,2}\" , 'weight' : 1 }, { 'regex' : r \"(([\\w&()\\[\\]'\\.\\/ ]+)([ ]?[-]+[ ]?)([\\w&()\\[\\]'\\.\\/ ]+))+\" , 'weight' : 0.75 }, { 'regex' : r \"^([\\d]+[. ]+)\" , 'weight' : 1 } ] certainty = 0.0 for method in certainty_indexes : if re . match ( method [ 'regex' ], line ): certainty += method [ 'weight' ] return certainty / len ( certainty_indexes )","title":"calculate_certainty()"},{"location":"reference/description_parser/#mps_youtube.description_parser.has_artist","text":"Determine if the str\u00ecng has artist or not Source code in mps_youtube/description_parser.py def has_artist ( text ): \"\"\" Determine if the str\u00ecng has artist or not \"\"\" regex = r \"(?:([\\w&()\\[\\]'\\.\\/ ]+)(?:[ ]?[-]+[ ]?)([\\w&()\\[\\]'\\.\\/ ]+))+\" return not re . match ( regex , text )","title":"has_artist()"},{"location":"reference/description_parser/#mps_youtube.description_parser.is_substr","text":"Check if is substring Source code in mps_youtube/description_parser.py def is_substr ( find , data ): \"\"\" Check if is substring \"\"\" if len ( data ) < 1 and len ( find ) < 1 : return False for i , _ in enumerate ( data ): if find not in data [ i ]: return False return True","title":"is_substr()"},{"location":"reference/description_parser/#mps_youtube.description_parser.long_substr","text":"https://stackoverflow.com/a/2894073 Source code in mps_youtube/description_parser.py def long_substr ( data ): \"\"\" https://stackoverflow.com/a/2894073 \"\"\" substr = '' if len ( data ) > 1 and len ( data [ 0 ]) > 0 : for i in range ( len ( data [ 0 ])): for j in range ( len ( data [ 0 ]) - i + 1 ): if j > len ( substr ) and is_substr ( data [ 0 ][ i : i + j ], data ): substr = data [ 0 ][ i : i + j ] return substr","title":"long_substr()"},{"location":"reference/description_parser/#mps_youtube.description_parser.parse","text":"Main function Source code in mps_youtube/description_parser.py def parse ( text , title = \"Unknown\" ): \"\"\" Main function\"\"\" # Determine a certainty index for each line lines = [] for line in text . split ( ' \\n ' ): lines . append (( calculate_certainty ( line ), line )) # Get average from all strings certainty_average = sum ([ x [ 0 ] for x in lines ]) / len ( lines ) # Single out lines with above average certainty index lines = filter ( lambda a : a is not None , [ x if x [ 0 ] > certainty_average else None for x in lines ]) # Determine if they are artist combo strings or only title cmbs = [] for line in lines : is_ac = has_artist ( line [ 1 ]) cmbs . append ( strip_string ( line [ 1 ], is_ac )) # No or very few tracklists will ommit aritsts or add artist information # on only a few select number of tracks, therefore we count entries with # and without artist, and remove the anomalities IF the number of # anomalities are small enough counters = { 'has' : 0 , 'not' : 0 } for combo in cmbs : counters [ 'has' if combo [ 0 ] else 'not' ] += 1 dominant = 'has' if counters [ 'has' ] > counters [ 'not' ] else 'not' diff = abs ( counters [ 'has' ] - counters [ 'not' ]) if diff > sum ([ counters [ 'has' ], counters [ 'not' ]]): print ( \"Too many anomalities detected\" ) return [] if dominant == 'has' : cmbs = filter ( lambda a : a is not None , [ x if x [ 0 ] is not None else None for x in cmbs ]) else : arti = artist_from_title ( title ) cmbs = filter ( lambda a : a is not None , [( arti , x [ 1 ]) if x [ 0 ] is None else None for x in cmbs ]) return list ( cmbs )","title":"parse()"},{"location":"reference/description_parser/#mps_youtube.description_parser.strip_string","text":"Strip an artist-combo string Source code in mps_youtube/description_parser.py def strip_string ( text , single = False ): \"\"\" Strip an artist-combo string \"\"\" # Removes timestamps ts_reg = r \"(?:\\(?(?:\\d{0,4}:)?\\d{1,2}:\\d{1,2}\\)?(?: - )?){1,2}\" text = re . sub ( ts_reg , \"\" , text ) # Removes Tracknumbers. text = re . sub ( r \"^([\\d]+[. ]+)\" , \"\" , text ) # Removes starting with non words text = re . sub ( r \"^[^\\w&()\\[\\]'\\.\\/]\" , \"\" , text , flags = re . MULTILINE ) artist , track = None , None if not single : rgex = r \"(?:([\\w&()\\[\\]'\\.\\/ ]+)(?:[ ]?[-]+[ ]?)([\\w&()\\[\\]'\\.\\/ ]+))+\" artist , track = ( re . findall ( rgex , text )[ 0 ]) else : track = text return artist , track","title":"strip_string()"},{"location":"reference/g/","text":"Module for holding globals that are needed throught mps-youtube.","title":"g.py"},{"location":"reference/helptext/","text":"Holds all help text get_help ( choice ) \u00b6 Return help message. Source code in mps_youtube/helptext.py def get_help ( choice ): \"\"\" Return help message. \"\"\" helps = { \"download\" : ( \"playback dl listen watch show repeat playing\" \"show_video playurl browserplay dlurl d da dv all *\" \" play browsersearch\" . split ()), \"dl-command\" : ( \"dlcmd dl-cmd download-cmd dl_cmd download_cmd \" \"download-command download_command\" . split ()), \"encode\" : ( \"encoding transcoding transcode wma mp3 format \" \"encode encoder\" . split ()), \"invoke\" : \"command commands yt invocation\" . split (), \"search\" : ( \"user userpl pl pls r n p url album \" \"editing result results related remove swop mkp --description\" . split ()), \"edit\" : ( \"editing manupulate manipulating rm mv sw edit move \" \"swap shuffle\" . split ()), \"tips\" : ( \"undump dump -f -w -a adv advanced\" . split ( \" \" )), \"basic\" : ( \"basic comment basics c copy clipboard comments u \" \"i\" . split ()), \"config\" : ( \"set checkupdate colours colors ddir directory player \" \"arguments args playerargs music search_music keys \" \"status show_status show_video video configuration \" \"fullscreen full screen folder player mpv mplayer\" \" settings default reset configure audio results \" \"max_results size lines rows height window \" \"position window_pos quality resolution max_res \" \"columns width console overwrite\" . split ()), \"playlists\" : ( \"save rename delete move rm ls mv sw add vp open\" \" view\" . split ())} for topic , aliases in helps . items (): if choice in aliases : choice = topic break choice = \"menu\" if not choice else choice out , all_help = \"\" , helptext () help_names = [ x [ 0 ] for x in all_help ] choice = get_near_name ( choice , help_names ) def indent ( x ): \"\"\" Indent. \"\"\" return \" \\n \" . join ( x . split ( \" \\n \" )) if choice == \"menu\" or choice not in help_names : out += \" %s Help Topics %s \" % ( c . ul , c . w ) out += F ( 'help topic' , 2 , 1 ) for x in all_help : out += ( \" \\n %s %-10s%s : %s \" % ( c . y , x [ 0 ], c . w , x [ 1 ])) out += \" \\n \" return out else : if choice == 'tor' : output_text = check_tor () elif choice == 'new' : output_text = get_changelog () elif choice == \"changelog\" : output_text = get_changelog_local () else : choice = help_names . index ( choice ) output_text = all_help [ choice ][ 2 ] return indent ( output_text ) helptext () \u00b6 Return a list of help categories, with their contents. Source code in mps_youtube/helptext.py def helptext (): \"\"\" Return a list of help categories, with their contents. \"\"\" return [ ( \"basic\" , \"Basics\" , \"\"\" {0} Basic Usage {1} Use {2} / {1} or {2} . {1} to prefix your search query. e.g., {2} /pink floyd {1} Then, when results are shown: {2} <number(s)> {1} - play specified items, separated by commas. e.g., {2} 1-3,5 {1} plays items 1, 2, 3 and 5. {2} i <number> {1} - view information on video <number> {2} c <number> {1} - view comments for video <number> {2} d <number> {1} - download video <number> {2} r <number> {1} - show videos related to video <number> {2} u <number> {1} - show videos uploaded by uploader of video <number> {2} x <number> {1} - copy item <number> url to clipboard. (See the note below) Note: This feature requires `pyperclip` which is installed automatically when you install yewtube but Linux users further need to install `xsel` or `xclip` manually using apt, dnf, pacman, zypper or whatever package manager you use. Visit https://pyperclip.readthedocs.io/en/latest/index.html#not-implemented-error for more info. {2} q {1} , {2} quit {1} - exit yewtube \"\"\" . format ( c . ul , c . w , c . y )), ( \"search\" , \"Searching and Retrieving\" , \"\"\" {0} Searching and Retrieving {1} {2} set search_music false {1} - search all YouTube categories. {2} set search_music true {1} - search only YouTube music category. {2} /<query> {1} or {2} .<query> {1} to search for videos. e.g., {2} /daft punk {1} Search Arguments: {2} -d, --duration {1} Can be any/short/medium/long {2} -a, --after {1} Date in {2} YYYY-MM-DD {1} or {2} YYYY-MM-DD {1} T {2} HH:MM {1} format {2} -l, --live {1} Limit search to livestreams {2} -c, --category {1} Search within a category, (number or string) Available categories: {2}{3}{1} {2} //<query> {1} or {2} ..<query> {1} - search for YouTube playlists. e.g., \\ {2} //80's music {1} {2} n {1} and {2} p {1} - continue search to next/previous pages. {2} p <number> {1} - switch to page <number>. {2} album <album title> {1} - Search for matching tracks using album title {2} channels <Channel name> {1} - Search for channels by channelname {2} live <category> {1} - Search for livestreams from a range of categories. Categories: {2}{3}{1} {2} mkp <fullfilepath> {1} - Creates a playlist automatically with video titles from fullfilepath <fullfilepath>: Full path of text file with one title per line {2} mkp -d <search result number> {1} - Create a playlist based on tracks listed in that videos description. (Alternatively one can use {2} --description {1} ) {2} user <username> {1} - list YouTube uploads by <username>. {2} user <username>/<query> {1} - as above, but matches <query>. {2} userpl <username> {1} - list YouTube playlists created by <username>. {2} pl <url or id> {1} - Open YouTube playlist by url or id. {2} url <url or id> {1} - Retrieve specific YouTube video by url or id. {2} url <url> <url> ... <url> {1} - Retrieve specific YouTube videos by url or id. {2} url_file <file_absolute_path> {1} - Retrieve YouTube videos by url or id from a .txt file. File format : .txt, with one url or id by line. {2} r <number> {1} - show videos related to video <number>. {2} u <number> {1} - show videos uploaded by uploader of video <number>. {2} c <number> {1} - view comments for video <number> \"\"\" . format ( c . ul , c . w , c . y , \", \" . join ( g . categories . keys ()))), ( \"edit\" , \"Editing / Manipulating Results\" , \"\"\" {0} Editing and Manipulating Results {1} {2} rm <number(s)> {1} - remove items from displayed results. {2} sw <number>,<number> {1} - swap two items. {2} mv <number>,<number> {1} - move item <number> to position <number>. {2} save <name> {1} - save displayed items as a local playlist. {2} mix <number> {1} - show YouTube mix playlist from item in results. {2} shuffle {1} - Shuffle the displayed results. {2} reverse {1} or {2} reverse <number>-<number> {1} - Reverse the displayed items or item range. {2} reverse all {1} - Reverse order of entire loaded playlist \"\"\" . format ( c . ul , c . w , c . y )), ( \"download\" , \"Downloading and Playback\" , \"\"\" {0} Downloading and Playback {1} {2} set show_video true {1} - play video instead of audio. {2} <number(s)> {1} - play specified items, separated by commas. e.g., {2} 1-3,5 {1} plays items 1, 2, 3 and 5 {2} d <number> {1} - view downloads available for an item. {2} da <number(s)> {1} - download best available audio file(s). {2} dv <number(s)> {1} - download best available video file(s). {2} dapl <url or id> {1} - download YouTube playlist (audio) by url or id. {2} dvpl <url or id> {1} - download YouTube playlist (video) by url or id. {2} daupl <username> {1} - download user's YouTube playlists (audio). {2} dvupl <username> {1} - download user's YouTube playlists (video). {2} dlurl <url or id> {1} - download a YouTube video by url or video id. {2} daurl <url or id> {1} - download best available audio of YouTube video by url or video id. {2} playurl <url or id> {1} - play a YouTube video by url or id. {2} browserplay <number> {1} - open a specified previous search in browser. {2} all {1} or {2} * {1} - play all displayed items. {2} repeat <number(s)> {1} - play and repeat the specified items. {2} shuffle <number(s)> {1} - play specified items in random order. \"\"\" . format ( c . ul , c . w , c . y )), ( \"dl-command\" , \"Downloading Using External Application\" , \"\"\" {0} Download Using A Custom Application {1} Use {2} set download_command <command> {1} to specify a custom command to use for downloading. mps-youtube will make the following substitutions: %u - url of the remote file to download %d - download directory as set in DDIR in mps-youtube config %f - filename (determined by title and filetype) %F - full file path ( %d / %f ) %i - youtube video id for example, to download using aria2c (http://aria2.sourceforge.net), enter: {2} set download_command aria2c --dir= %d --out= %f %u{1} Note that using a custom download command does not support transcoding the downloaded file to another format using mps-youtube. \"\"\" . format ( c . ul , c . w , c . y )), ( \"encode\" , \"Encoding to MP3 and other formats\" , \"\"\" {0} Encoding to MP3 and other formats {1} Enter {2} encoders {1} to view available encoding presets Enter {2} set encoder <number> {1} to apply an encoding preset for downloads This feature requires that ffmpeg or avconv is installed on your system and is available in the system path. The encoding presets can be modified by editing the text config file which resides at: {3} \"\"\" . format ( c . ul , c . w , c . y , g . TCFILE )), ( \"playlists\" , \"Using Local Playlists\" , \"\"\" {0} Using Local Playlists {1} {2} add <number(s)> {1} - add items to the current playlist. {2} add <number(s)> <playlist> {1} - add items to the specified playlist. (<playlist> will be created if it doesn't already exist) {2} vp {1} - view current playlist. {2} ls {1} - list saved playlists. {2} mv <old name or ID> <new name> {1} - rename a playlist. {2} rmp <playlist_name or ID> {1} - delete a playlist from disk. {2} open <name or ID> {1} - open a saved playlist as the current playlist. {2} play <name or ID> {1} - play a saved playlist directly. {2} view <name or ID> {1} - view a playlist (current playlist left intact). {2} save {1} or {2} save <name> {1} - save the displayed items as a playlist. {2} rm <number(s)> {1} - remove items from displayed results. {2} sw <number>,<number> {1} - swap two items. {2} mv <number>,<number> {1} - move item <number> to position <number>. \"\"\" . format ( c . ul , c . w , c . y )), ( \"history\" , \"Accessing Local History\" , \"\"\" {0} Accessing Local History {1} Access songs that have been played within yewtube {2} history {1} - displays a list of songs contained in history {2} history clear {1} - clears the song history {2} history recent {1} - displays a list of recent played songs {2} set history on|off {1} - toggles history recording \"\"\" . format ( c . ul , c . w , c . y )), ( \"invoke\" , \"Invocation Parameters\" , \"\"\" {0} Invocation {1} All yewtube commands can be entered from the command line. For example; {2} yt dlurl <url or id> {1} to download a YouTube video by url or id {2} yt playurl <url or id> {1} to play a YouTube video by url or id {2} yt /mozart {1} to search {2} yt //best songs of 2010 {1} for a playlist search {2} yt play <playlist name or ID> {1} to play a saved playlist {2} yt ls {1} to list saved playlists For further automation, a series of commands can be entered separated by commas (,). E.g., {2} yt open 1, 2-4 {1} - play items 2-4 of first saved playlist {2} yt //the doors, 1, all -a {1} - open YouTube playlist and play audio If you need to enter an actual comma on the command line, use {2} ,, {1} instead. \"\"\" . format ( c . ul , c . w , c . y )), ( \"config\" , \"Configuration Options\" , \"\"\" {0} Configuration {1} {2} set {1} - view current configuration {2} set <item> default {1} - set an item to its default value {2} set all default {1} - restore default settings {2} set checkupdate true|false {1} - check for updates on exit {2} set columns <columns> {1} - select extra displayed fields in search results: (valid: views comments rating date time user likes dislikes category ytid) {2} set ddir <download direcory> {1} - set where downloads are saved {2} set download_command <command> {1} - type {2} help dl-command {1} for info {2} set encoder <number> {1} - set encoding preset for downloaded files {2} set fullscreen true|false {1} - output video content in full-screen mode {2} set always_repeat true|false {1} - always in repeat mode without repeat <number> {2} set max_res <number> {1} - play / download maximum video resolution height {3} {2} set notifier <notifier app> {1} - call <notifier app> with each new song title {2} set order <relevance|date|views|rating> {1} search result ordering {2} set user_order <<nothing>|relevance|date|views|rating> {1} user upload list result ordering, leave blank for the same as order setting {2} set overwrite true|false {1} - overwrite existing files (skip if false) {2} set player <player app> {1} - use <player app> for playback {2} set playerargs <args> {1} - use specified arguments with player {2} set lookup_metadata true|false {1} - lookup metadata using Last.fm {2} set lastfm_username <username> {1} - scrobble to this Last.fm userprofile {2} set lastfm_password <password> {1} - Last.fm password (saved in hash form) {2} set lastfm_api <key> {1} - API key needed for Last.fm mps-yt authorization {2} set lastfm_secret <key> {1} - secret for the Last.fm API key {2} set search_music true|false {1} - search only music (all categories if false) {2} set show_mplayer_keys true|false {1} - show keyboard help for mplayer and mpv {2} set show_status true|false {1} - show status messages and progress {2} set show_video true|false {1} - show video output (audio only if false) {2} set window_pos <top|bottom>-<left|right> {1} - set player window position {2} set window_size <number>x<number> {1} - set player window width & height {2} set audio_format <auto|m4a|webm> {1} - set default music audio format {2} set video_format <auto|mp4|webm|3gp> {1} - set default music video format {2} set set_title true|false {1} - change window title {2} set show_qrcode true|false {1} - show qrcode of the URL in the video information panel {2} set history true|false {1} - record play history {2} set input_history true|false {1} - record command input history {2} set vlc_dummy_interface true|false {1} - whether to hide VLC GUI or not (hides when true) Additionally, {2} set -t {1} may be used to temporarily change a setting without saving it to disk \"\"\" . format ( c . ul , c . w , c . y , ' \\n {0} set max_results <number> {1} - show <number> re' 'sults when searching (max 50)' . format ( c . y , c . w ) if not g . detectable_size else '' )), ( \"lastfm\" , \"Last.fm configuration\" , \"\"\" {0} Configure Last.fm {1} pylast needs to be installed for Last.fm support. See https://github.com/pylast/pylast. Use {2} set {1} to set your Last.fm login credenditals, e.g. {2} set lastfm_username jane_doe {1} . Similarly, you also have to provide an API key and it's corresponding secret. An API key can be retrieved from https://www.last.fm/api/account/create. Your Last.fm configuration is saved and automatically reloaded when mps-youtube starts. After having set the required information, a connection can also be established with {2} lastfm_connect {1} . Additionally, {2} lastfm_connect {1} provides verbose error messages. For now, Last.fm support only works with the {2} album {1} command. \"\"\" . format ( c . ul , c . w , c . y )), ( \"tips\" , \"Advanced Tips\" , \"\"\" {0} Advanced Tips {1} Use {2} -w {1} , {2} -f {1} or {2} -a {1} with your choice to override the configured \\ setting and play items in windowed, fullscreen or audio modes. E.g., 1-4 -a When specifying columns with {2} set columns {1} command, append :N to set \\ width. E.g.: {2} set columns date views user:17 likes {1} When using {2} open {1} , {2} view {1} or {2} play {1} to access a local playlist, \\ you can enter the first few characters instead of the whole name. Use {2} 5- {1} to select items 5 upward and {2} -5 {1} to select up to item 5. \\ This can be included with other choices. e.g., 5,3,7-,-2 You can use spaces instead of commas: 5 3 7- -2 Reversed ranges also work. eg., 5-2 {2} dump {1} - to show entire contents of an opened YouTube playlist. (useful for playing or saving entire playlists, use {2} undump {1} to \\ undo) {2} set player mpv {1} or {2} set player mplayer {1} - change player application Use {2} 1 {1} and {2} 0 {1} in place of true and false when using the {2} set {1} \\ command Use {2} clearcache {1} command to clear the cache. \"\"\" . format ( c . ul , c . w , c . y ), ), ( \"new\" , \"Check if new version is available\" , \"\"\"{0}What's New{1}\\n{3}\"\"\" . format ( c . ul , c . w , c . y , \"get_changelog()\" ), ), ( \"changelog\" , \"Check program changelog\" , \"\"\"{0}Changelog{1}\\n{3}\"\"\" . format ( c . ul , c . w , c . y , \"get_changelog_local()\" ), ), ( \"tor\" , \"Check Tor Status. NOTE: Use this feature at your own risk. In case of any kind of damage we will not be responsible.\" , \"\"\"{0}Tor Status{1}\\n{3}\"\"\" . format ( c . ul , c . w , c . y , \"check_tor()\" ), ), ]","title":"helptext.py"},{"location":"reference/helptext/#mps_youtube.helptext.get_help","text":"Return help message. Source code in mps_youtube/helptext.py def get_help ( choice ): \"\"\" Return help message. \"\"\" helps = { \"download\" : ( \"playback dl listen watch show repeat playing\" \"show_video playurl browserplay dlurl d da dv all *\" \" play browsersearch\" . split ()), \"dl-command\" : ( \"dlcmd dl-cmd download-cmd dl_cmd download_cmd \" \"download-command download_command\" . split ()), \"encode\" : ( \"encoding transcoding transcode wma mp3 format \" \"encode encoder\" . split ()), \"invoke\" : \"command commands yt invocation\" . split (), \"search\" : ( \"user userpl pl pls r n p url album \" \"editing result results related remove swop mkp --description\" . split ()), \"edit\" : ( \"editing manupulate manipulating rm mv sw edit move \" \"swap shuffle\" . split ()), \"tips\" : ( \"undump dump -f -w -a adv advanced\" . split ( \" \" )), \"basic\" : ( \"basic comment basics c copy clipboard comments u \" \"i\" . split ()), \"config\" : ( \"set checkupdate colours colors ddir directory player \" \"arguments args playerargs music search_music keys \" \"status show_status show_video video configuration \" \"fullscreen full screen folder player mpv mplayer\" \" settings default reset configure audio results \" \"max_results size lines rows height window \" \"position window_pos quality resolution max_res \" \"columns width console overwrite\" . split ()), \"playlists\" : ( \"save rename delete move rm ls mv sw add vp open\" \" view\" . split ())} for topic , aliases in helps . items (): if choice in aliases : choice = topic break choice = \"menu\" if not choice else choice out , all_help = \"\" , helptext () help_names = [ x [ 0 ] for x in all_help ] choice = get_near_name ( choice , help_names ) def indent ( x ): \"\"\" Indent. \"\"\" return \" \\n \" . join ( x . split ( \" \\n \" )) if choice == \"menu\" or choice not in help_names : out += \" %s Help Topics %s \" % ( c . ul , c . w ) out += F ( 'help topic' , 2 , 1 ) for x in all_help : out += ( \" \\n %s %-10s%s : %s \" % ( c . y , x [ 0 ], c . w , x [ 1 ])) out += \" \\n \" return out else : if choice == 'tor' : output_text = check_tor () elif choice == 'new' : output_text = get_changelog () elif choice == \"changelog\" : output_text = get_changelog_local () else : choice = help_names . index ( choice ) output_text = all_help [ choice ][ 2 ] return indent ( output_text )","title":"get_help()"},{"location":"reference/helptext/#mps_youtube.helptext.helptext","text":"Return a list of help categories, with their contents. Source code in mps_youtube/helptext.py def helptext (): \"\"\" Return a list of help categories, with their contents. \"\"\" return [ ( \"basic\" , \"Basics\" , \"\"\" {0} Basic Usage {1} Use {2} / {1} or {2} . {1} to prefix your search query. e.g., {2} /pink floyd {1} Then, when results are shown: {2} <number(s)> {1} - play specified items, separated by commas. e.g., {2} 1-3,5 {1} plays items 1, 2, 3 and 5. {2} i <number> {1} - view information on video <number> {2} c <number> {1} - view comments for video <number> {2} d <number> {1} - download video <number> {2} r <number> {1} - show videos related to video <number> {2} u <number> {1} - show videos uploaded by uploader of video <number> {2} x <number> {1} - copy item <number> url to clipboard. (See the note below) Note: This feature requires `pyperclip` which is installed automatically when you install yewtube but Linux users further need to install `xsel` or `xclip` manually using apt, dnf, pacman, zypper or whatever package manager you use. Visit https://pyperclip.readthedocs.io/en/latest/index.html#not-implemented-error for more info. {2} q {1} , {2} quit {1} - exit yewtube \"\"\" . format ( c . ul , c . w , c . y )), ( \"search\" , \"Searching and Retrieving\" , \"\"\" {0} Searching and Retrieving {1} {2} set search_music false {1} - search all YouTube categories. {2} set search_music true {1} - search only YouTube music category. {2} /<query> {1} or {2} .<query> {1} to search for videos. e.g., {2} /daft punk {1} Search Arguments: {2} -d, --duration {1} Can be any/short/medium/long {2} -a, --after {1} Date in {2} YYYY-MM-DD {1} or {2} YYYY-MM-DD {1} T {2} HH:MM {1} format {2} -l, --live {1} Limit search to livestreams {2} -c, --category {1} Search within a category, (number or string) Available categories: {2}{3}{1} {2} //<query> {1} or {2} ..<query> {1} - search for YouTube playlists. e.g., \\ {2} //80's music {1} {2} n {1} and {2} p {1} - continue search to next/previous pages. {2} p <number> {1} - switch to page <number>. {2} album <album title> {1} - Search for matching tracks using album title {2} channels <Channel name> {1} - Search for channels by channelname {2} live <category> {1} - Search for livestreams from a range of categories. Categories: {2}{3}{1} {2} mkp <fullfilepath> {1} - Creates a playlist automatically with video titles from fullfilepath <fullfilepath>: Full path of text file with one title per line {2} mkp -d <search result number> {1} - Create a playlist based on tracks listed in that videos description. (Alternatively one can use {2} --description {1} ) {2} user <username> {1} - list YouTube uploads by <username>. {2} user <username>/<query> {1} - as above, but matches <query>. {2} userpl <username> {1} - list YouTube playlists created by <username>. {2} pl <url or id> {1} - Open YouTube playlist by url or id. {2} url <url or id> {1} - Retrieve specific YouTube video by url or id. {2} url <url> <url> ... <url> {1} - Retrieve specific YouTube videos by url or id. {2} url_file <file_absolute_path> {1} - Retrieve YouTube videos by url or id from a .txt file. File format : .txt, with one url or id by line. {2} r <number> {1} - show videos related to video <number>. {2} u <number> {1} - show videos uploaded by uploader of video <number>. {2} c <number> {1} - view comments for video <number> \"\"\" . format ( c . ul , c . w , c . y , \", \" . join ( g . categories . keys ()))), ( \"edit\" , \"Editing / Manipulating Results\" , \"\"\" {0} Editing and Manipulating Results {1} {2} rm <number(s)> {1} - remove items from displayed results. {2} sw <number>,<number> {1} - swap two items. {2} mv <number>,<number> {1} - move item <number> to position <number>. {2} save <name> {1} - save displayed items as a local playlist. {2} mix <number> {1} - show YouTube mix playlist from item in results. {2} shuffle {1} - Shuffle the displayed results. {2} reverse {1} or {2} reverse <number>-<number> {1} - Reverse the displayed items or item range. {2} reverse all {1} - Reverse order of entire loaded playlist \"\"\" . format ( c . ul , c . w , c . y )), ( \"download\" , \"Downloading and Playback\" , \"\"\" {0} Downloading and Playback {1} {2} set show_video true {1} - play video instead of audio. {2} <number(s)> {1} - play specified items, separated by commas. e.g., {2} 1-3,5 {1} plays items 1, 2, 3 and 5 {2} d <number> {1} - view downloads available for an item. {2} da <number(s)> {1} - download best available audio file(s). {2} dv <number(s)> {1} - download best available video file(s). {2} dapl <url or id> {1} - download YouTube playlist (audio) by url or id. {2} dvpl <url or id> {1} - download YouTube playlist (video) by url or id. {2} daupl <username> {1} - download user's YouTube playlists (audio). {2} dvupl <username> {1} - download user's YouTube playlists (video). {2} dlurl <url or id> {1} - download a YouTube video by url or video id. {2} daurl <url or id> {1} - download best available audio of YouTube video by url or video id. {2} playurl <url or id> {1} - play a YouTube video by url or id. {2} browserplay <number> {1} - open a specified previous search in browser. {2} all {1} or {2} * {1} - play all displayed items. {2} repeat <number(s)> {1} - play and repeat the specified items. {2} shuffle <number(s)> {1} - play specified items in random order. \"\"\" . format ( c . ul , c . w , c . y )), ( \"dl-command\" , \"Downloading Using External Application\" , \"\"\" {0} Download Using A Custom Application {1} Use {2} set download_command <command> {1} to specify a custom command to use for downloading. mps-youtube will make the following substitutions: %u - url of the remote file to download %d - download directory as set in DDIR in mps-youtube config %f - filename (determined by title and filetype) %F - full file path ( %d / %f ) %i - youtube video id for example, to download using aria2c (http://aria2.sourceforge.net), enter: {2} set download_command aria2c --dir= %d --out= %f %u{1} Note that using a custom download command does not support transcoding the downloaded file to another format using mps-youtube. \"\"\" . format ( c . ul , c . w , c . y )), ( \"encode\" , \"Encoding to MP3 and other formats\" , \"\"\" {0} Encoding to MP3 and other formats {1} Enter {2} encoders {1} to view available encoding presets Enter {2} set encoder <number> {1} to apply an encoding preset for downloads This feature requires that ffmpeg or avconv is installed on your system and is available in the system path. The encoding presets can be modified by editing the text config file which resides at: {3} \"\"\" . format ( c . ul , c . w , c . y , g . TCFILE )), ( \"playlists\" , \"Using Local Playlists\" , \"\"\" {0} Using Local Playlists {1} {2} add <number(s)> {1} - add items to the current playlist. {2} add <number(s)> <playlist> {1} - add items to the specified playlist. (<playlist> will be created if it doesn't already exist) {2} vp {1} - view current playlist. {2} ls {1} - list saved playlists. {2} mv <old name or ID> <new name> {1} - rename a playlist. {2} rmp <playlist_name or ID> {1} - delete a playlist from disk. {2} open <name or ID> {1} - open a saved playlist as the current playlist. {2} play <name or ID> {1} - play a saved playlist directly. {2} view <name or ID> {1} - view a playlist (current playlist left intact). {2} save {1} or {2} save <name> {1} - save the displayed items as a playlist. {2} rm <number(s)> {1} - remove items from displayed results. {2} sw <number>,<number> {1} - swap two items. {2} mv <number>,<number> {1} - move item <number> to position <number>. \"\"\" . format ( c . ul , c . w , c . y )), ( \"history\" , \"Accessing Local History\" , \"\"\" {0} Accessing Local History {1} Access songs that have been played within yewtube {2} history {1} - displays a list of songs contained in history {2} history clear {1} - clears the song history {2} history recent {1} - displays a list of recent played songs {2} set history on|off {1} - toggles history recording \"\"\" . format ( c . ul , c . w , c . y )), ( \"invoke\" , \"Invocation Parameters\" , \"\"\" {0} Invocation {1} All yewtube commands can be entered from the command line. For example; {2} yt dlurl <url or id> {1} to download a YouTube video by url or id {2} yt playurl <url or id> {1} to play a YouTube video by url or id {2} yt /mozart {1} to search {2} yt //best songs of 2010 {1} for a playlist search {2} yt play <playlist name or ID> {1} to play a saved playlist {2} yt ls {1} to list saved playlists For further automation, a series of commands can be entered separated by commas (,). E.g., {2} yt open 1, 2-4 {1} - play items 2-4 of first saved playlist {2} yt //the doors, 1, all -a {1} - open YouTube playlist and play audio If you need to enter an actual comma on the command line, use {2} ,, {1} instead. \"\"\" . format ( c . ul , c . w , c . y )), ( \"config\" , \"Configuration Options\" , \"\"\" {0} Configuration {1} {2} set {1} - view current configuration {2} set <item> default {1} - set an item to its default value {2} set all default {1} - restore default settings {2} set checkupdate true|false {1} - check for updates on exit {2} set columns <columns> {1} - select extra displayed fields in search results: (valid: views comments rating date time user likes dislikes category ytid) {2} set ddir <download direcory> {1} - set where downloads are saved {2} set download_command <command> {1} - type {2} help dl-command {1} for info {2} set encoder <number> {1} - set encoding preset for downloaded files {2} set fullscreen true|false {1} - output video content in full-screen mode {2} set always_repeat true|false {1} - always in repeat mode without repeat <number> {2} set max_res <number> {1} - play / download maximum video resolution height {3} {2} set notifier <notifier app> {1} - call <notifier app> with each new song title {2} set order <relevance|date|views|rating> {1} search result ordering {2} set user_order <<nothing>|relevance|date|views|rating> {1} user upload list result ordering, leave blank for the same as order setting {2} set overwrite true|false {1} - overwrite existing files (skip if false) {2} set player <player app> {1} - use <player app> for playback {2} set playerargs <args> {1} - use specified arguments with player {2} set lookup_metadata true|false {1} - lookup metadata using Last.fm {2} set lastfm_username <username> {1} - scrobble to this Last.fm userprofile {2} set lastfm_password <password> {1} - Last.fm password (saved in hash form) {2} set lastfm_api <key> {1} - API key needed for Last.fm mps-yt authorization {2} set lastfm_secret <key> {1} - secret for the Last.fm API key {2} set search_music true|false {1} - search only music (all categories if false) {2} set show_mplayer_keys true|false {1} - show keyboard help for mplayer and mpv {2} set show_status true|false {1} - show status messages and progress {2} set show_video true|false {1} - show video output (audio only if false) {2} set window_pos <top|bottom>-<left|right> {1} - set player window position {2} set window_size <number>x<number> {1} - set player window width & height {2} set audio_format <auto|m4a|webm> {1} - set default music audio format {2} set video_format <auto|mp4|webm|3gp> {1} - set default music video format {2} set set_title true|false {1} - change window title {2} set show_qrcode true|false {1} - show qrcode of the URL in the video information panel {2} set history true|false {1} - record play history {2} set input_history true|false {1} - record command input history {2} set vlc_dummy_interface true|false {1} - whether to hide VLC GUI or not (hides when true) Additionally, {2} set -t {1} may be used to temporarily change a setting without saving it to disk \"\"\" . format ( c . ul , c . w , c . y , ' \\n {0} set max_results <number> {1} - show <number> re' 'sults when searching (max 50)' . format ( c . y , c . w ) if not g . detectable_size else '' )), ( \"lastfm\" , \"Last.fm configuration\" , \"\"\" {0} Configure Last.fm {1} pylast needs to be installed for Last.fm support. See https://github.com/pylast/pylast. Use {2} set {1} to set your Last.fm login credenditals, e.g. {2} set lastfm_username jane_doe {1} . Similarly, you also have to provide an API key and it's corresponding secret. An API key can be retrieved from https://www.last.fm/api/account/create. Your Last.fm configuration is saved and automatically reloaded when mps-youtube starts. After having set the required information, a connection can also be established with {2} lastfm_connect {1} . Additionally, {2} lastfm_connect {1} provides verbose error messages. For now, Last.fm support only works with the {2} album {1} command. \"\"\" . format ( c . ul , c . w , c . y )), ( \"tips\" , \"Advanced Tips\" , \"\"\" {0} Advanced Tips {1} Use {2} -w {1} , {2} -f {1} or {2} -a {1} with your choice to override the configured \\ setting and play items in windowed, fullscreen or audio modes. E.g., 1-4 -a When specifying columns with {2} set columns {1} command, append :N to set \\ width. E.g.: {2} set columns date views user:17 likes {1} When using {2} open {1} , {2} view {1} or {2} play {1} to access a local playlist, \\ you can enter the first few characters instead of the whole name. Use {2} 5- {1} to select items 5 upward and {2} -5 {1} to select up to item 5. \\ This can be included with other choices. e.g., 5,3,7-,-2 You can use spaces instead of commas: 5 3 7- -2 Reversed ranges also work. eg., 5-2 {2} dump {1} - to show entire contents of an opened YouTube playlist. (useful for playing or saving entire playlists, use {2} undump {1} to \\ undo) {2} set player mpv {1} or {2} set player mplayer {1} - change player application Use {2} 1 {1} and {2} 0 {1} in place of true and false when using the {2} set {1} \\ command Use {2} clearcache {1} command to clear the cache. \"\"\" . format ( c . ul , c . w , c . y ), ), ( \"new\" , \"Check if new version is available\" , \"\"\"{0}What's New{1}\\n{3}\"\"\" . format ( c . ul , c . w , c . y , \"get_changelog()\" ), ), ( \"changelog\" , \"Check program changelog\" , \"\"\"{0}Changelog{1}\\n{3}\"\"\" . format ( c . ul , c . w , c . y , \"get_changelog_local()\" ), ), ( \"tor\" , \"Check Tor Status. NOTE: Use this feature at your own risk. In case of any kind of damage we will not be responsible.\" , \"\"\"{0}Tor Status{1}\\n{3}\"\"\" . format ( c . ul , c . w , c . y , \"check_tor()\" ), ), ]","title":"helptext()"},{"location":"reference/history/","text":"add ( song ) \u00b6 Add song to history. Source code in mps_youtube/history.py def add ( song ): \"\"\" Add song to history. \"\"\" if not g . userhist . get ( 'history' ): g . userhist [ 'history' ] = Playlist ( 'history' ) g . userhist [ 'history' ] . songs . append ( song ) save () load () \u00b6 Open history. Called once on script invocation. Source code in mps_youtube/history.py def load (): \"\"\" Open history. Called once on script invocation. \"\"\" _convert_to_m3u () try : g . userhist [ 'history' ] = read_m3u ( g . HISTFILE ) except FileNotFoundError : # no playlist found, create a blank one if not os . path . isfile ( g . HISTFILE ): g . userhist = {} save () save () \u00b6 Save history. Called each time history is updated. Source code in mps_youtube/history.py def save (): \"\"\" Save history. Called each time history is updated. \"\"\" with open ( g . HISTFILE , 'w' ) as hf : hf . write ( '#EXTM3U \\n\\n ' ) if 'history' in g . userhist : for song in g . userhist [ 'history' ] . songs : hf . write ( '#EXTINF: %d , %s \\n ' % ( song . length , song . title )) hf . write ( 'https://www.youtube.com/watch?v= %s \\n ' % song . ytid ) dbg ( c . r + \"History saved \\n ---\" + c . w )","title":"history.py"},{"location":"reference/history/#mps_youtube.history.add","text":"Add song to history. Source code in mps_youtube/history.py def add ( song ): \"\"\" Add song to history. \"\"\" if not g . userhist . get ( 'history' ): g . userhist [ 'history' ] = Playlist ( 'history' ) g . userhist [ 'history' ] . songs . append ( song ) save ()","title":"add()"},{"location":"reference/history/#mps_youtube.history.load","text":"Open history. Called once on script invocation. Source code in mps_youtube/history.py def load (): \"\"\" Open history. Called once on script invocation. \"\"\" _convert_to_m3u () try : g . userhist [ 'history' ] = read_m3u ( g . HISTFILE ) except FileNotFoundError : # no playlist found, create a blank one if not os . path . isfile ( g . HISTFILE ): g . userhist = {} save ()","title":"load()"},{"location":"reference/history/#mps_youtube.history.save","text":"Save history. Called each time history is updated. Source code in mps_youtube/history.py def save (): \"\"\" Save history. Called each time history is updated. \"\"\" with open ( g . HISTFILE , 'w' ) as hf : hf . write ( '#EXTM3U \\n\\n ' ) if 'history' in g . userhist : for song in g . userhist [ 'history' ] . songs : hf . write ( '#EXTINF: %d , %s \\n ' % ( song . length , song . title )) hf . write ( 'https://www.youtube.com/watch?v= %s \\n ' % song . ytid ) dbg ( c . r + \"History saved \\n ---\" + c . w )","title":"save()"},{"location":"reference/init/","text":"init () \u00b6 Initial setup. Source code in mps_youtube/init.py def init (): \"\"\" Initial setup. \"\"\" _process_cl_args () # set player to mpv or mplayer if found, otherwise unset suffix = \".exe\" if mswin else \"\" vlc , mplayer , mpv = \"vlc\" + suffix , \"mplayer\" + suffix , \"mpv\" + suffix # check for old pickled binary config and convert to json if so config . convert_old_cf_to_json () if not os . path . exists ( g . CFFILE ): if has_exefile ( vlc ): config . PLAYER . set ( vlc ) elif has_exefile ( mpv ): config . PLAYER . set ( mpv ) elif has_exefile ( mplayer ): config . PLAYER . set ( mplayer ) config . save () else : config . load () try : assign_player ( config . PLAYER . get ) # Player is not assigned when config is loaded except Exception as ex : g . message = \" %s Failed to get %s `s version. Probabily it is not installed. Try installing it again or change player using `set player <player_name>` %s \" % ( c . y , config . PLAYER . get , c . w ) screen . update () input ( \"Press Enter to go back to main menu.\" ) # Make pafy use the same api key # pafy.set_api_key(config.API_KEY.get) _init_readline () cache . load () _init_transcode () # ensure encoder is not set beyond range of available presets if config . ENCODER . get >= len ( g . encoders ): config . ENCODER . set ( \"0\" ) # check mpv/mplayer version if has_exefile ( config . PLAYER . get ): load_player_info ( config . PLAYER . get ) # setup colorama if has_colorama and mswin : # Colorama converts ansi escape codes to Windows system calls colorama . init () # find muxer app if mswin : g . muxapp = has_exefile ( \"ffmpeg.exe\" ) or has_exefile ( \"avconv.exe\" ) else : g . muxapp = has_exefile ( \"ffmpeg\" ) or has_exefile ( \"avconv\" ) # initialize MPRIS2 interface if config . MPRIS . get : try : from . import mpris conn1 , conn2 = multiprocessing . Pipe () g . mprisctl = mpris . MprisConnection ( conn1 ) t = multiprocessing . Process ( target = mpris . main , args = ( conn2 ,)) t . daemon = True t . start () except ImportError : print ( \"could not load MPRIS interface. missing libraries.\" )","title":"init.py"},{"location":"reference/init/#mps_youtube.init.init","text":"Initial setup. Source code in mps_youtube/init.py def init (): \"\"\" Initial setup. \"\"\" _process_cl_args () # set player to mpv or mplayer if found, otherwise unset suffix = \".exe\" if mswin else \"\" vlc , mplayer , mpv = \"vlc\" + suffix , \"mplayer\" + suffix , \"mpv\" + suffix # check for old pickled binary config and convert to json if so config . convert_old_cf_to_json () if not os . path . exists ( g . CFFILE ): if has_exefile ( vlc ): config . PLAYER . set ( vlc ) elif has_exefile ( mpv ): config . PLAYER . set ( mpv ) elif has_exefile ( mplayer ): config . PLAYER . set ( mplayer ) config . save () else : config . load () try : assign_player ( config . PLAYER . get ) # Player is not assigned when config is loaded except Exception as ex : g . message = \" %s Failed to get %s `s version. Probabily it is not installed. Try installing it again or change player using `set player <player_name>` %s \" % ( c . y , config . PLAYER . get , c . w ) screen . update () input ( \"Press Enter to go back to main menu.\" ) # Make pafy use the same api key # pafy.set_api_key(config.API_KEY.get) _init_readline () cache . load () _init_transcode () # ensure encoder is not set beyond range of available presets if config . ENCODER . get >= len ( g . encoders ): config . ENCODER . set ( \"0\" ) # check mpv/mplayer version if has_exefile ( config . PLAYER . get ): load_player_info ( config . PLAYER . get ) # setup colorama if has_colorama and mswin : # Colorama converts ansi escape codes to Windows system calls colorama . init () # find muxer app if mswin : g . muxapp = has_exefile ( \"ffmpeg.exe\" ) or has_exefile ( \"avconv.exe\" ) else : g . muxapp = has_exefile ( \"ffmpeg\" ) or has_exefile ( \"avconv\" ) # initialize MPRIS2 interface if config . MPRIS . get : try : from . import mpris conn1 , conn2 = multiprocessing . Pipe () g . mprisctl = mpris . MprisConnection ( conn1 ) t = multiprocessing . Process ( target = mpris . main , args = ( conn2 ,)) t . daemon = True t . start () except ImportError : print ( \"could not load MPRIS interface. missing libraries.\" )","title":"init()"},{"location":"reference/main/","text":"mps-youtube. https://github.com/np1/mps-youtube Copyright (C) 2014, 2015 np1 and contributors This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see http://www.gnu.org/licenses/ . matchfunction ( func , regex , userinput ) \u00b6 Match userinput against regex. Call func, return True if matches. Source code in mps_youtube/main.py def matchfunction ( func , regex , userinput ): \"\"\" Match userinput against regex. Call func, return True if matches. \"\"\" # Not supported in python 3.3 or lower # match = regex.fullmatch(userinput) # if match: match = regex . match ( userinput ) if match and match . group ( 0 ) == userinput : matches = match . groups () util . dbg ( \"input: %s \" , userinput ) util . dbg ( \"function call: %s \" , func . __name__ ) util . dbg ( \"regx matches: %s \" , matches ) try : func ( * matches ) except IndexError : if g . debug_mode : g . content = '' . join ( traceback_py . format_exception ( * sys . exc_info ())) g . message = util . F ( 'invalid range' ) g . content = g . content or content . generate_songlist_display () except ( ValueError , IOError ) as e : if g . debug_mode : g . content = '' . join ( traceback_py . format_exception ( * sys . exc_info ())) g . message = util . F ( 'cant get track' ) % str ( e ) g . content = g . content or \\ content . generate_songlist_display ( zeromsg = g . message ) except Exception as e : #pafy.GdataError as e: import traceback traceback . print_exception ( type ( e ), e , e . __traceback__ ) if g . debug_mode : g . content = '' . join ( traceback . format_exception ( * sys . exc_info ())) g . message = util . F ( 'no data' ) % e g . content = g . content return True prompt_for_exit () \u00b6 Ask for exit confirmation. Source code in mps_youtube/main.py def prompt_for_exit (): \"\"\" Ask for exit confirmation. \"\"\" g . message = c . r + \"Press ctrl-c again to exit\" + c . w g . content = content . generate_songlist_display () screen . update () try : userinput = input ( c . r + \" > \" + c . w ) except ( KeyboardInterrupt , EOFError ): commands . misc . quits ( showlogo = False ) return userinput","title":"main.py"},{"location":"reference/main/#mps_youtube.main.matchfunction","text":"Match userinput against regex. Call func, return True if matches. Source code in mps_youtube/main.py def matchfunction ( func , regex , userinput ): \"\"\" Match userinput against regex. Call func, return True if matches. \"\"\" # Not supported in python 3.3 or lower # match = regex.fullmatch(userinput) # if match: match = regex . match ( userinput ) if match and match . group ( 0 ) == userinput : matches = match . groups () util . dbg ( \"input: %s \" , userinput ) util . dbg ( \"function call: %s \" , func . __name__ ) util . dbg ( \"regx matches: %s \" , matches ) try : func ( * matches ) except IndexError : if g . debug_mode : g . content = '' . join ( traceback_py . format_exception ( * sys . exc_info ())) g . message = util . F ( 'invalid range' ) g . content = g . content or content . generate_songlist_display () except ( ValueError , IOError ) as e : if g . debug_mode : g . content = '' . join ( traceback_py . format_exception ( * sys . exc_info ())) g . message = util . F ( 'cant get track' ) % str ( e ) g . content = g . content or \\ content . generate_songlist_display ( zeromsg = g . message ) except Exception as e : #pafy.GdataError as e: import traceback traceback . print_exception ( type ( e ), e , e . __traceback__ ) if g . debug_mode : g . content = '' . join ( traceback . format_exception ( * sys . exc_info ())) g . message = util . F ( 'no data' ) % e g . content = g . content return True","title":"matchfunction()"},{"location":"reference/main/#mps_youtube.main.prompt_for_exit","text":"Ask for exit confirmation. Source code in mps_youtube/main.py def prompt_for_exit (): \"\"\" Ask for exit confirmation. \"\"\" g . message = c . r + \"Press ctrl-c again to exit\" + c . w g . content = content . generate_songlist_display () screen . update () try : userinput = input ( c . r + \" > \" + c . w ) except ( KeyboardInterrupt , EOFError ): commands . misc . quits ( showlogo = False ) return userinput","title":"prompt_for_exit()"},{"location":"reference/pafy/","text":"channel_search ( query ) \u00b6 Search channel based on keyword / query provided by user Source code in mps_youtube/pafy.py def channel_search ( query ): ''' Search channel based on keyword / query provided by user ''' channelsSearch = ChannelsSearch ( query , limit = 50 , region = 'US' ) return channelsSearch . result ()[ 'result' ] download_video ( ytid , folder ) \u00b6 Given a youtube video id and target folder, this function will download video to that folder Source code in mps_youtube/pafy.py def download_video ( ytid , folder ): ''' Given a youtube video id and target folder, this function will download video to that folder ''' ytdl_format_options = { 'outtmpl' : os . path . join ( folder , ' %(title)s - %(id)s . %(ext)s ' ) } with yt_dlp . YoutubeDL ( ytdl_format_options ) as ydl : ydl . download ( 'https://www.youtube.com/watch?v= %s ' % ytid ) return True extract_video_id ( url ) \u00b6 Extract the video id from a url, return video id as str. Source code in mps_youtube/pafy.py def extract_video_id ( url ): \"\"\" Extract the video id from a url, return video id as str. \"\"\" idregx = re . compile ( r '[\\w-] {11} $' ) url = str ( url ) . strip () if idregx . match ( url ): return url # ID of video if '://' not in url : url = '//' + url parsedurl = urlparse ( url ) if parsedurl . netloc in ( 'youtube.com' , 'www.youtube.com' , 'm.youtube.com' , 'gaming.youtube.com' ): query = parse_qs ( parsedurl . query ) if 'v' in query and idregx . match ( query [ 'v' ][ 0 ]): return query [ 'v' ][ 0 ] elif parsedurl . netloc in ( 'youtu.be' , 'www.youtu.be' ): vidid = parsedurl . path . split ( '/' )[ - 1 ] if parsedurl . path else '' if idregx . match ( vidid ): return vidid err = \"Need 11 character video id or the URL of the video. Got %s \" raise ValueError ( err % url ) get_playlist ( playlist_id ) \u00b6 Get all videos of a playlist identified by playlist_id Source code in mps_youtube/pafy.py def get_playlist ( playlist_id ): ''' Get all videos of a playlist identified by playlist_id ''' playlist = Playlist . get ( 'https://www.youtube.com/playlist?list= %s ' % playlist_id ) return playlist get_video_streams ( ytid ) \u00b6 given a youtube video id returns different video / audio stream formats' Source code in mps_youtube/pafy.py def get_video_streams ( ytid ): ''' given a youtube video id returns different video / audio stream formats' \\ ''' with yt_dlp . YoutubeDL ({ 'logger' : MyLogger ()}) as ydl : info_dict = ydl . extract_info ( ytid , download = False ) return [ i for i in info_dict [ 'formats' ] if i . get ( 'format_note' ) != 'storyboard' ] playlist_search ( query ) \u00b6 Returns all playlists having similar names as keyword / query provided Source code in mps_youtube/pafy.py def playlist_search ( query ): ''' Returns all playlists having similar names as keyword / query provided ''' playlistsSearch = PlaylistsSearch ( query , limit = 50 ) return playlistsSearch . result ()[ 'result' ] search_videos ( query , pages ) \u00b6 Given a keyword / query this function will return youtube video results against those keywords / query Source code in mps_youtube/pafy.py def search_videos ( query , pages ): ''' Given a keyword / query this function will return youtube video results against those keywords / query ''' videosSearch = VideosSearch ( query , limit = 50 ) wdata = videosSearch . result ()[ 'result' ] for i in range ( pages - 1 ): videosSearch . next () wdata . extend ( videosSearch . result ()[ 'result' ]) return wdata","title":"pafy.py"},{"location":"reference/pafy/#mps_youtube.pafy.channel_search","text":"Search channel based on keyword / query provided by user Source code in mps_youtube/pafy.py def channel_search ( query ): ''' Search channel based on keyword / query provided by user ''' channelsSearch = ChannelsSearch ( query , limit = 50 , region = 'US' ) return channelsSearch . result ()[ 'result' ]","title":"channel_search()"},{"location":"reference/pafy/#mps_youtube.pafy.download_video","text":"Given a youtube video id and target folder, this function will download video to that folder Source code in mps_youtube/pafy.py def download_video ( ytid , folder ): ''' Given a youtube video id and target folder, this function will download video to that folder ''' ytdl_format_options = { 'outtmpl' : os . path . join ( folder , ' %(title)s - %(id)s . %(ext)s ' ) } with yt_dlp . YoutubeDL ( ytdl_format_options ) as ydl : ydl . download ( 'https://www.youtube.com/watch?v= %s ' % ytid ) return True","title":"download_video()"},{"location":"reference/pafy/#mps_youtube.pafy.extract_video_id","text":"Extract the video id from a url, return video id as str. Source code in mps_youtube/pafy.py def extract_video_id ( url ): \"\"\" Extract the video id from a url, return video id as str. \"\"\" idregx = re . compile ( r '[\\w-] {11} $' ) url = str ( url ) . strip () if idregx . match ( url ): return url # ID of video if '://' not in url : url = '//' + url parsedurl = urlparse ( url ) if parsedurl . netloc in ( 'youtube.com' , 'www.youtube.com' , 'm.youtube.com' , 'gaming.youtube.com' ): query = parse_qs ( parsedurl . query ) if 'v' in query and idregx . match ( query [ 'v' ][ 0 ]): return query [ 'v' ][ 0 ] elif parsedurl . netloc in ( 'youtu.be' , 'www.youtu.be' ): vidid = parsedurl . path . split ( '/' )[ - 1 ] if parsedurl . path else '' if idregx . match ( vidid ): return vidid err = \"Need 11 character video id or the URL of the video. Got %s \" raise ValueError ( err % url )","title":"extract_video_id()"},{"location":"reference/pafy/#mps_youtube.pafy.get_playlist","text":"Get all videos of a playlist identified by playlist_id Source code in mps_youtube/pafy.py def get_playlist ( playlist_id ): ''' Get all videos of a playlist identified by playlist_id ''' playlist = Playlist . get ( 'https://www.youtube.com/playlist?list= %s ' % playlist_id ) return playlist","title":"get_playlist()"},{"location":"reference/pafy/#mps_youtube.pafy.get_video_streams","text":"given a youtube video id returns different video / audio stream formats' Source code in mps_youtube/pafy.py def get_video_streams ( ytid ): ''' given a youtube video id returns different video / audio stream formats' \\ ''' with yt_dlp . YoutubeDL ({ 'logger' : MyLogger ()}) as ydl : info_dict = ydl . extract_info ( ytid , download = False ) return [ i for i in info_dict [ 'formats' ] if i . get ( 'format_note' ) != 'storyboard' ]","title":"get_video_streams()"},{"location":"reference/pafy/#mps_youtube.pafy.playlist_search","text":"Returns all playlists having similar names as keyword / query provided Source code in mps_youtube/pafy.py def playlist_search ( query ): ''' Returns all playlists having similar names as keyword / query provided ''' playlistsSearch = PlaylistsSearch ( query , limit = 50 ) return playlistsSearch . result ()[ 'result' ]","title":"playlist_search()"},{"location":"reference/pafy/#mps_youtube.pafy.search_videos","text":"Given a keyword / query this function will return youtube video results against those keywords / query Source code in mps_youtube/pafy.py def search_videos ( query , pages ): ''' Given a keyword / query this function will return youtube video results against those keywords / query ''' videosSearch = VideosSearch ( query , limit = 50 ) wdata = videosSearch . result ()[ 'result' ] for i in range ( pages - 1 ): videosSearch . next () wdata . extend ( videosSearch . result ()[ 'result' ]) return wdata","title":"search_videos()"},{"location":"reference/paths/","text":"get_config_dir () \u00b6 Get user's configuration directory. Migrate to new mps name if old. Source code in mps_youtube/paths.py def get_config_dir (): \"\"\" Get user's configuration directory. Migrate to new mps name if old.\"\"\" if mswin : confdir = os . environ [ \"APPDATA\" ] elif 'XDG_CONFIG_HOME' in os . environ : confdir = os . environ [ 'XDG_CONFIG_HOME' ] else : confdir = os . path . join ( os . path . expanduser ( \"~\" ), '.config' ) mps_confdir = os . path . join ( confdir , \"mps-youtube\" ) os . makedirs ( mps_confdir , exist_ok = True ) return mps_confdir get_default_ddir () \u00b6 Get system default Download directory, append mps dir. Source code in mps_youtube/paths.py def get_default_ddir (): \"\"\" Get system default Download directory, append mps dir. \"\"\" user_home = os . path . expanduser ( \"~\" ) join , exists = os . path . join , os . path . exists if mswin : return join ( user_home , \"Downloads\" , \"yewtube\" ) USER_DIRS = join ( user_home , \".config\" , \"user-dirs.dirs\" ) DOWNLOAD_HOME = join ( user_home , \"Downloads\" ) # define ddir by (1) env var, (2) user-dirs.dirs file, # (3) existing ~/Downloads dir (4) ~ if 'XDG_DOWNLOAD_DIR' in os . environ : ddir = os . environ [ 'XDG_DOWNLOAD_DIR' ] elif exists ( USER_DIRS ): lines = open ( USER_DIRS ) . readlines () defn = [ x for x in lines if x . startswith ( \"XDG_DOWNLOAD_DIR\" )] if len ( defn ) == 1 : ddir = defn [ 0 ] . split ( \"=\" )[ 1 ] . replace ( '\"' , '' ) ddir = ddir . replace ( \"$HOME\" , user_home ) . strip () else : ddir = DOWNLOAD_HOME if exists ( DOWNLOAD_HOME ) else user_home else : ddir = DOWNLOAD_HOME if exists ( DOWNLOAD_HOME ) else user_home ddir = ddir return os . path . join ( ddir , \"mps\" )","title":"paths.py"},{"location":"reference/paths/#mps_youtube.paths.get_config_dir","text":"Get user's configuration directory. Migrate to new mps name if old. Source code in mps_youtube/paths.py def get_config_dir (): \"\"\" Get user's configuration directory. Migrate to new mps name if old.\"\"\" if mswin : confdir = os . environ [ \"APPDATA\" ] elif 'XDG_CONFIG_HOME' in os . environ : confdir = os . environ [ 'XDG_CONFIG_HOME' ] else : confdir = os . path . join ( os . path . expanduser ( \"~\" ), '.config' ) mps_confdir = os . path . join ( confdir , \"mps-youtube\" ) os . makedirs ( mps_confdir , exist_ok = True ) return mps_confdir","title":"get_config_dir()"},{"location":"reference/paths/#mps_youtube.paths.get_default_ddir","text":"Get system default Download directory, append mps dir. Source code in mps_youtube/paths.py def get_default_ddir (): \"\"\" Get system default Download directory, append mps dir. \"\"\" user_home = os . path . expanduser ( \"~\" ) join , exists = os . path . join , os . path . exists if mswin : return join ( user_home , \"Downloads\" , \"yewtube\" ) USER_DIRS = join ( user_home , \".config\" , \"user-dirs.dirs\" ) DOWNLOAD_HOME = join ( user_home , \"Downloads\" ) # define ddir by (1) env var, (2) user-dirs.dirs file, # (3) existing ~/Downloads dir (4) ~ if 'XDG_DOWNLOAD_DIR' in os . environ : ddir = os . environ [ 'XDG_DOWNLOAD_DIR' ] elif exists ( USER_DIRS ): lines = open ( USER_DIRS ) . readlines () defn = [ x for x in lines if x . startswith ( \"XDG_DOWNLOAD_DIR\" )] if len ( defn ) == 1 : ddir = defn [ 0 ] . split ( \"=\" )[ 1 ] . replace ( '\"' , '' ) ddir = ddir . replace ( \"$HOME\" , user_home ) . strip () else : ddir = DOWNLOAD_HOME if exists ( DOWNLOAD_HOME ) else user_home else : ddir = DOWNLOAD_HOME if exists ( DOWNLOAD_HOME ) else user_home ddir = ddir return os . path . join ( ddir , \"mps\" )","title":"get_default_ddir()"},{"location":"reference/player/","text":"BasePlayer \u00b6 Source code in mps_youtube/player.py class BasePlayer : _playbackStatus = \"Paused\" _last_displayed_line = None @property def PlaybackStatus ( self ): return self . _playbackStatus @PlaybackStatus . setter def PlaybackStatus ( self , value ): self . _playbackStatus = value if value == 'Playing' : paused = False else : paused = True g . mprisctl . send (( 'pause' , paused )) def play ( self , songlist , shuffle = False , repeat = False , override = False ): \"\"\" Play a range of songs, exit cleanly on keyboard interrupt. \"\"\" if config . ALWAYS_REPEAT . get : repeat = True self . songlist = songlist self . shuffle = shuffle self . repeat = repeat self . override = override if shuffle : random . shuffle ( self . songlist ) self . song_no = 0 while 0 <= self . song_no <= len ( self . songlist ) - 1 : self . song = self . songlist [ self . song_no ] g . content = self . _playback_progress ( self . song_no , self . songlist , repeat = repeat ) if not g . command_line : screen . update ( fill_blank = False ) hasnext = len ( self . songlist ) > self . song_no + 1 if hasnext : streams . preload ( self . songlist [ self . song_no + 1 ], override = self . override ) if config . SET_TITLE . get : util . set_window_title ( self . song . title + \" - yewtube\" ) self . softrepeat = repeat and len ( self . songlist ) == 1 if g . scrobble : lastfm . set_now_playing ( g . artist , g . scrobble_queue [ self . song_no ]) try : self . video , self . stream , self . override = stream_details ( self . song , override = self . override , softrepeat = self . softrepeat ) self . _playsong () except KeyboardInterrupt : logging . info ( \"Keyboard Interrupt\" ) util . xprint ( c . w + \"Stopping... \" ) screen . reset_terminal () g . message = c . y + \"Playback halted\" + c . w raise KeyboardInterrupt break # skip forbidden, video removed/no longer available, etc. tracks except TypeError as e : import traceback traceback . print_exception ( type ( e ), e , e . __traceback__ ) self . song_no += 1 pass if config . SET_TITLE . get : util . set_window_title ( \"yewtube\" ) if self . song_no == - 1 : self . song_no = len ( songlist ) - 1 if repeat else 0 elif self . song_no == len ( self . songlist ) and repeat : self . song_no = 0 # To be defined by subclass based on being cmd player or library # When overriding next and previous don't forget to add the following # if g.scrobble: # lastfm.scrobble_track(g.artist, g.album, g.scrobble_queue[self.song_no]) def next ( self ): pass def previous ( self ): pass def stop ( self ): pass ############### def seek ( self ): pass def _playsong ( self , failcount = 0 , softrepeat = False ): \"\"\" Play song using config.PLAYER called with args config.PLAYERARGS. \"\"\" # pylint: disable=R0911,R0912 if not config . PLAYER . get or not util . has_exefile ( config . PLAYER . get ): g . message = \"Player not configured! Enter %s set player <player_app> \" \\ \" %s to set a player\" % ( c . g , c . w ) return if config . NOTIFIER . get : subprocess . Popen ( shlex . split ( config . NOTIFIER . get ) + [ self . song . title ]) size = streams . get_size ( self . song . ytid , self . stream [ 'url' ]) songdata = ( self . song . ytid , '' if self . stream . get ( 'ext' ) is None else self . stream . get ( 'ext' ) + \" \" + self . stream [ 'quality' ], int ( size / ( 1024 ** 2 ))) self . songdata = \" %s ; %s ; %s Mb\" % songdata screen . writestatus ( self . songdata ) self . _launch_player () if config . HISTORY . get : history . add ( self . song ) def _launch_player ( self ): \"\"\" Launch player application. \"\"\" pass def send_metadata_mpris ( self ): metadata = util . _get_metadata ( self . song . title ) if config . LOOKUP_METADATA . get else None if metadata is None : arturl = \"https://i.ytimg.com/vi/ %s /default.jpg\" % self . song . ytid metadata = ( self . song . ytid , self . song . title , self . song . length , arturl , [ '' ], '' ) else : arturl = metadata [ 'album_art_url' ] metadata = ( self . song . ytid , metadata [ 'track_title' ], self . song . length , arturl , [ metadata [ 'artist' ]], metadata [ 'album' ]) if g . mprisctl : g . mprisctl . send (( 'metadata' , metadata )) def _playback_progress ( self , idx , allsongs , repeat = False ): \"\"\" Generate string to show selected tracks, indicate current track. \"\"\" # pylint: disable=R0914 # too many local variables cw = util . getxy () . width out = \" %s%-X Xs %s%s \\n \" . replace ( \"XX\" , str ( cw - 9 )) out = out % ( c . ul , \"Title\" , \"Time\" , c . w ) multi = len ( allsongs ) > 1 for n , song in enumerate ( allsongs ): length_orig = util . fmt_time ( song . length ) length = \" \" * ( 8 - len ( length_orig )) + length_orig i = util . uea_pad ( cw - 14 , song . title ), length , length_orig fmt = ( c . w , \" \" , c . b , i [ 0 ], c . w , c . y , i [ 1 ], c . w ) if n == idx : fmt = ( c . y , \"> \" , c . p , i [ 0 ], c . w , c . p , i [ 1 ], c . w ) cur = i out += \" %s%s%s%s%s %s%s%s \\n \" % fmt out += \" \\n \" * ( 3 - len ( allsongs )) pos = 8 * \" \" , c . y , idx + 1 , c . w , c . y , len ( allsongs ), c . w playing = \" {}{}{}{} of {}{}{} \\n\\n \" . format ( * pos ) if multi else \" \\n\\n \" keys = self . _help ( short = ( not multi and not repeat )) out = out if multi else content . generate_songlist_display ( song = allsongs [ 0 ]) if config . SHOW_PLAYER_KEYS . get and keys is not None : out += \" \\n \" + keys else : playing = \" {}{}{}{} of {}{}{} \\n \" . format ( * pos ) if multi else \" \\n \" out += \" \\n \" + \" \" * ( cw - 19 ) if multi else \"\" fmt = playing , c . r , cur [ 0 ] . strip ()[: cw - 19 ], c . w , c . w , cur [ 2 ], c . w out += \" %s %s%s%s %s [ %s ] %s \" % fmt out += \" REPEAT MODE\" if repeat else \"\" return out def make_status_line ( self , elapsed_s , prefix , songlength = 0 , volume = None ): self . _line = self . _make_status_line ( elapsed_s , prefix , songlength , volume = volume ) if self . _line != self . _last_displayed_line : screen . writestatus ( self . _line ) self . _last_displayed_line = self . _line def _make_status_line ( self , elapsed_s , prefix , songlength = 0 , volume = None ): \"\"\" Format progress line output. \"\"\" # pylint: disable=R0914 display_s = elapsed_s display_h = display_m = 0 if elapsed_s >= 60 : display_m = display_s // 60 display_s %= 60 if display_m >= 60 : display_h = display_m // 60 display_m %= 60 pct = ( float ( elapsed_s ) / songlength * 100 ) if songlength else 0 status_line = \" %02i : %02i : %02i %s \" % ( display_h , display_m , display_s , ( \"[ %.0f%% ]\" % pct ) . ljust ( 6 ) ) if volume : vol_suffix = \" vol: %d%% \" % volume else : vol_suffix = \"\" cw = util . getxy () . width prog_bar_size = cw - len ( prefix ) - len ( status_line ) - len ( vol_suffix ) - 7 progress = int ( math . ceil ( pct / 100 * prog_bar_size )) status_line += \" [ %s ]\" % ( \"=\" * ( progress - 1 ) + \">\" ) . ljust ( prog_bar_size , ' ' ) return prefix + status_line + vol_suffix play ( self , songlist , shuffle = False , repeat = False , override = False ) \u00b6 Play a range of songs, exit cleanly on keyboard interrupt. Source code in mps_youtube/player.py def play ( self , songlist , shuffle = False , repeat = False , override = False ): \"\"\" Play a range of songs, exit cleanly on keyboard interrupt. \"\"\" if config . ALWAYS_REPEAT . get : repeat = True self . songlist = songlist self . shuffle = shuffle self . repeat = repeat self . override = override if shuffle : random . shuffle ( self . songlist ) self . song_no = 0 while 0 <= self . song_no <= len ( self . songlist ) - 1 : self . song = self . songlist [ self . song_no ] g . content = self . _playback_progress ( self . song_no , self . songlist , repeat = repeat ) if not g . command_line : screen . update ( fill_blank = False ) hasnext = len ( self . songlist ) > self . song_no + 1 if hasnext : streams . preload ( self . songlist [ self . song_no + 1 ], override = self . override ) if config . SET_TITLE . get : util . set_window_title ( self . song . title + \" - yewtube\" ) self . softrepeat = repeat and len ( self . songlist ) == 1 if g . scrobble : lastfm . set_now_playing ( g . artist , g . scrobble_queue [ self . song_no ]) try : self . video , self . stream , self . override = stream_details ( self . song , override = self . override , softrepeat = self . softrepeat ) self . _playsong () except KeyboardInterrupt : logging . info ( \"Keyboard Interrupt\" ) util . xprint ( c . w + \"Stopping... \" ) screen . reset_terminal () g . message = c . y + \"Playback halted\" + c . w raise KeyboardInterrupt break # skip forbidden, video removed/no longer available, etc. tracks except TypeError as e : import traceback traceback . print_exception ( type ( e ), e , e . __traceback__ ) self . song_no += 1 pass if config . SET_TITLE . get : util . set_window_title ( \"yewtube\" ) if self . song_no == - 1 : self . song_no = len ( songlist ) - 1 if repeat else 0 elif self . song_no == len ( self . songlist ) and repeat : self . song_no = 0 stream_details ( song , failcount = 0 , override = False , softrepeat = False ) \u00b6 Fetch stream details for a song. Source code in mps_youtube/player.py def stream_details ( song , failcount = 0 , override = False , softrepeat = False ): \"\"\"Fetch stream details for a song.\"\"\" # don't interrupt preloading: while song . ytid in g . preloading : screen . writestatus ( \"fetching item..\" ) time . sleep ( 0.1 ) try : streams . get ( song , force = failcount , callback = screen . writestatus ) except ( IOError , URLError , HTTPError , socket . timeout ) as e : util . dbg ( \"--ioerror in stream_details call to streams.get %s \" , str ( e )) if \"Youtube says\" in str ( e ): g . message = util . F ( 'cant get track' ) % ( song . title + \" \" + str ( e )) return elif failcount < g . max_retries : util . dbg ( \"--ioerror - trying next stream\" ) failcount += 1 return stream_details ( song , failcount = failcount , override = override , softrepeat = softrepeat ) elif \"pafy\" in str ( e ): g . message = str ( e ) + \" - \" + song . ytid return except ValueError : g . message = util . F ( 'track unresolved' ) util . dbg ( \"----valueerror in stream_details call to streams.get\" ) return if failcount == g . max_retries : raise TypeError () try : video = (( config . SHOW_VIDEO . get and override != \"audio\" ) or ( override in ( \"fullscreen\" , \"window\" , \"forcevid\" ))) m4a = \"mplayer\" not in config . PLAYER . get cached = g . streams [ song . ytid ] stream = streams . select ( cached , q = failcount , audio = ( not video ), m4a_ok = m4a ) # handle no audio stream available, or m4a with mplayer # by switching to video stream and suppressing video output. if ( not stream or failcount ) and not video : util . dbg ( c . r + \"no audio or mplayer m4a, using video stream\" + c . w ) override = \"a-v\" video = True stream = streams . select ( cached , q = failcount , audio = False , maxres = 1600 ) if not stream : raise IOError ( \"No streams available\" ) return ( video , stream , override ) except ( HTTPError ) as e : # Fix for invalid streams (gh-65) util . dbg ( \"----htterror in stream_details call to gen_real_args %s \" , str ( e )) if failcount < g . max_retries : failcount += 1 return stream_details ( song , failcount = failcount , override = override , softrepeat = softrepeat ) else : g . message = str ( e ) return except IOError as e : # this may be cause by attempting to play a https stream with # mplayer # ==== errmsg = e . message if hasattr ( e , \"message\" ) else str ( e ) g . message = c . r + str ( errmsg ) + c . w return","title":"player.py"},{"location":"reference/player/#mps_youtube.player.BasePlayer","text":"Source code in mps_youtube/player.py class BasePlayer : _playbackStatus = \"Paused\" _last_displayed_line = None @property def PlaybackStatus ( self ): return self . _playbackStatus @PlaybackStatus . setter def PlaybackStatus ( self , value ): self . _playbackStatus = value if value == 'Playing' : paused = False else : paused = True g . mprisctl . send (( 'pause' , paused )) def play ( self , songlist , shuffle = False , repeat = False , override = False ): \"\"\" Play a range of songs, exit cleanly on keyboard interrupt. \"\"\" if config . ALWAYS_REPEAT . get : repeat = True self . songlist = songlist self . shuffle = shuffle self . repeat = repeat self . override = override if shuffle : random . shuffle ( self . songlist ) self . song_no = 0 while 0 <= self . song_no <= len ( self . songlist ) - 1 : self . song = self . songlist [ self . song_no ] g . content = self . _playback_progress ( self . song_no , self . songlist , repeat = repeat ) if not g . command_line : screen . update ( fill_blank = False ) hasnext = len ( self . songlist ) > self . song_no + 1 if hasnext : streams . preload ( self . songlist [ self . song_no + 1 ], override = self . override ) if config . SET_TITLE . get : util . set_window_title ( self . song . title + \" - yewtube\" ) self . softrepeat = repeat and len ( self . songlist ) == 1 if g . scrobble : lastfm . set_now_playing ( g . artist , g . scrobble_queue [ self . song_no ]) try : self . video , self . stream , self . override = stream_details ( self . song , override = self . override , softrepeat = self . softrepeat ) self . _playsong () except KeyboardInterrupt : logging . info ( \"Keyboard Interrupt\" ) util . xprint ( c . w + \"Stopping... \" ) screen . reset_terminal () g . message = c . y + \"Playback halted\" + c . w raise KeyboardInterrupt break # skip forbidden, video removed/no longer available, etc. tracks except TypeError as e : import traceback traceback . print_exception ( type ( e ), e , e . __traceback__ ) self . song_no += 1 pass if config . SET_TITLE . get : util . set_window_title ( \"yewtube\" ) if self . song_no == - 1 : self . song_no = len ( songlist ) - 1 if repeat else 0 elif self . song_no == len ( self . songlist ) and repeat : self . song_no = 0 # To be defined by subclass based on being cmd player or library # When overriding next and previous don't forget to add the following # if g.scrobble: # lastfm.scrobble_track(g.artist, g.album, g.scrobble_queue[self.song_no]) def next ( self ): pass def previous ( self ): pass def stop ( self ): pass ############### def seek ( self ): pass def _playsong ( self , failcount = 0 , softrepeat = False ): \"\"\" Play song using config.PLAYER called with args config.PLAYERARGS. \"\"\" # pylint: disable=R0911,R0912 if not config . PLAYER . get or not util . has_exefile ( config . PLAYER . get ): g . message = \"Player not configured! Enter %s set player <player_app> \" \\ \" %s to set a player\" % ( c . g , c . w ) return if config . NOTIFIER . get : subprocess . Popen ( shlex . split ( config . NOTIFIER . get ) + [ self . song . title ]) size = streams . get_size ( self . song . ytid , self . stream [ 'url' ]) songdata = ( self . song . ytid , '' if self . stream . get ( 'ext' ) is None else self . stream . get ( 'ext' ) + \" \" + self . stream [ 'quality' ], int ( size / ( 1024 ** 2 ))) self . songdata = \" %s ; %s ; %s Mb\" % songdata screen . writestatus ( self . songdata ) self . _launch_player () if config . HISTORY . get : history . add ( self . song ) def _launch_player ( self ): \"\"\" Launch player application. \"\"\" pass def send_metadata_mpris ( self ): metadata = util . _get_metadata ( self . song . title ) if config . LOOKUP_METADATA . get else None if metadata is None : arturl = \"https://i.ytimg.com/vi/ %s /default.jpg\" % self . song . ytid metadata = ( self . song . ytid , self . song . title , self . song . length , arturl , [ '' ], '' ) else : arturl = metadata [ 'album_art_url' ] metadata = ( self . song . ytid , metadata [ 'track_title' ], self . song . length , arturl , [ metadata [ 'artist' ]], metadata [ 'album' ]) if g . mprisctl : g . mprisctl . send (( 'metadata' , metadata )) def _playback_progress ( self , idx , allsongs , repeat = False ): \"\"\" Generate string to show selected tracks, indicate current track. \"\"\" # pylint: disable=R0914 # too many local variables cw = util . getxy () . width out = \" %s%-X Xs %s%s \\n \" . replace ( \"XX\" , str ( cw - 9 )) out = out % ( c . ul , \"Title\" , \"Time\" , c . w ) multi = len ( allsongs ) > 1 for n , song in enumerate ( allsongs ): length_orig = util . fmt_time ( song . length ) length = \" \" * ( 8 - len ( length_orig )) + length_orig i = util . uea_pad ( cw - 14 , song . title ), length , length_orig fmt = ( c . w , \" \" , c . b , i [ 0 ], c . w , c . y , i [ 1 ], c . w ) if n == idx : fmt = ( c . y , \"> \" , c . p , i [ 0 ], c . w , c . p , i [ 1 ], c . w ) cur = i out += \" %s%s%s%s%s %s%s%s \\n \" % fmt out += \" \\n \" * ( 3 - len ( allsongs )) pos = 8 * \" \" , c . y , idx + 1 , c . w , c . y , len ( allsongs ), c . w playing = \" {}{}{}{} of {}{}{} \\n\\n \" . format ( * pos ) if multi else \" \\n\\n \" keys = self . _help ( short = ( not multi and not repeat )) out = out if multi else content . generate_songlist_display ( song = allsongs [ 0 ]) if config . SHOW_PLAYER_KEYS . get and keys is not None : out += \" \\n \" + keys else : playing = \" {}{}{}{} of {}{}{} \\n \" . format ( * pos ) if multi else \" \\n \" out += \" \\n \" + \" \" * ( cw - 19 ) if multi else \"\" fmt = playing , c . r , cur [ 0 ] . strip ()[: cw - 19 ], c . w , c . w , cur [ 2 ], c . w out += \" %s %s%s%s %s [ %s ] %s \" % fmt out += \" REPEAT MODE\" if repeat else \"\" return out def make_status_line ( self , elapsed_s , prefix , songlength = 0 , volume = None ): self . _line = self . _make_status_line ( elapsed_s , prefix , songlength , volume = volume ) if self . _line != self . _last_displayed_line : screen . writestatus ( self . _line ) self . _last_displayed_line = self . _line def _make_status_line ( self , elapsed_s , prefix , songlength = 0 , volume = None ): \"\"\" Format progress line output. \"\"\" # pylint: disable=R0914 display_s = elapsed_s display_h = display_m = 0 if elapsed_s >= 60 : display_m = display_s // 60 display_s %= 60 if display_m >= 60 : display_h = display_m // 60 display_m %= 60 pct = ( float ( elapsed_s ) / songlength * 100 ) if songlength else 0 status_line = \" %02i : %02i : %02i %s \" % ( display_h , display_m , display_s , ( \"[ %.0f%% ]\" % pct ) . ljust ( 6 ) ) if volume : vol_suffix = \" vol: %d%% \" % volume else : vol_suffix = \"\" cw = util . getxy () . width prog_bar_size = cw - len ( prefix ) - len ( status_line ) - len ( vol_suffix ) - 7 progress = int ( math . ceil ( pct / 100 * prog_bar_size )) status_line += \" [ %s ]\" % ( \"=\" * ( progress - 1 ) + \">\" ) . ljust ( prog_bar_size , ' ' ) return prefix + status_line + vol_suffix","title":"BasePlayer"},{"location":"reference/player/#mps_youtube.player.BasePlayer.play","text":"Play a range of songs, exit cleanly on keyboard interrupt. Source code in mps_youtube/player.py def play ( self , songlist , shuffle = False , repeat = False , override = False ): \"\"\" Play a range of songs, exit cleanly on keyboard interrupt. \"\"\" if config . ALWAYS_REPEAT . get : repeat = True self . songlist = songlist self . shuffle = shuffle self . repeat = repeat self . override = override if shuffle : random . shuffle ( self . songlist ) self . song_no = 0 while 0 <= self . song_no <= len ( self . songlist ) - 1 : self . song = self . songlist [ self . song_no ] g . content = self . _playback_progress ( self . song_no , self . songlist , repeat = repeat ) if not g . command_line : screen . update ( fill_blank = False ) hasnext = len ( self . songlist ) > self . song_no + 1 if hasnext : streams . preload ( self . songlist [ self . song_no + 1 ], override = self . override ) if config . SET_TITLE . get : util . set_window_title ( self . song . title + \" - yewtube\" ) self . softrepeat = repeat and len ( self . songlist ) == 1 if g . scrobble : lastfm . set_now_playing ( g . artist , g . scrobble_queue [ self . song_no ]) try : self . video , self . stream , self . override = stream_details ( self . song , override = self . override , softrepeat = self . softrepeat ) self . _playsong () except KeyboardInterrupt : logging . info ( \"Keyboard Interrupt\" ) util . xprint ( c . w + \"Stopping... \" ) screen . reset_terminal () g . message = c . y + \"Playback halted\" + c . w raise KeyboardInterrupt break # skip forbidden, video removed/no longer available, etc. tracks except TypeError as e : import traceback traceback . print_exception ( type ( e ), e , e . __traceback__ ) self . song_no += 1 pass if config . SET_TITLE . get : util . set_window_title ( \"yewtube\" ) if self . song_no == - 1 : self . song_no = len ( songlist ) - 1 if repeat else 0 elif self . song_no == len ( self . songlist ) and repeat : self . song_no = 0","title":"play()"},{"location":"reference/player/#mps_youtube.player.stream_details","text":"Fetch stream details for a song. Source code in mps_youtube/player.py def stream_details ( song , failcount = 0 , override = False , softrepeat = False ): \"\"\"Fetch stream details for a song.\"\"\" # don't interrupt preloading: while song . ytid in g . preloading : screen . writestatus ( \"fetching item..\" ) time . sleep ( 0.1 ) try : streams . get ( song , force = failcount , callback = screen . writestatus ) except ( IOError , URLError , HTTPError , socket . timeout ) as e : util . dbg ( \"--ioerror in stream_details call to streams.get %s \" , str ( e )) if \"Youtube says\" in str ( e ): g . message = util . F ( 'cant get track' ) % ( song . title + \" \" + str ( e )) return elif failcount < g . max_retries : util . dbg ( \"--ioerror - trying next stream\" ) failcount += 1 return stream_details ( song , failcount = failcount , override = override , softrepeat = softrepeat ) elif \"pafy\" in str ( e ): g . message = str ( e ) + \" - \" + song . ytid return except ValueError : g . message = util . F ( 'track unresolved' ) util . dbg ( \"----valueerror in stream_details call to streams.get\" ) return if failcount == g . max_retries : raise TypeError () try : video = (( config . SHOW_VIDEO . get and override != \"audio\" ) or ( override in ( \"fullscreen\" , \"window\" , \"forcevid\" ))) m4a = \"mplayer\" not in config . PLAYER . get cached = g . streams [ song . ytid ] stream = streams . select ( cached , q = failcount , audio = ( not video ), m4a_ok = m4a ) # handle no audio stream available, or m4a with mplayer # by switching to video stream and suppressing video output. if ( not stream or failcount ) and not video : util . dbg ( c . r + \"no audio or mplayer m4a, using video stream\" + c . w ) override = \"a-v\" video = True stream = streams . select ( cached , q = failcount , audio = False , maxres = 1600 ) if not stream : raise IOError ( \"No streams available\" ) return ( video , stream , override ) except ( HTTPError ) as e : # Fix for invalid streams (gh-65) util . dbg ( \"----htterror in stream_details call to gen_real_args %s \" , str ( e )) if failcount < g . max_retries : failcount += 1 return stream_details ( song , failcount = failcount , override = override , softrepeat = softrepeat ) else : g . message = str ( e ) return except IOError as e : # this may be cause by attempting to play a https stream with # mplayer # ==== errmsg = e . message if hasattr ( e , \"message\" ) else str ( e ) g . message = c . r + str ( errmsg ) + c . w return","title":"stream_details()"},{"location":"reference/playlist/","text":"Playlist \u00b6 Representation of a playist, has list of songs. Source code in mps_youtube/playlist.py class Playlist : \"\"\" Representation of a playist, has list of songs. \"\"\" def __init__ ( self , name = None , songs = None ): \"\"\" class members. \"\"\" self . name = name self . songs = songs or [] def __len__ ( self ): \"\"\" Return number of tracks. \"\"\" return len ( self . songs ) def __getitem__ ( self , sliced ): return self . songs [ sliced ] def __setitem__ ( self , position , item ): self . songs [ position ] = item def __iter__ ( self ): for i in self . songs : yield i @property def duration ( self ): \"\"\" Sum duration of the playlist. \"\"\" duration = sum ( s . length for s in self . songs ) mins , secs = divmod ( duration , 60 ) hours , mins = divmod ( mins , 60 ) duration = ' {H:02} : {M:02} : {S:02} ' . format ( H = hours , M = mins , S = secs ) return duration duration property readonly \u00b6 Sum duration of the playlist. __init__ ( self , name = None , songs = None ) special \u00b6 class members. Source code in mps_youtube/playlist.py def __init__ ( self , name = None , songs = None ): \"\"\" class members. \"\"\" self . name = name self . songs = songs or [] __len__ ( self ) special \u00b6 Return number of tracks. Source code in mps_youtube/playlist.py def __len__ ( self ): \"\"\" Return number of tracks. \"\"\" return len ( self . songs ) Video \u00b6 Class to represent a YouTube video. Source code in mps_youtube/playlist.py class Video : \"\"\" Class to represent a YouTube video. \"\"\" description = \"\" def __init__ ( self , ytid , title , length ): \"\"\" class members. \"\"\" self . ytid = ytid self . title = title self . length = int ( length ) __init__ ( self , ytid , title , length ) special \u00b6 class members. Source code in mps_youtube/playlist.py def __init__ ( self , ytid , title , length ): \"\"\" class members. \"\"\" self . ytid = ytid self . title = title self . length = int ( length )","title":"playlist.py"},{"location":"reference/playlist/#mps_youtube.playlist.Playlist","text":"Representation of a playist, has list of songs. Source code in mps_youtube/playlist.py class Playlist : \"\"\" Representation of a playist, has list of songs. \"\"\" def __init__ ( self , name = None , songs = None ): \"\"\" class members. \"\"\" self . name = name self . songs = songs or [] def __len__ ( self ): \"\"\" Return number of tracks. \"\"\" return len ( self . songs ) def __getitem__ ( self , sliced ): return self . songs [ sliced ] def __setitem__ ( self , position , item ): self . songs [ position ] = item def __iter__ ( self ): for i in self . songs : yield i @property def duration ( self ): \"\"\" Sum duration of the playlist. \"\"\" duration = sum ( s . length for s in self . songs ) mins , secs = divmod ( duration , 60 ) hours , mins = divmod ( mins , 60 ) duration = ' {H:02} : {M:02} : {S:02} ' . format ( H = hours , M = mins , S = secs ) return duration","title":"Playlist"},{"location":"reference/playlist/#mps_youtube.playlist.Playlist.duration","text":"Sum duration of the playlist.","title":"duration"},{"location":"reference/playlist/#mps_youtube.playlist.Playlist.__init__","text":"class members. Source code in mps_youtube/playlist.py def __init__ ( self , name = None , songs = None ): \"\"\" class members. \"\"\" self . name = name self . songs = songs or []","title":"__init__()"},{"location":"reference/playlist/#mps_youtube.playlist.Playlist.__len__","text":"Return number of tracks. Source code in mps_youtube/playlist.py def __len__ ( self ): \"\"\" Return number of tracks. \"\"\" return len ( self . songs )","title":"__len__()"},{"location":"reference/playlist/#mps_youtube.playlist.Video","text":"Class to represent a YouTube video. Source code in mps_youtube/playlist.py class Video : \"\"\" Class to represent a YouTube video. \"\"\" description = \"\" def __init__ ( self , ytid , title , length ): \"\"\" class members. \"\"\" self . ytid = ytid self . title = title self . length = int ( length )","title":"Video"},{"location":"reference/playlist/#mps_youtube.playlist.Video.__init__","text":"class members. Source code in mps_youtube/playlist.py def __init__ ( self , ytid , title , length ): \"\"\" class members. \"\"\" self . ytid = ytid self . title = title self . length = int ( length )","title":"__init__()"},{"location":"reference/playlists/","text":"delete ( name ) \u00b6 Delete playlist, including m3u file. Source code in mps_youtube/playlists.py def delete ( name ): \"\"\" Delete playlist, including m3u file. \"\"\" del g . userpl [ name ] os . remove ( os . path . join ( g . PLFOLDER , name + '.m3u' )) load () \u00b6 Open playlists. Called once on script invocation. Source code in mps_youtube/playlists.py def load (): \"\"\" Open playlists. Called once on script invocation. \"\"\" _convert_playlist_to_v2 () _convert_playlist_to_m3u () try : # Loop through all files ending in '.m3u' for m3u in [ m3u for m3u in os . listdir ( g . PLFOLDER ) if m3u [ - 4 :] == '.m3u' ]: g . userpl [ m3u [: - 4 ]] = read_m3u ( os . path . join ( g . PLFOLDER , m3u )) except FileNotFoundError : # No playlist folder, create an empty one if not os . path . isdir ( g . PLFOLDER ): g . userpl = {} os . mkdir ( g . PLFOLDER ) save () # remove any cached urls from playlist file, these are now # stored in a separate cache file do_save = False for k , v in g . userpl . items (): for song in v . songs : if hasattr ( song , \"urls\" ): util . dbg ( \"remove %s : %s \" , k , song . urls ) del song . urls do_save = True if do_save : save () read_m3u ( m3u ) \u00b6 Processes an m3u file into a Playlist object. Source code in mps_youtube/playlists.py def read_m3u ( m3u ): \"\"\" Processes an m3u file into a Playlist object. \"\"\" name = os . path . basename ( m3u )[: - 4 ] songs = [] expect_ytid = False with open ( m3u , 'r' ) as plf : if plf . readline () . startswith ( '#EXTM3U' ): for line in plf : if line . startswith ( '#EXTINF:' ) and not expect_ytid : duration , title = line . replace ( '#EXTINF:' , '' ) . strip () . split ( ',' , 1 ) expect_ytid = True elif not line . startswith ( ' \\n ' ) and not line . startswith ( '#' ) and expect_ytid : try : expect_ytid = False ytid = pafy . extract_video_id ( line ) . strip () songs . append ( Video ( ytid , title , int ( duration ))) except ValueError as ex : util . dbg ( c . r + str ( ex ) + c . w ) # Handles a simple m3u file which should just be a list of urls else : plf . seek ( 0 ) for line in plf : if not line . startswith ( '#' ): try : p = util . get_pafy ( line ) songs . append ( Video ( p . videoid , p . title , p . length )) except ( IOError , ValueError ) as e : util . dbg ( c . r + \"Error loading video: \" + str ( e ) + c . w ) return Playlist ( name , songs ) save () \u00b6 Save playlists. Called each time a playlist is saved or deleted. Source code in mps_youtube/playlists.py def save (): \"\"\" Save playlists. Called each time a playlist is saved or deleted. \"\"\" for pl in g . userpl : with open ( os . path . join ( g . PLFOLDER , pl + '.m3u' ), 'w' ) as plf : plf . write ( '#EXTM3U \\n\\n ' ) for song in g . userpl [ pl ] . songs : plf . write ( '#EXTINF: %d , %s \\n ' % ( song . length , song . title )) plf . write ( 'https://www.youtube.com/watch?v= %s \\n ' % song . ytid ) util . dbg ( c . r + \"Playlist saved \\n ---\" + c . w )","title":"playlists.py"},{"location":"reference/playlists/#mps_youtube.playlists.delete","text":"Delete playlist, including m3u file. Source code in mps_youtube/playlists.py def delete ( name ): \"\"\" Delete playlist, including m3u file. \"\"\" del g . userpl [ name ] os . remove ( os . path . join ( g . PLFOLDER , name + '.m3u' ))","title":"delete()"},{"location":"reference/playlists/#mps_youtube.playlists.load","text":"Open playlists. Called once on script invocation. Source code in mps_youtube/playlists.py def load (): \"\"\" Open playlists. Called once on script invocation. \"\"\" _convert_playlist_to_v2 () _convert_playlist_to_m3u () try : # Loop through all files ending in '.m3u' for m3u in [ m3u for m3u in os . listdir ( g . PLFOLDER ) if m3u [ - 4 :] == '.m3u' ]: g . userpl [ m3u [: - 4 ]] = read_m3u ( os . path . join ( g . PLFOLDER , m3u )) except FileNotFoundError : # No playlist folder, create an empty one if not os . path . isdir ( g . PLFOLDER ): g . userpl = {} os . mkdir ( g . PLFOLDER ) save () # remove any cached urls from playlist file, these are now # stored in a separate cache file do_save = False for k , v in g . userpl . items (): for song in v . songs : if hasattr ( song , \"urls\" ): util . dbg ( \"remove %s : %s \" , k , song . urls ) del song . urls do_save = True if do_save : save ()","title":"load()"},{"location":"reference/playlists/#mps_youtube.playlists.read_m3u","text":"Processes an m3u file into a Playlist object. Source code in mps_youtube/playlists.py def read_m3u ( m3u ): \"\"\" Processes an m3u file into a Playlist object. \"\"\" name = os . path . basename ( m3u )[: - 4 ] songs = [] expect_ytid = False with open ( m3u , 'r' ) as plf : if plf . readline () . startswith ( '#EXTM3U' ): for line in plf : if line . startswith ( '#EXTINF:' ) and not expect_ytid : duration , title = line . replace ( '#EXTINF:' , '' ) . strip () . split ( ',' , 1 ) expect_ytid = True elif not line . startswith ( ' \\n ' ) and not line . startswith ( '#' ) and expect_ytid : try : expect_ytid = False ytid = pafy . extract_video_id ( line ) . strip () songs . append ( Video ( ytid , title , int ( duration ))) except ValueError as ex : util . dbg ( c . r + str ( ex ) + c . w ) # Handles a simple m3u file which should just be a list of urls else : plf . seek ( 0 ) for line in plf : if not line . startswith ( '#' ): try : p = util . get_pafy ( line ) songs . append ( Video ( p . videoid , p . title , p . length )) except ( IOError , ValueError ) as e : util . dbg ( c . r + \"Error loading video: \" + str ( e ) + c . w ) return Playlist ( name , songs )","title":"read_m3u()"},{"location":"reference/playlists/#mps_youtube.playlists.save","text":"Save playlists. Called each time a playlist is saved or deleted. Source code in mps_youtube/playlists.py def save (): \"\"\" Save playlists. Called each time a playlist is saved or deleted. \"\"\" for pl in g . userpl : with open ( os . path . join ( g . PLFOLDER , pl + '.m3u' ), 'w' ) as plf : plf . write ( '#EXTM3U \\n\\n ' ) for song in g . userpl [ pl ] . songs : plf . write ( '#EXTINF: %d , %s \\n ' % ( song . length , song . title )) plf . write ( 'https://www.youtube.com/watch?v= %s \\n ' % song . ytid ) util . dbg ( c . r + \"Playlist saved \\n ---\" + c . w )","title":"save()"},{"location":"reference/screen/","text":"clear () \u00b6 Clear all text from screen. Source code in mps_youtube/screen.py def clear (): \"\"\"Clear all text from screen.\"\"\" if g . no_clear_screen : util . xprint ( '-- \\n ' ) else : util . xprint ( ' \\n ' * 200 ) msgexit ( msg , code = 0 ) \u00b6 Print a message and exit. Source code in mps_youtube/screen.py def msgexit ( msg , code = 0 ): \"\"\" Print a message and exit. \"\"\" util . xprint ( msg ) sys . exit ( code ) reset_terminal () \u00b6 Reset terminal control character and modes for non Win OS's. Source code in mps_youtube/screen.py def reset_terminal (): \"\"\" Reset terminal control character and modes for non Win OS's. \"\"\" if not mswin : subprocess . call ([ \"tset\" , \"-c\" ]) update ( fill_blank = True ) \u00b6 Display content, show message, blank screen. Source code in mps_youtube/screen.py def update ( fill_blank = True ): \"\"\" Display content, show message, blank screen.\"\"\" clear () if isinstance ( g . content , content . PaginatedContent ): util . xprint ( g . content . getPage ( g . current_page )) g . rprompt = content . page_msg ( g . current_page ) elif g . content : util . xprint ( g . content ) g . content = False if g . message or g . rprompt : out = g . message or '' blanks = util . getxy () . width - len ( out ) - len ( g . rprompt or '' ) out += ' ' * blanks + ( g . rprompt or '' ) util . xprint ( out ) elif fill_blank : util . xprint ( \"\" ) g . message = g . rprompt = False writestatus ( text , mute = False ) \u00b6 Update status line. Source code in mps_youtube/screen.py def writestatus ( text , mute = False ): \"\"\" Update status line. \"\"\" if not mute and config . SHOW_STATUS . get : _writeline ( text )","title":"screen.py"},{"location":"reference/screen/#mps_youtube.screen.clear","text":"Clear all text from screen. Source code in mps_youtube/screen.py def clear (): \"\"\"Clear all text from screen.\"\"\" if g . no_clear_screen : util . xprint ( '-- \\n ' ) else : util . xprint ( ' \\n ' * 200 )","title":"clear()"},{"location":"reference/screen/#mps_youtube.screen.msgexit","text":"Print a message and exit. Source code in mps_youtube/screen.py def msgexit ( msg , code = 0 ): \"\"\" Print a message and exit. \"\"\" util . xprint ( msg ) sys . exit ( code )","title":"msgexit()"},{"location":"reference/screen/#mps_youtube.screen.reset_terminal","text":"Reset terminal control character and modes for non Win OS's. Source code in mps_youtube/screen.py def reset_terminal (): \"\"\" Reset terminal control character and modes for non Win OS's. \"\"\" if not mswin : subprocess . call ([ \"tset\" , \"-c\" ])","title":"reset_terminal()"},{"location":"reference/screen/#mps_youtube.screen.update","text":"Display content, show message, blank screen. Source code in mps_youtube/screen.py def update ( fill_blank = True ): \"\"\" Display content, show message, blank screen.\"\"\" clear () if isinstance ( g . content , content . PaginatedContent ): util . xprint ( g . content . getPage ( g . current_page )) g . rprompt = content . page_msg ( g . current_page ) elif g . content : util . xprint ( g . content ) g . content = False if g . message or g . rprompt : out = g . message or '' blanks = util . getxy () . width - len ( out ) - len ( g . rprompt or '' ) out += ' ' * blanks + ( g . rprompt or '' ) util . xprint ( out ) elif fill_blank : util . xprint ( \"\" ) g . message = g . rprompt = False","title":"update()"},{"location":"reference/screen/#mps_youtube.screen.writestatus","text":"Update status line. Source code in mps_youtube/screen.py def writestatus ( text , mute = False ): \"\"\" Update status line. \"\"\" if not mute and config . SHOW_STATUS . get : _writeline ( text )","title":"writestatus()"},{"location":"reference/streams/","text":"get ( vid , force = False , callback = None , threeD = False ) \u00b6 Get all streams as a dict. callback function passed to get_pafy. Source code in mps_youtube/streams.py def get ( vid , force = False , callback = None , threeD = False ): \"\"\" Get all streams as a dict. callback function passed to get_pafy. \"\"\" now = time . time () ytid = vid . ytid have_stream = g . streams . get ( ytid ) and ( g . streams [ ytid ][ 'expiry' ] > now if g . streams [ ytid ][ 'expiry' ] is not None else False ) prfx = \"preload: \" if not callback else \"\" if not force and have_stream : ss = str ( int ( g . streams [ ytid ][ 'expiry' ] - now ) // 60 ) util . dbg ( \" %s%s Got streams from cache ( %s mins left) %s \" , c . g , prfx , ss , c . w ) return g . streams . get ( ytid )[ 'meta' ] #p = None#util.get_pafy(vid, force=force, callback=callback) #ps = p.allstreams if threeD else [x for x in p.allstreams if not x.threed] ps = pafy . get_video_streams ( ytid ) try : # test urls are valid [ x [ 'url' ] for x in ps ] except TypeError : # refetch if problem util . dbg ( \" %s ****Type Error in get_streams. Retrying %s \" , c . r , c . w ) p = util . get_pafy ( vid , force = True , callback = callback ) ps = p . allstreams if threeD else [ x for x in p . allstreams if not x . threed ] streams = [{ \"url\" : s [ 'url' ], \"ext\" : s [ 'ext' ], \"quality\" : s [ 'resolution' ], \"rawbitrate\" : s . get ( 'bitrate' , - 1 ), \"mtype\" : 'audio' if 'audio' in s [ 'resolution' ] else ( 'video' if s [ 'acodec' ] != 'none' else '?' ), \"size\" : int ( s . get ( 'filesize' ) if s . get ( 'filesize' ) is not None else s . get ( 'filesize_approx' , - 1 ))} for s in ps ] if 'manifest' in streams [ 0 ][ 'url' ]: expiry = float ( streams [ 0 ][ 'url' ] . split ( '/expire/' )[ 1 ] . split ( '/' )[ 0 ]) else : temp = streams [ 0 ][ 'url' ] . split ( 'expire=' )[ 1 ] expiry = float ( temp [: temp . find ( '&' )]) g . streams [ ytid ] = dict ( expiry = expiry , meta = streams ) prune () return streams get_size ( ytid , url , preloading = False ) \u00b6 Get size of stream, try stream cache first. Source code in mps_youtube/streams.py def get_size ( ytid , url , preloading = False ): \"\"\" Get size of stream, try stream cache first. \"\"\" # try cached value stream = [ x for x in g . streams [ ytid ][ 'meta' ] if x [ 'url' ] == url ][ 0 ] size = stream [ 'size' ] prefix = \"preload: \" if preloading else \"\" if not size == - 1 : util . dbg ( \" %s%s using cached size: %s%s \" , c . g , prefix , size , c . w ) else : screen . writestatus ( \"Getting content length\" , mute = preloading ) stream [ 'size' ] = _get_content_length ( url , preloading = preloading ) util . dbg ( \" %s%s - content-length: %s%s \" , c . y , prefix , stream [ 'size' ], c . w ) return stream [ 'size' ] preload ( song , delay = 2 , override = False ) \u00b6 Get streams. Source code in mps_youtube/streams.py def preload ( song , delay = 2 , override = False ): \"\"\" Get streams. \"\"\" args = ( song , delay , override ) t = threading . Thread ( target = _preload , args = args ) t . daemon = True t . start () prune () \u00b6 Keep cache size in check. Source code in mps_youtube/streams.py def prune (): \"\"\" Keep cache size in check. \"\"\" while len ( g . pafs ) > g . max_cached_streams : g . pafs . popitem ( last = False ) while len ( g . streams ) > g . max_cached_streams : g . streams . popitem ( last = False ) # prune time expired items now = time . time () oldpafs = [ k for k in g . pafs if g . pafs [ k ] is not None and g . pafs [ k ] . expiry < now ] if len ( oldpafs ): util . dbg ( c . r + \" %s old pafy items pruned %s \" , len ( oldpafs ), c . w ) for oldpaf in oldpafs : g . pafs . pop ( oldpaf , 0 ) oldstreams = [ k for k in g . streams if g . streams [ k ][ 'expiry' ] is None or g . streams [ k ][ 'expiry' ] < now ] if len ( oldstreams ): util . dbg ( c . r + \" %s old stream items pruned %s \" , len ( oldstreams ), c . w ) for oldstream in oldstreams : g . streams . pop ( oldstream , 0 ) util . dbg ( c . b + \"paf: %s , streams: %s%s \" , len ( g . pafs ), len ( g . streams ), c . w ) select ( slist , q = 0 , audio = False , m4a_ok = True , maxres = None ) \u00b6 Select a stream from stream list. Source code in mps_youtube/streams.py def select ( slist , q = 0 , audio = False , m4a_ok = True , maxres = None ): \"\"\" Select a stream from stream list. \"\"\" maxres = maxres or config . MAX_RES . get slist = slist [ 'meta' ] if isinstance ( slist , dict ) else slist def okres ( x ): \"\"\" Return True if resolution is within user specified maxres. \"\"\" return int ( x [ 'quality' ] . split ( \"x\" )[ 1 ]) <= maxres def getq ( x ): \"\"\" Return height aspect of resolution, eg 640x480 => 480. \"\"\" return int ( x [ 'quality' ] . split ( \"x\" )[ 1 ]) def getbitrate ( x ): \"\"\"Return the bitrate of a stream.\"\"\" return x [ 'rawbitrate' ] if audio : streams = [ x for x in slist if x [ 'mtype' ] == \"audio\" ] if not m4a_ok : streams = [ x for x in streams if not x [ 'ext' ] == \"m4a\" ] if not config . AUDIO_FORMAT . get == \"auto\" : if m4a_ok and config . AUDIO_FORMAT . get == \"m4a\" : streams = [ x for x in streams if x [ 'ext' ] == \"m4a\" ] if config . AUDIO_FORMAT . get == \"webm\" : streams = [ x for x in streams if x [ 'ext' ] == \"webm\" ] if not streams : streams = [ x for x in slist if x [ 'mtype' ] == \"audio\" ] streams = sorted ( streams , key = getbitrate , reverse = True ) else : streams = [ x for x in slist if x [ 'mtype' ] == \"video\" and okres ( x )] if not config . VIDEO_FORMAT . get == \"auto\" : if config . VIDEO_FORMAT . get == \"mp4\" : streams = [ x for x in streams if x [ 'ext' ] == \"mp4\" ] if config . VIDEO_FORMAT . get == \"webm\" : streams = [ x for x in streams if x [ 'ext' ] == \"webm\" ] if config . VIDEO_FORMAT . get == \"3gp\" : streams = [ x for x in streams if x [ 'ext' ] == \"3gp\" ] if not streams : streams = [ x for x in slist if x [ 'mtype' ] == \"video\" and okres ( x )] streams = sorted ( streams , key = getq , reverse = True ) util . dbg ( \"select stream, q: %s , audio: %s , len: %s \" , q , audio , len ( streams )) try : ret = streams [ q ] except IndexError : ret = streams [ 0 ] if q and len ( streams ) else None return ret","title":"streams.py"},{"location":"reference/streams/#mps_youtube.streams.get","text":"Get all streams as a dict. callback function passed to get_pafy. Source code in mps_youtube/streams.py def get ( vid , force = False , callback = None , threeD = False ): \"\"\" Get all streams as a dict. callback function passed to get_pafy. \"\"\" now = time . time () ytid = vid . ytid have_stream = g . streams . get ( ytid ) and ( g . streams [ ytid ][ 'expiry' ] > now if g . streams [ ytid ][ 'expiry' ] is not None else False ) prfx = \"preload: \" if not callback else \"\" if not force and have_stream : ss = str ( int ( g . streams [ ytid ][ 'expiry' ] - now ) // 60 ) util . dbg ( \" %s%s Got streams from cache ( %s mins left) %s \" , c . g , prfx , ss , c . w ) return g . streams . get ( ytid )[ 'meta' ] #p = None#util.get_pafy(vid, force=force, callback=callback) #ps = p.allstreams if threeD else [x for x in p.allstreams if not x.threed] ps = pafy . get_video_streams ( ytid ) try : # test urls are valid [ x [ 'url' ] for x in ps ] except TypeError : # refetch if problem util . dbg ( \" %s ****Type Error in get_streams. Retrying %s \" , c . r , c . w ) p = util . get_pafy ( vid , force = True , callback = callback ) ps = p . allstreams if threeD else [ x for x in p . allstreams if not x . threed ] streams = [{ \"url\" : s [ 'url' ], \"ext\" : s [ 'ext' ], \"quality\" : s [ 'resolution' ], \"rawbitrate\" : s . get ( 'bitrate' , - 1 ), \"mtype\" : 'audio' if 'audio' in s [ 'resolution' ] else ( 'video' if s [ 'acodec' ] != 'none' else '?' ), \"size\" : int ( s . get ( 'filesize' ) if s . get ( 'filesize' ) is not None else s . get ( 'filesize_approx' , - 1 ))} for s in ps ] if 'manifest' in streams [ 0 ][ 'url' ]: expiry = float ( streams [ 0 ][ 'url' ] . split ( '/expire/' )[ 1 ] . split ( '/' )[ 0 ]) else : temp = streams [ 0 ][ 'url' ] . split ( 'expire=' )[ 1 ] expiry = float ( temp [: temp . find ( '&' )]) g . streams [ ytid ] = dict ( expiry = expiry , meta = streams ) prune () return streams","title":"get()"},{"location":"reference/streams/#mps_youtube.streams.get_size","text":"Get size of stream, try stream cache first. Source code in mps_youtube/streams.py def get_size ( ytid , url , preloading = False ): \"\"\" Get size of stream, try stream cache first. \"\"\" # try cached value stream = [ x for x in g . streams [ ytid ][ 'meta' ] if x [ 'url' ] == url ][ 0 ] size = stream [ 'size' ] prefix = \"preload: \" if preloading else \"\" if not size == - 1 : util . dbg ( \" %s%s using cached size: %s%s \" , c . g , prefix , size , c . w ) else : screen . writestatus ( \"Getting content length\" , mute = preloading ) stream [ 'size' ] = _get_content_length ( url , preloading = preloading ) util . dbg ( \" %s%s - content-length: %s%s \" , c . y , prefix , stream [ 'size' ], c . w ) return stream [ 'size' ]","title":"get_size()"},{"location":"reference/streams/#mps_youtube.streams.preload","text":"Get streams. Source code in mps_youtube/streams.py def preload ( song , delay = 2 , override = False ): \"\"\" Get streams. \"\"\" args = ( song , delay , override ) t = threading . Thread ( target = _preload , args = args ) t . daemon = True t . start ()","title":"preload()"},{"location":"reference/streams/#mps_youtube.streams.prune","text":"Keep cache size in check. Source code in mps_youtube/streams.py def prune (): \"\"\" Keep cache size in check. \"\"\" while len ( g . pafs ) > g . max_cached_streams : g . pafs . popitem ( last = False ) while len ( g . streams ) > g . max_cached_streams : g . streams . popitem ( last = False ) # prune time expired items now = time . time () oldpafs = [ k for k in g . pafs if g . pafs [ k ] is not None and g . pafs [ k ] . expiry < now ] if len ( oldpafs ): util . dbg ( c . r + \" %s old pafy items pruned %s \" , len ( oldpafs ), c . w ) for oldpaf in oldpafs : g . pafs . pop ( oldpaf , 0 ) oldstreams = [ k for k in g . streams if g . streams [ k ][ 'expiry' ] is None or g . streams [ k ][ 'expiry' ] < now ] if len ( oldstreams ): util . dbg ( c . r + \" %s old stream items pruned %s \" , len ( oldstreams ), c . w ) for oldstream in oldstreams : g . streams . pop ( oldstream , 0 ) util . dbg ( c . b + \"paf: %s , streams: %s%s \" , len ( g . pafs ), len ( g . streams ), c . w )","title":"prune()"},{"location":"reference/streams/#mps_youtube.streams.select","text":"Select a stream from stream list. Source code in mps_youtube/streams.py def select ( slist , q = 0 , audio = False , m4a_ok = True , maxres = None ): \"\"\" Select a stream from stream list. \"\"\" maxres = maxres or config . MAX_RES . get slist = slist [ 'meta' ] if isinstance ( slist , dict ) else slist def okres ( x ): \"\"\" Return True if resolution is within user specified maxres. \"\"\" return int ( x [ 'quality' ] . split ( \"x\" )[ 1 ]) <= maxres def getq ( x ): \"\"\" Return height aspect of resolution, eg 640x480 => 480. \"\"\" return int ( x [ 'quality' ] . split ( \"x\" )[ 1 ]) def getbitrate ( x ): \"\"\"Return the bitrate of a stream.\"\"\" return x [ 'rawbitrate' ] if audio : streams = [ x for x in slist if x [ 'mtype' ] == \"audio\" ] if not m4a_ok : streams = [ x for x in streams if not x [ 'ext' ] == \"m4a\" ] if not config . AUDIO_FORMAT . get == \"auto\" : if m4a_ok and config . AUDIO_FORMAT . get == \"m4a\" : streams = [ x for x in streams if x [ 'ext' ] == \"m4a\" ] if config . AUDIO_FORMAT . get == \"webm\" : streams = [ x for x in streams if x [ 'ext' ] == \"webm\" ] if not streams : streams = [ x for x in slist if x [ 'mtype' ] == \"audio\" ] streams = sorted ( streams , key = getbitrate , reverse = True ) else : streams = [ x for x in slist if x [ 'mtype' ] == \"video\" and okres ( x )] if not config . VIDEO_FORMAT . get == \"auto\" : if config . VIDEO_FORMAT . get == \"mp4\" : streams = [ x for x in streams if x [ 'ext' ] == \"mp4\" ] if config . VIDEO_FORMAT . get == \"webm\" : streams = [ x for x in streams if x [ 'ext' ] == \"webm\" ] if config . VIDEO_FORMAT . get == \"3gp\" : streams = [ x for x in streams if x [ 'ext' ] == \"3gp\" ] if not streams : streams = [ x for x in slist if x [ 'mtype' ] == \"video\" and okres ( x )] streams = sorted ( streams , key = getq , reverse = True ) util . dbg ( \"select stream, q: %s , audio: %s , len: %s \" , q , audio , len ( streams )) try : ret = streams [ q ] except IndexError : ret = streams [ 0 ] if q and len ( streams ) else None return ret","title":"select()"},{"location":"reference/terminalsize/","text":"Terminal Size. get_terminal_size () \u00b6 getTerminalSize(). get width and height of console works on linux,os x,windows,cygwin(windows) originally retrieved from: http://stackoverflow.com/questions/566746/how-to-get-console-window-width-in-python Source code in mps_youtube/terminalsize.py def get_terminal_size (): \"\"\" getTerminalSize(). - get width and height of console - works on linux,os x,windows,cygwin(windows) originally retrieved from: http://stackoverflow.com/questions/566746/how-to-get-console-window-width-in-python \"\"\" if sys . version_info >= ( 3 , 3 ): return shutil . get_terminal_size () current_os = platform . system () tuple_xy = None if current_os == 'Windows' : tuple_xy = _get_terminal_size_windows () if tuple_xy is None : tuple_xy = _get_terminal_size_tput () # needed for window's python in cygwin's xterm! else : tuple_xy = _get_terminal_size_linux () if tuple_xy is None : tuple_xy = ( 80 , 25 ) # default value return tuple_xy","title":"terminalsize.py"},{"location":"reference/terminalsize/#mps_youtube.terminalsize.get_terminal_size","text":"getTerminalSize(). get width and height of console works on linux,os x,windows,cygwin(windows) originally retrieved from: http://stackoverflow.com/questions/566746/how-to-get-console-window-width-in-python Source code in mps_youtube/terminalsize.py def get_terminal_size (): \"\"\" getTerminalSize(). - get width and height of console - works on linux,os x,windows,cygwin(windows) originally retrieved from: http://stackoverflow.com/questions/566746/how-to-get-console-window-width-in-python \"\"\" if sys . version_info >= ( 3 , 3 ): return shutil . get_terminal_size () current_os = platform . system () tuple_xy = None if current_os == 'Windows' : tuple_xy = _get_terminal_size_windows () if tuple_xy is None : tuple_xy = _get_terminal_size_tput () # needed for window's python in cygwin's xterm! else : tuple_xy = _get_terminal_size_linux () if tuple_xy is None : tuple_xy = ( 80 , 25 ) # default value return tuple_xy","title":"get_terminal_size()"},{"location":"reference/util/","text":"IterSlicer \u00b6 Class that takes an iterable and allows slicing, loading from the iterable as needed. Source code in mps_youtube/util.py class IterSlicer (): \"\"\" Class that takes an iterable and allows slicing, loading from the iterable as needed.\"\"\" def __init__ ( self , iterable , length = None ): self . ilist = [] self . iterable = iter ( iterable ) self . length = length if length is None : try : self . length = len ( iterable ) except TypeError : pass def __getitem__ ( self , sliced ): if isinstance ( sliced , slice ): stop = sliced . stop else : stop = sliced # To get the last item in an iterable, must iterate over all items if ( stop is None ) or ( stop < 0 ): stop = None while ( stop is None ) or ( stop > len ( self . ilist ) - 1 ): try : self . ilist . append ( next ( self . iterable )) except StopIteration : break return self . ilist [ sliced ] def __len__ ( self ): if self . length is None : self . length = len ( self [:]) return self . length XYTuple ( tuple ) \u00b6 XYTuple(width, height, max_results) __getnewargs__ ( self ) special \u00b6 Return self as a plain tuple. Used by copy and pickle. Source code in mps_youtube/util.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , width , height , max_results ) special staticmethod \u00b6 Create new instance of XYTuple(width, height, max_results) __repr__ ( self ) special \u00b6 Return a nicely formatted representation string Source code in mps_youtube/util.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self F ( key , nb = 0 , na = 0 , textlib = None ) \u00b6 Format text. :param nb: newline before :type nb: int :param na: newline after :type na: int :param textlib: the dictionary to use (defaults to g.text if not given) :type textlib: dict :returns: A string, potentially containing one or more %s :rtype: str Source code in mps_youtube/util.py def F ( key , nb = 0 , na = 0 , textlib = None ): \"\"\"Format text. :param nb: newline before :type nb: int :param na: newline after :type na: int :param textlib: the dictionary to use (defaults to g.text if not given) :type textlib: dict :returns: A string, potentially containing one or more %s :rtype: str \"\"\" textlib = textlib or g . text assert key in textlib text = textlib [ key ] percent_fmt = textlib . get ( key + \"_\" ) if percent_fmt : text = re . sub ( r \"\\*\" , r \" %s \" , text ) % percent_fmt text = text . replace ( \"&&\" , \" %s \" ) return \" \\n \" * nb + text + c . w + \" \\n \" * na correct_truncate ( text , max_len ) \u00b6 Truncate a string taking into account East Asian width chars. Source code in mps_youtube/util.py def correct_truncate ( text , max_len ): \"\"\" Truncate a string taking into account East Asian width chars.\"\"\" str_len , out = 0 , '' for c in text : str_len += real_len ( c ) if str_len <= max_len : out += c else : break return out dbg ( * args ) \u00b6 Emit a debug message. Source code in mps_youtube/util.py def dbg ( * args ): \"\"\"Emit a debug message.\"\"\" # Uses xenc to deal with UnicodeEncodeError when writing to terminal logging . debug ( * ( xenc ( i ) for i in args )) fmt_time ( seconds ) \u00b6 Format number of seconds to %H:%M:%S. Source code in mps_youtube/util.py def fmt_time ( seconds ): \"\"\" Format number of seconds to %H:%M:%S. \"\"\" hms = time . strftime ( '%H:%M:%S' , time . gmtime ( int ( seconds ))) H , M , S = hms . split ( \":\" ) if H == \"00\" : hms = M + \":\" + S elif H == \"01\" and int ( M ) < 40 : hms = str ( int ( M ) + 60 ) + \":\" + S elif H . startswith ( \"0\" ): hms = \":\" . join ([ H [ 1 ], M , S ]) return hms get_near_name ( begin , items ) \u00b6 Return the closest matching playlist name that starts with begin. Source code in mps_youtube/util.py def get_near_name ( begin , items ): \"\"\" Return the closest matching playlist name that starts with begin. \"\"\" for name in sorted ( items ): if name . lower () . startswith ( begin . lower ()): return name return begin get_pafy ( item , force = False , callback = None ) \u00b6 Get pafy object for an item. :param item: video to retrieve :type item: :class: mps_youtube.playlist.Video or str :param force: ignore cache and retrieve anyway :type force: bool :param callback: callpack to pass to pafy :type callback: func :rtype: Pafy Source code in mps_youtube/util.py def get_pafy ( item , force = False , callback = None ): \"\"\" Get pafy object for an item. :param item: video to retrieve :type item: :class:`mps_youtube.playlist.Video` or str :param force: ignore cache and retrieve anyway :type force: bool :param callback: callpack to pass to pafy :type callback: func :rtype: Pafy \"\"\" if isinstance ( item , Video ): ytid = item . ytid else : ytid = item callback_fn = callback or ( lambda x : None ) cached = g . pafs . get ( ytid ) if not force and cached and cached . expiry > time . time (): dbg ( \"get pafy cache hit for %s \" , cached . title ) cached . fresh = False return cached else : try : p = None #pafy.new(ytid, callback=callback_fn) except IOError as e : if \"pafy\" in str ( e ): dbg ( c . p + \"retrying failed pafy get: \" + ytid + c . w ) p = None #pafy.new(ytid, callback=callback) else : raise g . pafs [ ytid ] = p p . fresh = True thread = \"preload: \" if not callback else \"\" dbg ( \" %s%s got new pafy object: %s%s \" % ( c . y , thread , p . title [: 26 ], c . w )) dbg ( \" %s%s got new pafy object: %s%s \" % ( c . y , thread , p . videoid , c . w )) return p getxy () \u00b6 Get terminal size, terminal width and max-results. :rtype: :class: XYTuple Source code in mps_youtube/util.py def getxy (): \"\"\" Get terminal size, terminal width and max-results. :rtype: :class:`XYTuple` \"\"\" # Import here to avoid circular dependency from . import config if g . detectable_size : x , y = terminalsize . get_terminal_size () max_results = y - 4 if y < 54 else 50 max_results = 1 if y <= 5 else max_results else : x , max_results = config . CONSOLE_WIDTH . get , config . MAX_RESULTS . get y = max_results + 4 return XYTuple ( x , y , max_results ) has_exefile ( filename ) \u00b6 Check whether file exists in path and is executable. :param filename: name of executable :type filename: str :returns: Path to file or False if not found :rtype: str or False Source code in mps_youtube/util.py def has_exefile ( filename ): \"\"\" Check whether file exists in path and is executable. :param filename: name of executable :type filename: str :returns: Path to file or False if not found :rtype: str or False \"\"\" paths = [ os . getcwd ()] + os . environ . get ( \"PATH\" , '' ) . split ( os . pathsep ) paths = [ i for i in paths if i ] dbg ( \"searching path for %s \" , filename ) for path in paths : exepath = os . path . join ( path , filename ) if os . path . isfile ( exepath ): if os . access ( exepath , os . X_OK ): dbg ( \"found at %s \" , exepath ) return exepath return False is_known_player ( player ) \u00b6 Return true if the set player is known. Source code in mps_youtube/util.py def is_known_player ( player ): \"\"\" Return true if the set player is known. \"\"\" for allowed_player in g . playerargs_defaults : regex = r '(?:\\b %s ($|\\.[a-zA-Z0-9]+$))' % re . escape ( allowed_player ) match = re . search ( regex , player ) if mswin : match = re . search ( regex , player , re . IGNORECASE ) if match : return allowed_player return None list_update ( item , lst , remove = False ) \u00b6 Add or remove item from list, checking first to avoid exceptions. Source code in mps_youtube/util.py def list_update ( item , lst , remove = False ): \"\"\" Add or remove item from list, checking first to avoid exceptions. \"\"\" if not remove and item not in lst : lst . append ( item ) elif remove and item in lst : lst . remove ( item ) mswinfn ( filename ) \u00b6 Fix filename for Windows. Source code in mps_youtube/util.py def mswinfn ( filename ): \"\"\" Fix filename for Windows. \"\"\" if mswin : filename = utf8_replace ( filename ) if not_utf8_environment else filename allowed = re . compile ( r '[^ \\\\ /?*$ \\' \"%&:<>|]' ) filename = \"\" . join ( x if allowed . match ( x ) else \"_\" for x in filename ) return filename number_string_to_list ( text ) \u00b6 Parses comma separated lists Source code in mps_youtube/util.py def number_string_to_list ( text ): \"\"\" Parses comma separated lists \"\"\" text = [ x . strip () for x in text . split ( \",\" )] vals = [] for line in text : k = line if \"-\" in line : separated = [ int ( x . strip ()) for x in k . split ( \"-\" )] for number in list ( range ( separated [ 0 ] - 1 , separated [ 1 ])): vals . append ( number ) else : vals . append ( k ) return [ int ( x ) - 1 for x in vals ] parse_multi ( choice , end = None ) \u00b6 Handle ranges like 5-9, 9-5, 5- and -5 with optional repetitions number [n] eg. 2-4[2] is the same as 2 3 4 2 3 4 and 3[4] is 3 3 3 3 Return list of ints. Source code in mps_youtube/util.py def parse_multi ( choice , end = None ): \"\"\" Handle ranges like 5-9, 9-5, 5- and -5 with optional repetitions number [n] eg. 2-4[2] is the same as 2 3 4 2 3 4 and 3[4] is 3 3 3 3 Return list of ints. \"\"\" end = end or str ( len ( g . model )) pattern = r '(?<![-\\d\\[\\]])(\\d+-\\d+|-\\d+|\\d+-|\\d+)(?:\\[(\\d+)\\])?(?![-\\d\\[\\]])' items = re . findall ( pattern , choice ) alltracks = [] for x , nreps in items : # nreps is in the inclusive range [1,100] nreps = min ( int ( nreps ), 100 ) if nreps else 1 for _ in range ( nreps ): if x . startswith ( \"-\" ): x = \"1\" + x elif x . endswith ( \"-\" ): x = x + str ( end ) if \"-\" in x : nrange = x . split ( \"-\" ) startend = map ( int , nrange ) alltracks += _bi_range ( * startend ) else : alltracks . append ( int ( x )) return alltracks parse_video_length ( duration ) \u00b6 Converts HH:MM:SS to a single integer .i.e. total number of seconds Source code in mps_youtube/util.py def parse_video_length ( duration ): ''' Converts HH:MM:SS to a single integer .i.e. total number of seconds ''' if duration : duration_tokens = duration . split ( \":\" ) if len ( duration_tokens ) == 2 : return int ( duration_tokens [ 0 ]) * 60 + int ( duration_tokens [ 1 ]) else : return int ( duration_tokens [ 0 ]) * 3600 + int ( duration_tokens [ 1 ]) * 60 + int ( duration_tokens [ 2 ]) else : return 10 real_len ( u , alt = False ) \u00b6 Try to determine width of strings displayed with monospace font. Source code in mps_youtube/util.py def real_len ( u , alt = False ): \"\"\" Try to determine width of strings displayed with monospace font. \"\"\" if not isinstance ( u , str ): u = u . decode ( \"utf8\" ) u = xenc ( u ) # Handle replacements of unsuported characters ueaw = unicodedata . east_asian_width if alt : # widths = dict(W=2, F=2, A=1, N=0.75, H=0.5) # original widths = dict ( N = .75 , Na = 1 , W = 2 , F = 2 , A = 1 ) else : widths = dict ( W = 2 , F = 2 , A = 1 , N = 1 , H = 0.5 ) return int ( round ( sum ( widths . get ( ueaw ( char ), 1 ) for char in u ))) sanitize_filename ( filename , ignore_slashes = False ) \u00b6 Sanitize filename Source code in mps_youtube/util.py def sanitize_filename ( filename , ignore_slashes = False ): \"\"\" Sanitize filename \"\"\" if not ignore_slashes : filename = filename . replace ( '/' , '-' ) if macos : filename = filename . replace ( ':' , '_' ) if mswin : filename = utf8_replace ( filename ) if not_utf8_environment else filename allowed = re . compile ( r '[^ \\\\ ?*$ \\' \"%&:<>|]' ) filename = \"\" . join ( x if allowed . match ( x ) else \"_\" for x in filename ) return filename set_window_title ( title ) \u00b6 Set terminal window title. Source code in mps_youtube/util.py def set_window_title ( title ): \"\"\" Set terminal window title. \"\"\" if mswin : ctypes . windll . kernel32 . SetConsoleTitleW ( xenc ( title )) else : sys . stdout . write ( xenc ( ' \\x1b ]2;' + title + ' \\x07 ' )) uea_pad ( num , t , direction = '<' , notrunc = False ) \u00b6 Right pad with spaces taking into account East Asian width chars. Source code in mps_youtube/util.py def uea_pad ( num , t , direction = \"<\" , notrunc = False ): \"\"\" Right pad with spaces taking into account East Asian width chars. \"\"\" direction = direction . strip () or \"<\" t = ' ' . join ( str ( t ) . split ( ' \\n ' )) # TODO: Find better way of dealing with this? if num <= 0 : return '' if not notrunc : # Truncate to max of num characters t = correct_truncate ( t , num ) if real_len ( t ) < num : spaces = num - real_len ( t ) if direction == \"<\" : t = t + ( \" \" * spaces ) elif direction == \">\" : t = ( \" \" * spaces ) + t elif direction == \"^\" : right = False while real_len ( t ) < num : t = t + \" \" if right else \" \" + t right = not right return t utf8_replace ( txt ) \u00b6 Replace unsupported characters in unicode string. :param txt: text to filter :type txt: str :returns: Unicode text without any characters unsupported by locale :rtype: str Source code in mps_youtube/util.py def utf8_replace ( txt ): \"\"\" Replace unsupported characters in unicode string. :param txt: text to filter :type txt: str :returns: Unicode text without any characters unsupported by locale :rtype: str \"\"\" sse = sys . stdout . encoding txt = str ( txt ) txt = txt . encode ( sse , \"replace\" ) . decode ( sse ) return txt xenc ( stuff ) \u00b6 Replace unsupported characters. Source code in mps_youtube/util.py def xenc ( stuff ): \"\"\" Replace unsupported characters. \"\"\" return utf8_replace ( stuff ) if not_utf8_environment else stuff xprint ( stuff , end = None ) \u00b6 Compatible print. Source code in mps_youtube/util.py def xprint ( stuff , end = None ): \"\"\" Compatible print. \"\"\" print ( xenc ( stuff ), end = end ) yt_datetime ( yt_date_time ) \u00b6 Return a time object, locale formated date string and locale formatted time string. Source code in mps_youtube/util.py def yt_datetime ( yt_date_time ): \"\"\" Return a time object, locale formated date string and locale formatted time string. \"\"\" if yt_date_time is None : return [ 'Unknown' , 'Unknown' , 'Unknown' ] time_obj = time . strptime ( yt_date_time , \"%Y-%m- %d T%H:%M:%SZ\" ) locale_date = time . strftime ( \" %x \" , time_obj ) locale_time = time . strftime ( \" %X \" , time_obj ) # strip first two digits of four digit year short_date = re . sub ( r \"(\\d\\d\\D\\d\\d\\D)20(\\d\\d)$\" , r \"\\1\\2\" , locale_date ) return time_obj , short_date , locale_time yt_datetime_local ( yt_date_time ) \u00b6 Return a datetime object, locale converted and formated date string and locale converted and formatted time string. Source code in mps_youtube/util.py def yt_datetime_local ( yt_date_time ): \"\"\" Return a datetime object, locale converted and formated date string and locale converted and formatted time string. \"\"\" datetime_obj = datetime . strptime ( yt_date_time , \"%Y-%m- %d T%H:%M:%SZ\" ) datetime_obj = utc2local ( datetime_obj ) locale_date = datetime_obj . strftime ( \" %x \" ) locale_time = datetime_obj . strftime ( \" %X \" ) # strip first two digits of four digit year short_date = re . sub ( r \"(\\d\\d\\D\\d\\d\\D)20(\\d\\d)$\" , r \"\\1\\2\" , locale_date ) return datetime_obj , short_date , locale_time","title":"util.py"},{"location":"reference/util/#mps_youtube.util.IterSlicer","text":"Class that takes an iterable and allows slicing, loading from the iterable as needed. Source code in mps_youtube/util.py class IterSlicer (): \"\"\" Class that takes an iterable and allows slicing, loading from the iterable as needed.\"\"\" def __init__ ( self , iterable , length = None ): self . ilist = [] self . iterable = iter ( iterable ) self . length = length if length is None : try : self . length = len ( iterable ) except TypeError : pass def __getitem__ ( self , sliced ): if isinstance ( sliced , slice ): stop = sliced . stop else : stop = sliced # To get the last item in an iterable, must iterate over all items if ( stop is None ) or ( stop < 0 ): stop = None while ( stop is None ) or ( stop > len ( self . ilist ) - 1 ): try : self . ilist . append ( next ( self . iterable )) except StopIteration : break return self . ilist [ sliced ] def __len__ ( self ): if self . length is None : self . length = len ( self [:]) return self . length","title":"IterSlicer"},{"location":"reference/util/#mps_youtube.util.XYTuple","text":"XYTuple(width, height, max_results)","title":"XYTuple"},{"location":"reference/util/#mps_youtube.util.XYTuple.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in mps_youtube/util.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"reference/util/#mps_youtube.util.XYTuple.__new__","text":"Create new instance of XYTuple(width, height, max_results)","title":"__new__()"},{"location":"reference/util/#mps_youtube.util.XYTuple.__repr__","text":"Return a nicely formatted representation string Source code in mps_youtube/util.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"reference/util/#mps_youtube.util.F","text":"Format text. :param nb: newline before :type nb: int :param na: newline after :type na: int :param textlib: the dictionary to use (defaults to g.text if not given) :type textlib: dict :returns: A string, potentially containing one or more %s :rtype: str Source code in mps_youtube/util.py def F ( key , nb = 0 , na = 0 , textlib = None ): \"\"\"Format text. :param nb: newline before :type nb: int :param na: newline after :type na: int :param textlib: the dictionary to use (defaults to g.text if not given) :type textlib: dict :returns: A string, potentially containing one or more %s :rtype: str \"\"\" textlib = textlib or g . text assert key in textlib text = textlib [ key ] percent_fmt = textlib . get ( key + \"_\" ) if percent_fmt : text = re . sub ( r \"\\*\" , r \" %s \" , text ) % percent_fmt text = text . replace ( \"&&\" , \" %s \" ) return \" \\n \" * nb + text + c . w + \" \\n \" * na","title":"F()"},{"location":"reference/util/#mps_youtube.util.correct_truncate","text":"Truncate a string taking into account East Asian width chars. Source code in mps_youtube/util.py def correct_truncate ( text , max_len ): \"\"\" Truncate a string taking into account East Asian width chars.\"\"\" str_len , out = 0 , '' for c in text : str_len += real_len ( c ) if str_len <= max_len : out += c else : break return out","title":"correct_truncate()"},{"location":"reference/util/#mps_youtube.util.dbg","text":"Emit a debug message. Source code in mps_youtube/util.py def dbg ( * args ): \"\"\"Emit a debug message.\"\"\" # Uses xenc to deal with UnicodeEncodeError when writing to terminal logging . debug ( * ( xenc ( i ) for i in args ))","title":"dbg()"},{"location":"reference/util/#mps_youtube.util.fmt_time","text":"Format number of seconds to %H:%M:%S. Source code in mps_youtube/util.py def fmt_time ( seconds ): \"\"\" Format number of seconds to %H:%M:%S. \"\"\" hms = time . strftime ( '%H:%M:%S' , time . gmtime ( int ( seconds ))) H , M , S = hms . split ( \":\" ) if H == \"00\" : hms = M + \":\" + S elif H == \"01\" and int ( M ) < 40 : hms = str ( int ( M ) + 60 ) + \":\" + S elif H . startswith ( \"0\" ): hms = \":\" . join ([ H [ 1 ], M , S ]) return hms","title":"fmt_time()"},{"location":"reference/util/#mps_youtube.util.get_near_name","text":"Return the closest matching playlist name that starts with begin. Source code in mps_youtube/util.py def get_near_name ( begin , items ): \"\"\" Return the closest matching playlist name that starts with begin. \"\"\" for name in sorted ( items ): if name . lower () . startswith ( begin . lower ()): return name return begin","title":"get_near_name()"},{"location":"reference/util/#mps_youtube.util.get_pafy","text":"Get pafy object for an item. :param item: video to retrieve :type item: :class: mps_youtube.playlist.Video or str :param force: ignore cache and retrieve anyway :type force: bool :param callback: callpack to pass to pafy :type callback: func :rtype: Pafy Source code in mps_youtube/util.py def get_pafy ( item , force = False , callback = None ): \"\"\" Get pafy object for an item. :param item: video to retrieve :type item: :class:`mps_youtube.playlist.Video` or str :param force: ignore cache and retrieve anyway :type force: bool :param callback: callpack to pass to pafy :type callback: func :rtype: Pafy \"\"\" if isinstance ( item , Video ): ytid = item . ytid else : ytid = item callback_fn = callback or ( lambda x : None ) cached = g . pafs . get ( ytid ) if not force and cached and cached . expiry > time . time (): dbg ( \"get pafy cache hit for %s \" , cached . title ) cached . fresh = False return cached else : try : p = None #pafy.new(ytid, callback=callback_fn) except IOError as e : if \"pafy\" in str ( e ): dbg ( c . p + \"retrying failed pafy get: \" + ytid + c . w ) p = None #pafy.new(ytid, callback=callback) else : raise g . pafs [ ytid ] = p p . fresh = True thread = \"preload: \" if not callback else \"\" dbg ( \" %s%s got new pafy object: %s%s \" % ( c . y , thread , p . title [: 26 ], c . w )) dbg ( \" %s%s got new pafy object: %s%s \" % ( c . y , thread , p . videoid , c . w )) return p","title":"get_pafy()"},{"location":"reference/util/#mps_youtube.util.getxy","text":"Get terminal size, terminal width and max-results. :rtype: :class: XYTuple Source code in mps_youtube/util.py def getxy (): \"\"\" Get terminal size, terminal width and max-results. :rtype: :class:`XYTuple` \"\"\" # Import here to avoid circular dependency from . import config if g . detectable_size : x , y = terminalsize . get_terminal_size () max_results = y - 4 if y < 54 else 50 max_results = 1 if y <= 5 else max_results else : x , max_results = config . CONSOLE_WIDTH . get , config . MAX_RESULTS . get y = max_results + 4 return XYTuple ( x , y , max_results )","title":"getxy()"},{"location":"reference/util/#mps_youtube.util.has_exefile","text":"Check whether file exists in path and is executable. :param filename: name of executable :type filename: str :returns: Path to file or False if not found :rtype: str or False Source code in mps_youtube/util.py def has_exefile ( filename ): \"\"\" Check whether file exists in path and is executable. :param filename: name of executable :type filename: str :returns: Path to file or False if not found :rtype: str or False \"\"\" paths = [ os . getcwd ()] + os . environ . get ( \"PATH\" , '' ) . split ( os . pathsep ) paths = [ i for i in paths if i ] dbg ( \"searching path for %s \" , filename ) for path in paths : exepath = os . path . join ( path , filename ) if os . path . isfile ( exepath ): if os . access ( exepath , os . X_OK ): dbg ( \"found at %s \" , exepath ) return exepath return False","title":"has_exefile()"},{"location":"reference/util/#mps_youtube.util.is_known_player","text":"Return true if the set player is known. Source code in mps_youtube/util.py def is_known_player ( player ): \"\"\" Return true if the set player is known. \"\"\" for allowed_player in g . playerargs_defaults : regex = r '(?:\\b %s ($|\\.[a-zA-Z0-9]+$))' % re . escape ( allowed_player ) match = re . search ( regex , player ) if mswin : match = re . search ( regex , player , re . IGNORECASE ) if match : return allowed_player return None","title":"is_known_player()"},{"location":"reference/util/#mps_youtube.util.list_update","text":"Add or remove item from list, checking first to avoid exceptions. Source code in mps_youtube/util.py def list_update ( item , lst , remove = False ): \"\"\" Add or remove item from list, checking first to avoid exceptions. \"\"\" if not remove and item not in lst : lst . append ( item ) elif remove and item in lst : lst . remove ( item )","title":"list_update()"},{"location":"reference/util/#mps_youtube.util.mswinfn","text":"Fix filename for Windows. Source code in mps_youtube/util.py def mswinfn ( filename ): \"\"\" Fix filename for Windows. \"\"\" if mswin : filename = utf8_replace ( filename ) if not_utf8_environment else filename allowed = re . compile ( r '[^ \\\\ /?*$ \\' \"%&:<>|]' ) filename = \"\" . join ( x if allowed . match ( x ) else \"_\" for x in filename ) return filename","title":"mswinfn()"},{"location":"reference/util/#mps_youtube.util.number_string_to_list","text":"Parses comma separated lists Source code in mps_youtube/util.py def number_string_to_list ( text ): \"\"\" Parses comma separated lists \"\"\" text = [ x . strip () for x in text . split ( \",\" )] vals = [] for line in text : k = line if \"-\" in line : separated = [ int ( x . strip ()) for x in k . split ( \"-\" )] for number in list ( range ( separated [ 0 ] - 1 , separated [ 1 ])): vals . append ( number ) else : vals . append ( k ) return [ int ( x ) - 1 for x in vals ]","title":"number_string_to_list()"},{"location":"reference/util/#mps_youtube.util.parse_multi","text":"Handle ranges like 5-9, 9-5, 5- and -5 with optional repetitions number [n] eg. 2-4[2] is the same as 2 3 4 2 3 4 and 3[4] is 3 3 3 3 Return list of ints. Source code in mps_youtube/util.py def parse_multi ( choice , end = None ): \"\"\" Handle ranges like 5-9, 9-5, 5- and -5 with optional repetitions number [n] eg. 2-4[2] is the same as 2 3 4 2 3 4 and 3[4] is 3 3 3 3 Return list of ints. \"\"\" end = end or str ( len ( g . model )) pattern = r '(?<![-\\d\\[\\]])(\\d+-\\d+|-\\d+|\\d+-|\\d+)(?:\\[(\\d+)\\])?(?![-\\d\\[\\]])' items = re . findall ( pattern , choice ) alltracks = [] for x , nreps in items : # nreps is in the inclusive range [1,100] nreps = min ( int ( nreps ), 100 ) if nreps else 1 for _ in range ( nreps ): if x . startswith ( \"-\" ): x = \"1\" + x elif x . endswith ( \"-\" ): x = x + str ( end ) if \"-\" in x : nrange = x . split ( \"-\" ) startend = map ( int , nrange ) alltracks += _bi_range ( * startend ) else : alltracks . append ( int ( x )) return alltracks","title":"parse_multi()"},{"location":"reference/util/#mps_youtube.util.parse_video_length","text":"Converts HH:MM:SS to a single integer .i.e. total number of seconds Source code in mps_youtube/util.py def parse_video_length ( duration ): ''' Converts HH:MM:SS to a single integer .i.e. total number of seconds ''' if duration : duration_tokens = duration . split ( \":\" ) if len ( duration_tokens ) == 2 : return int ( duration_tokens [ 0 ]) * 60 + int ( duration_tokens [ 1 ]) else : return int ( duration_tokens [ 0 ]) * 3600 + int ( duration_tokens [ 1 ]) * 60 + int ( duration_tokens [ 2 ]) else : return 10","title":"parse_video_length()"},{"location":"reference/util/#mps_youtube.util.real_len","text":"Try to determine width of strings displayed with monospace font. Source code in mps_youtube/util.py def real_len ( u , alt = False ): \"\"\" Try to determine width of strings displayed with monospace font. \"\"\" if not isinstance ( u , str ): u = u . decode ( \"utf8\" ) u = xenc ( u ) # Handle replacements of unsuported characters ueaw = unicodedata . east_asian_width if alt : # widths = dict(W=2, F=2, A=1, N=0.75, H=0.5) # original widths = dict ( N = .75 , Na = 1 , W = 2 , F = 2 , A = 1 ) else : widths = dict ( W = 2 , F = 2 , A = 1 , N = 1 , H = 0.5 ) return int ( round ( sum ( widths . get ( ueaw ( char ), 1 ) for char in u )))","title":"real_len()"},{"location":"reference/util/#mps_youtube.util.sanitize_filename","text":"Sanitize filename Source code in mps_youtube/util.py def sanitize_filename ( filename , ignore_slashes = False ): \"\"\" Sanitize filename \"\"\" if not ignore_slashes : filename = filename . replace ( '/' , '-' ) if macos : filename = filename . replace ( ':' , '_' ) if mswin : filename = utf8_replace ( filename ) if not_utf8_environment else filename allowed = re . compile ( r '[^ \\\\ ?*$ \\' \"%&:<>|]' ) filename = \"\" . join ( x if allowed . match ( x ) else \"_\" for x in filename ) return filename","title":"sanitize_filename()"},{"location":"reference/util/#mps_youtube.util.set_window_title","text":"Set terminal window title. Source code in mps_youtube/util.py def set_window_title ( title ): \"\"\" Set terminal window title. \"\"\" if mswin : ctypes . windll . kernel32 . SetConsoleTitleW ( xenc ( title )) else : sys . stdout . write ( xenc ( ' \\x1b ]2;' + title + ' \\x07 ' ))","title":"set_window_title()"},{"location":"reference/util/#mps_youtube.util.uea_pad","text":"Right pad with spaces taking into account East Asian width chars. Source code in mps_youtube/util.py def uea_pad ( num , t , direction = \"<\" , notrunc = False ): \"\"\" Right pad with spaces taking into account East Asian width chars. \"\"\" direction = direction . strip () or \"<\" t = ' ' . join ( str ( t ) . split ( ' \\n ' )) # TODO: Find better way of dealing with this? if num <= 0 : return '' if not notrunc : # Truncate to max of num characters t = correct_truncate ( t , num ) if real_len ( t ) < num : spaces = num - real_len ( t ) if direction == \"<\" : t = t + ( \" \" * spaces ) elif direction == \">\" : t = ( \" \" * spaces ) + t elif direction == \"^\" : right = False while real_len ( t ) < num : t = t + \" \" if right else \" \" + t right = not right return t","title":"uea_pad()"},{"location":"reference/util/#mps_youtube.util.utf8_replace","text":"Replace unsupported characters in unicode string. :param txt: text to filter :type txt: str :returns: Unicode text without any characters unsupported by locale :rtype: str Source code in mps_youtube/util.py def utf8_replace ( txt ): \"\"\" Replace unsupported characters in unicode string. :param txt: text to filter :type txt: str :returns: Unicode text without any characters unsupported by locale :rtype: str \"\"\" sse = sys . stdout . encoding txt = str ( txt ) txt = txt . encode ( sse , \"replace\" ) . decode ( sse ) return txt","title":"utf8_replace()"},{"location":"reference/util/#mps_youtube.util.xenc","text":"Replace unsupported characters. Source code in mps_youtube/util.py def xenc ( stuff ): \"\"\" Replace unsupported characters. \"\"\" return utf8_replace ( stuff ) if not_utf8_environment else stuff","title":"xenc()"},{"location":"reference/util/#mps_youtube.util.xprint","text":"Compatible print. Source code in mps_youtube/util.py def xprint ( stuff , end = None ): \"\"\" Compatible print. \"\"\" print ( xenc ( stuff ), end = end )","title":"xprint()"},{"location":"reference/util/#mps_youtube.util.yt_datetime","text":"Return a time object, locale formated date string and locale formatted time string. Source code in mps_youtube/util.py def yt_datetime ( yt_date_time ): \"\"\" Return a time object, locale formated date string and locale formatted time string. \"\"\" if yt_date_time is None : return [ 'Unknown' , 'Unknown' , 'Unknown' ] time_obj = time . strptime ( yt_date_time , \"%Y-%m- %d T%H:%M:%SZ\" ) locale_date = time . strftime ( \" %x \" , time_obj ) locale_time = time . strftime ( \" %X \" , time_obj ) # strip first two digits of four digit year short_date = re . sub ( r \"(\\d\\d\\D\\d\\d\\D)20(\\d\\d)$\" , r \"\\1\\2\" , locale_date ) return time_obj , short_date , locale_time","title":"yt_datetime()"},{"location":"reference/util/#mps_youtube.util.yt_datetime_local","text":"Return a datetime object, locale converted and formated date string and locale converted and formatted time string. Source code in mps_youtube/util.py def yt_datetime_local ( yt_date_time ): \"\"\" Return a datetime object, locale converted and formated date string and locale converted and formatted time string. \"\"\" datetime_obj = datetime . strptime ( yt_date_time , \"%Y-%m- %d T%H:%M:%SZ\" ) datetime_obj = utc2local ( datetime_obj ) locale_date = datetime_obj . strftime ( \" %x \" ) locale_time = datetime_obj . strftime ( \" %X \" ) # strip first two digits of four digit year short_date = re . sub ( r \"(\\d\\d\\D\\d\\d\\D)20(\\d\\d)$\" , r \"\\1\\2\" , locale_date ) return datetime_obj , short_date , locale_time","title":"yt_datetime_local()"},{"location":"reference/commands/__init__/","text":"Command ( tuple ) \u00b6 Command(regex, category, usage, function) __getnewargs__ ( self ) special \u00b6 Return self as a plain tuple. Used by copy and pickle. Source code in mps_youtube/commands/__init__.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , regex , category , usage , function ) special staticmethod \u00b6 Create new instance of Command(regex, category, usage, function) __repr__ ( self ) special \u00b6 Return a nicely formatted representation string Source code in mps_youtube/commands/__init__.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self command ( regex , * commands ) \u00b6 Decorator to register an mps-youtube command. Source code in mps_youtube/commands/__init__.py def command ( regex , * commands ): \"\"\" Decorator to register an mps-youtube command. \"\"\" for command in commands : completer . add_cmd ( command ) def decorator ( function ): cmd = Command ( re . compile ( regex ), None , None , function ) g . commands . append ( cmd ) return function return decorator","title":"__init__.py"},{"location":"reference/commands/__init__/#mps_youtube.commands.__init__.Command","text":"Command(regex, category, usage, function)","title":"Command"},{"location":"reference/commands/__init__/#mps_youtube.commands.__init__.Command.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in mps_youtube/commands/__init__.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"reference/commands/__init__/#mps_youtube.commands.__init__.Command.__new__","text":"Create new instance of Command(regex, category, usage, function)","title":"__new__()"},{"location":"reference/commands/__init__/#mps_youtube.commands.__init__.Command.__repr__","text":"Return a nicely formatted representation string Source code in mps_youtube/commands/__init__.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"reference/commands/__init__/#mps_youtube.commands.__init__.command","text":"Decorator to register an mps-youtube command. Source code in mps_youtube/commands/__init__.py def command ( regex , * commands ): \"\"\" Decorator to register an mps-youtube command. \"\"\" for command in commands : completer . add_cmd ( command ) def decorator ( function ): cmd = Command ( re . compile ( regex ), None , None , function ) g . commands . append ( cmd ) return function return decorator","title":"command()"},{"location":"reference/commands/album_search/","text":"search_album ( term ) \u00b6 Search for albums. Source code in mps_youtube/commands/album_search.py @command ( r 'album\\s*(.{0,500})' , 'album' ) def search_album ( term ): \"\"\"Search for albums. \"\"\" # pylint: disable=R0914,R0912 if not term : show_message ( \"Enter album name:\" , c . g , update = True ) term = input ( \"> \" ) if not term or len ( term ) < 2 : g . message = c . r + \"Not enough input!\" + c . w g . content = content_py . generate_songlist_display () return album = _get_mb_album ( term ) if not album : show_message ( \"Album ' %s ' not found!\" % term ) return prompt = \"Artist? [ %s ] > \" % album [ 'artist' ] util . xprint ( prompt , end = \"\" ) artistentry = input () . strip () if artistentry : if artistentry == \"q\" : show_message ( \"Album search abandoned!\" ) return album = _get_mb_album ( term , artist = artistentry ) if not album : show_message ( \"Album ' %s ' by ' %s ' not found!\" % ( term , artistentry )) return title , artist = album [ 'title' ], album [ 'artist' ] mb_tracks = _get_mb_tracks ( album [ 'aid' ]) if not mb_tracks : show_message ( \"Album ' %s ' by ' %s ' has 0 tracks!\" % ( title , artist )) return msg = \" %s%s%s by %s%s%s \\n\\n \" % ( c . g , title , c . w , c . g , artist , c . w ) msg += \"Enter to begin matching or [q] to abort\" g . message = msg g . content = \"Tracks: \\n \" for n , track in enumerate ( mb_tracks , 1 ): g . content += \" %02s %s \" % ( n , track [ 'title' ]) g . content += \" \\n \" screen . update () entry = input ( \"Continue? [Enter] > \" ) if entry == \"\" : pass else : show_message ( \"Album search abandoned!\" ) return songs = [] screen . clear () itt = _match_tracks ( artist , title , mb_tracks ) stash = config . SEARCH_MUSIC . get , config . ORDER . get config . SEARCH_MUSIC . value = True config . ORDER . value = \"relevance\" try : songs . extend ( itt ) except KeyboardInterrupt : util . xprint ( \" %s Halted! %s \" % ( c . r , c . w )) finally : config . SEARCH_MUSIC . value , config . ORDER . value = stash if songs : util . xprint ( \" \\n %s / %s songs matched\" % ( len ( songs ), len ( mb_tracks ))) input ( \"Press Enter to continue\" ) if g . lastfm_network : g . artist = artist g . album = title g . scrobble = True # Fill up queue with all the track names g . scrobble_queue = [ t [ 'title' ] for t in mb_tracks ] msg = \"Contents of album %s%s - %s%s %s ( %d / %d ) %s :\" % ( c . y , artist , title , c . w , c . b , len ( songs ), len ( mb_tracks ), c . w ) failmsg = \"Found no album tracks for %s%s%s \" % ( c . y , title , c . w ) paginatesongs ( songs , msg = msg , failmsg = failmsg ) show_message ( message , col = '' , update = False ) \u00b6 Show message using col, update screen if required. Source code in mps_youtube/commands/album_search.py def show_message ( message , col = c . r , update = False ): \"\"\" Show message using col, update screen if required. \"\"\" g . content = content_py . generate_songlist_display () g . message = col + message + c . w if update : screen . update ()","title":"album_search.py"},{"location":"reference/commands/album_search/#mps_youtube.commands.album_search.search_album","text":"Search for albums. Source code in mps_youtube/commands/album_search.py @command ( r 'album\\s*(.{0,500})' , 'album' ) def search_album ( term ): \"\"\"Search for albums. \"\"\" # pylint: disable=R0914,R0912 if not term : show_message ( \"Enter album name:\" , c . g , update = True ) term = input ( \"> \" ) if not term or len ( term ) < 2 : g . message = c . r + \"Not enough input!\" + c . w g . content = content_py . generate_songlist_display () return album = _get_mb_album ( term ) if not album : show_message ( \"Album ' %s ' not found!\" % term ) return prompt = \"Artist? [ %s ] > \" % album [ 'artist' ] util . xprint ( prompt , end = \"\" ) artistentry = input () . strip () if artistentry : if artistentry == \"q\" : show_message ( \"Album search abandoned!\" ) return album = _get_mb_album ( term , artist = artistentry ) if not album : show_message ( \"Album ' %s ' by ' %s ' not found!\" % ( term , artistentry )) return title , artist = album [ 'title' ], album [ 'artist' ] mb_tracks = _get_mb_tracks ( album [ 'aid' ]) if not mb_tracks : show_message ( \"Album ' %s ' by ' %s ' has 0 tracks!\" % ( title , artist )) return msg = \" %s%s%s by %s%s%s \\n\\n \" % ( c . g , title , c . w , c . g , artist , c . w ) msg += \"Enter to begin matching or [q] to abort\" g . message = msg g . content = \"Tracks: \\n \" for n , track in enumerate ( mb_tracks , 1 ): g . content += \" %02s %s \" % ( n , track [ 'title' ]) g . content += \" \\n \" screen . update () entry = input ( \"Continue? [Enter] > \" ) if entry == \"\" : pass else : show_message ( \"Album search abandoned!\" ) return songs = [] screen . clear () itt = _match_tracks ( artist , title , mb_tracks ) stash = config . SEARCH_MUSIC . get , config . ORDER . get config . SEARCH_MUSIC . value = True config . ORDER . value = \"relevance\" try : songs . extend ( itt ) except KeyboardInterrupt : util . xprint ( \" %s Halted! %s \" % ( c . r , c . w )) finally : config . SEARCH_MUSIC . value , config . ORDER . value = stash if songs : util . xprint ( \" \\n %s / %s songs matched\" % ( len ( songs ), len ( mb_tracks ))) input ( \"Press Enter to continue\" ) if g . lastfm_network : g . artist = artist g . album = title g . scrobble = True # Fill up queue with all the track names g . scrobble_queue = [ t [ 'title' ] for t in mb_tracks ] msg = \"Contents of album %s%s - %s%s %s ( %d / %d ) %s :\" % ( c . y , artist , title , c . w , c . b , len ( songs ), len ( mb_tracks ), c . w ) failmsg = \"Found no album tracks for %s%s%s \" % ( c . y , title , c . w ) paginatesongs ( songs , msg = msg , failmsg = failmsg )","title":"search_album()"},{"location":"reference/commands/album_search/#mps_youtube.commands.album_search.show_message","text":"Show message using col, update screen if required. Source code in mps_youtube/commands/album_search.py def show_message ( message , col = c . r , update = False ): \"\"\" Show message using col, update screen if required. \"\"\" g . content = content_py . generate_songlist_display () g . message = col + message + c . w if update : screen . update ()","title":"show_message()"},{"location":"reference/commands/config/","text":"setconfig ( key , val , is_temp = False ) \u00b6 Set configuration variable. Source code in mps_youtube/commands/config.py @command ( r 'set\\s+([-\\w]+)\\s*(.*)' ) def setconfig ( key , val , is_temp = False ): \"\"\" Set configuration variable. \"\"\" key = key . replace ( \"-\" , \"_\" ) if key . upper () == \"ALL\" and val . upper () == \"DEFAULT\" : for ci in config : config [ ci ] . value = config [ ci ] . default config . save () message = \"Default configuration reinstated\" elif not key . upper () in config : message = \"Unknown config item: %s%s%s \" % ( c . r , key , c . w ) elif val . upper () == \"DEFAULT\" : att = config [ key . upper ()] att . value = att . default att . temp_value = None message = \" %s%s%s set to %s%s%s (default)\" dispval = att . display or \"None\" message = message % ( c . y , key , c . w , c . y , dispval , c . w ) config . save () else : # config.save() will be called by config.set() method message = config [ key . upper ()] . set ( val , is_temp = is_temp ) showconfig () g . message = message show_encs () \u00b6 Display available encoding presets. Source code in mps_youtube/commands/config.py @command ( r 'encoders?' , 'encoder' ) def show_encs (): \"\"\" Display available encoding presets. \"\"\" out = \" %s Encoding profiles: %s \\n\\n \" % ( c . ul , c . w ) for x , e in enumerate ( g . encoders ): sel = \" ( %s selected %s )\" % ( c . y , c . w ) if config . ENCODER . get == x else \"\" out += \" %2d . %s%s \\n \" % ( x , e [ 'name' ], sel ) g . content = out message = \"Enter %s set encoder <num> %s to select an encoder\" g . message = message % ( c . g , c . w ) showconfig () \u00b6 Dump config data. Source code in mps_youtube/commands/config.py @command ( r 'set|showconfig' , 'set' , 'showconfig' ) def showconfig (): \"\"\" Dump config data. \"\"\" width = util . getxy () . width longest_key = 17 longest_val = 0 has_temps = False for setting in config : val = config [ setting ] longest_val = max ( longest_val , len ( str ( val . display ))) has_temps = has_temps or val . temp_value is not None width -= 27 s = \" %s %- {0} s %s : %- {1} s\" . format ( longest_key , longest_val + 1 ) if has_temps : width -= longest_val + 5 out = \" %s %- {} s %- {} s %s%s%s \\n \" . format ( longest_key , longest_val ) % ( c . ul , \"Key\" , \"Value\" , \"Temporary\" , \" \" * width , c . w ) else : out = \" %s %- {} s %s%s%s \\n \" . format ( longest_key ) % ( c . ul , \"Key\" , \"Value\" , \" \" * width , c . w ) for setting in config : val = config [ setting ] # don't show player specific settings if unknown player if not util . is_known_player ( config . PLAYER . get ) and \\ val . require_known_player : continue # don't show max_results if auto determined if g . detectable_size and setting == \"MAX_RESULTS\" : continue if g . detectable_size and setting == \"CONSOLE_WIDTH\" : continue out += s % ( c . g , setting . lower (), c . w , val . display ) if has_temps : out += \" %s%s \" % ( c . w , val . display_temp ) out += \" \\n \" g . content = out g . message = \"Enter %s set <key> <value> %s to change \\n \" % ( c . g , c . w ) g . message += \"Enter %s set all default %s to reset all\" % ( c . g , c . w )","title":"config.py"},{"location":"reference/commands/config/#mps_youtube.commands.config.setconfig","text":"Set configuration variable. Source code in mps_youtube/commands/config.py @command ( r 'set\\s+([-\\w]+)\\s*(.*)' ) def setconfig ( key , val , is_temp = False ): \"\"\" Set configuration variable. \"\"\" key = key . replace ( \"-\" , \"_\" ) if key . upper () == \"ALL\" and val . upper () == \"DEFAULT\" : for ci in config : config [ ci ] . value = config [ ci ] . default config . save () message = \"Default configuration reinstated\" elif not key . upper () in config : message = \"Unknown config item: %s%s%s \" % ( c . r , key , c . w ) elif val . upper () == \"DEFAULT\" : att = config [ key . upper ()] att . value = att . default att . temp_value = None message = \" %s%s%s set to %s%s%s (default)\" dispval = att . display or \"None\" message = message % ( c . y , key , c . w , c . y , dispval , c . w ) config . save () else : # config.save() will be called by config.set() method message = config [ key . upper ()] . set ( val , is_temp = is_temp ) showconfig () g . message = message","title":"setconfig()"},{"location":"reference/commands/config/#mps_youtube.commands.config.show_encs","text":"Display available encoding presets. Source code in mps_youtube/commands/config.py @command ( r 'encoders?' , 'encoder' ) def show_encs (): \"\"\" Display available encoding presets. \"\"\" out = \" %s Encoding profiles: %s \\n\\n \" % ( c . ul , c . w ) for x , e in enumerate ( g . encoders ): sel = \" ( %s selected %s )\" % ( c . y , c . w ) if config . ENCODER . get == x else \"\" out += \" %2d . %s%s \\n \" % ( x , e [ 'name' ], sel ) g . content = out message = \"Enter %s set encoder <num> %s to select an encoder\" g . message = message % ( c . g , c . w )","title":"show_encs()"},{"location":"reference/commands/config/#mps_youtube.commands.config.showconfig","text":"Dump config data. Source code in mps_youtube/commands/config.py @command ( r 'set|showconfig' , 'set' , 'showconfig' ) def showconfig (): \"\"\" Dump config data. \"\"\" width = util . getxy () . width longest_key = 17 longest_val = 0 has_temps = False for setting in config : val = config [ setting ] longest_val = max ( longest_val , len ( str ( val . display ))) has_temps = has_temps or val . temp_value is not None width -= 27 s = \" %s %- {0} s %s : %- {1} s\" . format ( longest_key , longest_val + 1 ) if has_temps : width -= longest_val + 5 out = \" %s %- {} s %- {} s %s%s%s \\n \" . format ( longest_key , longest_val ) % ( c . ul , \"Key\" , \"Value\" , \"Temporary\" , \" \" * width , c . w ) else : out = \" %s %- {} s %s%s%s \\n \" . format ( longest_key ) % ( c . ul , \"Key\" , \"Value\" , \" \" * width , c . w ) for setting in config : val = config [ setting ] # don't show player specific settings if unknown player if not util . is_known_player ( config . PLAYER . get ) and \\ val . require_known_player : continue # don't show max_results if auto determined if g . detectable_size and setting == \"MAX_RESULTS\" : continue if g . detectable_size and setting == \"CONSOLE_WIDTH\" : continue out += s % ( c . g , setting . lower (), c . w , val . display ) if has_temps : out += \" %s%s \" % ( c . w , val . display_temp ) out += \" \\n \" g . content = out g . message = \"Enter %s set <key> <value> %s to change \\n \" % ( c . g , c . w ) g . message += \"Enter %s set all default %s to reset all\" % ( c . g , c . w )","title":"showconfig()"},{"location":"reference/commands/download/","text":"da_url ( url ) \u00b6 Open and prompt for download of youtube best audio from url. Source code in mps_youtube/commands/download.py @command ( r 'daurl\\s(.*[-_a-zA-Z0-9] {11} .*)' , 'daurl' ) def da_url ( url ): \"\"\" Open and prompt for download of youtube best audio from url. \"\"\" g . browse_mode = \"normal\" yt_url ( url ) if len ( g . model ) == 1 : download ( \"da\" , \"1\" ) if g . command_line : sys . exit () dl_url ( url ) \u00b6 Open and prompt for download of youtube video url. Source code in mps_youtube/commands/download.py @command ( r 'dlurl\\s(.*[-_a-zA-Z0-9] {11} .*)' , 'dlurl' ) def dl_url ( url ): \"\"\" Open and prompt for download of youtube video url. \"\"\" g . browse_mode = \"normal\" yt_url ( url ) if len ( g . model ) == 1 : download ( \"download\" , \"1\" ) if g . command_line : sys . exit () down_many ( dltype , choice , subdir = None ) \u00b6 Download multiple items. Source code in mps_youtube/commands/download.py @command ( r '(da|dv)\\s+((?:\\d+\\s\\d+|-\\d+|\\d+-|\\d+,)(?:[\\d\\s,-]*))' , 'da' , 'dv' ) def down_many ( dltype , choice , subdir = None ): \"\"\" Download multiple items. \"\"\" choice = util . parse_multi ( choice ) choice = list ( set ( choice )) downsongs = [ g . model [ int ( x ) - 1 ] for x in choice ] temp = g . model [::] g . model . songs = downsongs [::] count = len ( downsongs ) av = \"audio\" if dltype . startswith ( \"da\" ) else \"video\" msg = \"\" def handle_error ( message ): \"\"\" Handle error in download. \"\"\" g . message = message g . content = disp screen . update () time . sleep ( 2 ) g . model . songs . pop ( 0 ) try : for song in downsongs : g . result_count = len ( g . model ) disp = content . generate_songlist_display () title = \"Download Queue ( %s ): %s \\n\\n \" % ( av , c . w ) disp = re . sub ( r \"(Num\\s*?Title.*?\\n)\" , title , disp ) g . content = disp screen . update () try : filename = _make_fname ( song , None , av = av , subdir = subdir ) except IOError as e : handle_error ( \"Error for %s : %s \" % ( song . title , str ( e ))) count -= 1 continue except KeyError : handle_error ( \"No audio track for %s \" % song . title ) count -= 1 continue try : _download ( song , filename , url = None , audio = av == \"audio\" ) except HTTPError : handle_error ( \"HTTP Error for %s \" % song . title ) count -= 1 continue g . model . songs . pop ( 0 ) msg = \"Downloaded %s items\" % count g . message = \"Saved to \" + c . g + song . title + c . w except KeyboardInterrupt : msg = \"Downloads interrupted!\" finally : g . model . songs = temp [::] g . message = msg g . result_count = len ( g . model ) g . content = content . generate_songlist_display () down_plist ( dltype , parturl ) \u00b6 Download YouTube playlist. Source code in mps_youtube/commands/download.py @command ( r '(da|dv)pl\\s+ %s ' % PL , 'dapl' , 'dvpl' ) def down_plist ( dltype , parturl ): \"\"\" Download YouTube playlist. \"\"\" plist ( parturl ) dump ( False ) title = g . pafy_pls [ parturl ][ 0 ] . title # Remove double quotes for convenience subdir = util . sanitize_filename ( title . replace ( '\"' , '' )) down_many ( dltype , \"1-\" , subdir = subdir ) msg = g . message plist ( parturl ) g . message = msg down_user_pls ( dltype , user ) \u00b6 Download all user playlists. Source code in mps_youtube/commands/download.py @command ( r '(da|dv)upl\\s+(.*)' , 'daupl' , 'dvupl' ) def down_user_pls ( dltype , user ): \"\"\" Download all user playlists. \"\"\" user_pls ( user ) for i in g . ytpls : down_plist ( dltype , i . get ( 'link' )) return download ( dltype , num ) \u00b6 Download a track or playlist by menu item number. Source code in mps_youtube/commands/download.py @command ( r '(dv|da|d|dl|download)\\s*(\\d{1,4})' , 'da' , 'dv' , 'd' , 'dl' , 'download' ) def download ( dltype , num ): \"\"\" Download a track or playlist by menu item number. \"\"\" # This function needs refactoring! # pylint: disable=R0912 # pylint: disable=R0914 if g . browse_mode == \"ytpl\" and dltype in ( \"da\" , \"dv\" ): plid = g . ytpls [ int ( num ) - 1 ][ \"link\" ] down_plist ( dltype , plid ) return elif g . browse_mode == \"ytpl\" : g . message = \"Use da or dv to specify audio / video playlist download\" g . message = c . y + g . message + c . w g . content = content . generate_songlist_display () return elif g . browse_mode != \"normal\" : g . message = \"Download must refer to a specific video item\" g . message = c . y + g . message + c . w g . content = content . generate_songlist_display () return screen . writestatus ( \"Fetching video info...\" ) song = ( g . model [ int ( num ) - 1 ]) # best = dltype.startswith(\"dv\") or dltype.startswith(\"da\") # # if not best: # # try: # # user prompt for download stream # url, ext, url_au, ext_au = prompt_dl(song) # # except KeyboardInterrupt: # g.message = c.r + \"Download aborted!\" + c.w # g.content = content.generate_songlist_display() # return # # if not url or ext_au == \"abort\": # # abort on invalid stream selection # g.content = content.generate_songlist_display() # g.message = \"%sNo download selected / invalid input%s\" % (c.y, c.w) # return # # else: # # download user selected stream(s) # filename = _make_fname(song, ext) # args = (song, filename, url) # # if url_au and ext_au: # # downloading video and audio stream for muxing # audio = False # filename_au = _make_fname(song, ext_au) # args_au = (song, filename_au, url_au) # # else: # audio = ext in (\"m4a\", \"ogg\") # # kwargs = dict(audio=audio) # # elif best: # # set updownload without prompt # url_au = None # av = \"audio\" if dltype.startswith(\"da\") else \"video\" # audio = av == \"audio\" # filename = _make_fname(song, None, av=av) # args = (song, filename) # kwargs = dict(url=None, audio=audio) try : # perform download(s) # dl_filenames = [args[1]] # f = _download(*args, **kwargs) success = pafy . download_video ( song . ytid , config . DDIR . get ) if success : g . message = \"Saved \\' \" + song . title + \" \\' to \" + c . g + config . DDIR . get + c . w # if url_au: # dl_filenames += [args_au[1]] # _download(*args_au, allow_transcode=False, **kwargs) except KeyboardInterrupt : g . message = c . r + \"Download halted!\" + c . w # try: # for downloaded in dl_filenames: # os.remove(downloaded) # # except IOError: # pass # if url_au: # # multiplex # name, ext = os.path.splitext(args[1]) # tmpvideoname = name + '.' +str(random.randint(10000, 99999)) + ext # os.rename(args[1], tmpvideoname) # mux_cmd = [g.muxapp, \"-i\", tmpvideoname, \"-i\", args_au[1], \"-c\", # \"copy\", name + \".mp4\"] # # try: # subprocess.call(mux_cmd) # g.message = \"Saved to :\" + c.g + mux_cmd[7] + c.w # os.remove(tmpvideoname) # os.remove(args_au[1]) # # except KeyboardInterrupt: # g.message = \"Audio/Video multiplex aborted!\" g . content = content . generate_songlist_display () external_download ( song , filename , url ) \u00b6 Perform download using external application. Source code in mps_youtube/commands/download.py def external_download ( song , filename , url ): \"\"\" Perform download using external application. \"\"\" cmd = config . DOWNLOAD_COMMAND . get ddir , basename = config . DDIR . get , os . path . basename ( filename ) cmd_list = shlex . split ( cmd ) def list_string_sub ( orig , repl , lst ): \"\"\" Replace substrings for items in a list. \"\"\" return [ x if orig not in x else x . replace ( orig , repl ) for x in lst ] cmd_list = list_string_sub ( \" %F \" , filename , cmd_list ) cmd_list = list_string_sub ( \" %d \" , ddir , cmd_list ) cmd_list = list_string_sub ( \" %f \" , basename , cmd_list ) cmd_list = list_string_sub ( \" %u \" , url , cmd_list ) cmd_list = list_string_sub ( \" %i \" , song . ytid , cmd_list ) util . dbg ( \"Downloading using: %s \" , \" \" . join ( cmd_list )) subprocess . call ( cmd_list ) extract_metadata ( name ) \u00b6 Try to determine metadata from video title. Source code in mps_youtube/commands/download.py def extract_metadata ( name ): \"\"\" Try to determine metadata from video title. \"\"\" seps = name . count ( \" - \" ) artist = title = None if seps == 1 : pos = name . find ( \" - \" ) artist = name [: pos ] . strip () title = name [ pos + 3 :] . strip () else : title = name . strip () return dict ( artist = artist , title = title ) gen_dl_text ( ddata , song , p ) \u00b6 Generate text for dl screen. Source code in mps_youtube/commands/download.py def gen_dl_text ( ddata , song , p ): \"\"\" Generate text for dl screen. \"\"\" hdr = [] hdr . append ( \" %s%s%s \" % ( c . r , song . title , c . w )) author = p . author hdr . append ( c . r + \" Uploaded by \" + author + c . w ) hdr . append ( \" [\" + util . fmt_time ( song . length ) + \"]\" ) hdr . append ( \"\" ) heading = tuple ( \"Item Format Quality Media Size Notes\" . split ()) fmt = \" {0}%-6s %-8s %-13s %-7s %-5s %-16s{1} \" heading = [ fmt . format ( c . w , c . w ) % heading ] heading . append ( \"\" ) content = [] for n , d in enumerate ( ddata ): row = ( n + 1 , d [ 'ext' ], d [ 'quality' ], d [ 'mediatype' ], d [ 'size' ], d [ 'notes' ]) fmt = \" {0}%-6s %-8s %-13s %-7s %5s Mb %-16s{1} \" row = fmt . format ( c . g , c . w ) % row content . append ( row ) content . append ( \"\" ) footer = \"Select [ %s 1- %s%s ] to download or [ %s Enter %s ] to return\" footer = [ footer % ( c . y , len ( content ) - 1 , c . w , c . y , c . w )] return ( content , hdr , heading , footer ) get_dl_data ( song , mediatype = 'any' ) \u00b6 Get filesize and metadata for all streams, return dict. Source code in mps_youtube/commands/download.py def get_dl_data ( song , mediatype = \"any\" ): \"\"\" Get filesize and metadata for all streams, return dict. \"\"\" def mbsize ( x ): \"\"\" Return size in MB. \"\"\" return str ( int ( x / ( 1024 ** 2 ))) p = util . get_pafy ( song ) dldata = [] text = \" [Fetching stream info] >\" streamlist = [ x for x in p . allstreams ] if mediatype == \"audio\" : streamlist = [ x for x in p . audiostreams ] l = len ( streamlist ) for n , stream in enumerate ( streamlist ): sys . stdout . write ( text + \"-\" * n + \">\" + \" \" * ( l - n - 1 ) + \"< \\r \" ) sys . stdout . flush () try : size = mbsize ( stream . get_filesize ()) except TypeError : util . dbg ( c . r + \"---Error getting stream size\" + c . w ) size = 0 item = { 'mediatype' : stream . mediatype , 'size' : size , 'ext' : stream . extension , 'quality' : stream . quality , 'notes' : stream . notes , 'url' : stream . url } dldata . append ( item ) screen . writestatus ( \"\" ) return dldata , p menu_prompt ( model , prompt = ' > ' , rows = None , header = None , theading = None , footer = None , force = 0 ) \u00b6 Generate a list of choice, returns item from model. Source code in mps_youtube/commands/download.py def menu_prompt ( model , prompt = \" > \" , rows = None , header = None , theading = None , footer = None , force = 0 ): \"\"\" Generate a list of choice, returns item from model. \"\"\" content = \"\" for x in header , theading , rows , footer : if isinstance ( x , list ): for line in x : content += line + \" \\n \" elif isinstance ( x , str ): content += x + \" \\n \" g . content = content screen . update () choice = input ( prompt ) if choice in model : return model [ choice ] elif force : return menu_prompt ( model , prompt , rows , header , theading , footer , force ) elif not choice . strip (): return False , False else : # unrecognised input return False , \"abort\" prompt_dl ( song ) \u00b6 Prompt user do choose a stream to dl. Return (url, extension). Source code in mps_youtube/commands/download.py def prompt_dl ( song ): \"\"\" Prompt user do choose a stream to dl. Return (url, extension). \"\"\" # pylint: disable=R0914 dl_data , p = get_dl_data ( song ) dl_text = gen_dl_text ( dl_data , song , p ) model = [ x [ 'url' ] for x in dl_data ] ed = enumerate ( dl_data ) model = { str ( n + 1 ): ( x [ 'url' ], x [ 'ext' ]) for n , x in ed } url , ext = menu_prompt ( model , \"Download number: \" , * dl_text ) url2 = ext2 = None mediatype = [ i for i in dl_data if i [ 'url' ] == url ][ 0 ][ 'mediatype' ] if mediatype == \"video\" and g . muxapp and not config . DOWNLOAD_COMMAND . get : # offer mux if not using external downloader dl_data , p = get_dl_data ( song , mediatype = \"audio\" ) dl_text = gen_dl_text ( dl_data , song , p ) au_choices = \"1\" if len ( dl_data ) == 1 else \"1- %s \" % len ( dl_data ) footer = [ util . F ( '-audio' ) % ext , util . F ( 'select mux' ) % au_choices ] dl_text = tuple ( dl_text [ 0 : 3 ]) + ( footer ,) aext = ( \"ogg\" , \"m4a\" ) model = [ x [ 'url' ] for x in dl_data if x [ 'ext' ] in aext ] ed = enumerate ( dl_data ) model = { str ( n + 1 ): ( x [ 'url' ], x [ 'ext' ]) for n , x in ed } prompt = \"Audio stream: \" url2 , ext2 = menu_prompt ( model , prompt , * dl_text ) return url , ext , url2 , ext2 remux_audio ( filename , title ) \u00b6 Remux audio file. Insert limited metadata tags. Source code in mps_youtube/commands/download.py def remux_audio ( filename , title ): \"\"\" Remux audio file. Insert limited metadata tags. \"\"\" util . dbg ( \"starting remux\" ) temp_file = filename + \".\" + str ( random . randint ( 10000 , 99999 )) os . rename ( filename , temp_file ) meta = extract_metadata ( title ) metadata = [ \"title= %s \" % meta [ \"title\" ]] if meta [ \"artist\" ]: metadata = [ \"title= %s \" % meta [ \"title\" ], \"-metadata\" , \"artist= %s \" % meta [ \"artist\" ]] cmd = [ g . muxapp , \"-y\" , \"-i\" , temp_file , \"-acodec\" , \"copy\" , \"-metadata\" ] cmd += metadata + [ \"-vn\" , filename ] util . dbg ( cmd ) try : with open ( os . devnull , \"w\" ) as devnull : subprocess . call ( cmd , stdout = devnull , stderr = subprocess . STDOUT ) except OSError : util . dbg ( \"Failed to remux audio using %s \" , g . muxapp ) os . rename ( temp_file , filename ) else : os . unlink ( temp_file ) util . dbg ( \"remuxed audio file using %s \" % g . muxapp ) transcode ( filename , enc_data ) \u00b6 Re encode a download. Source code in mps_youtube/commands/download.py def transcode ( filename , enc_data ): \"\"\" Re encode a download. \"\"\" base = os . path . splitext ( filename )[ 0 ] exe = g . muxapp if g . transcoder_path == \"auto\" else g . transcoder_path # ensure valid executable if not exe or not os . path . exists ( exe ) or not os . access ( exe , os . X_OK ): util . xprint ( \"Encoding failed. Couldn't find a valid encoder :( \\n \" ) time . sleep ( 2 ) return filename command = shlex . split ( enc_data [ 'command' ]) newcom , outfn = command [::], \"\" for n , d in enumerate ( command ): if d == \"ENCODER_PATH\" : newcom [ n ] = exe elif d == \"IN\" : newcom [ n ] = filename elif d == \"OUT\" : newcom [ n ] = outfn = base elif d == \"OUT.EXT\" : newcom [ n ] = outfn = base + \".\" + enc_data [ 'ext' ] returncode = subprocess . call ( newcom ) if returncode == 0 and g . delete_orig : os . unlink ( filename ) return outfn","title":"download.py"},{"location":"reference/commands/download/#mps_youtube.commands.download.da_url","text":"Open and prompt for download of youtube best audio from url. Source code in mps_youtube/commands/download.py @command ( r 'daurl\\s(.*[-_a-zA-Z0-9] {11} .*)' , 'daurl' ) def da_url ( url ): \"\"\" Open and prompt for download of youtube best audio from url. \"\"\" g . browse_mode = \"normal\" yt_url ( url ) if len ( g . model ) == 1 : download ( \"da\" , \"1\" ) if g . command_line : sys . exit ()","title":"da_url()"},{"location":"reference/commands/download/#mps_youtube.commands.download.dl_url","text":"Open and prompt for download of youtube video url. Source code in mps_youtube/commands/download.py @command ( r 'dlurl\\s(.*[-_a-zA-Z0-9] {11} .*)' , 'dlurl' ) def dl_url ( url ): \"\"\" Open and prompt for download of youtube video url. \"\"\" g . browse_mode = \"normal\" yt_url ( url ) if len ( g . model ) == 1 : download ( \"download\" , \"1\" ) if g . command_line : sys . exit ()","title":"dl_url()"},{"location":"reference/commands/download/#mps_youtube.commands.download.down_many","text":"Download multiple items. Source code in mps_youtube/commands/download.py @command ( r '(da|dv)\\s+((?:\\d+\\s\\d+|-\\d+|\\d+-|\\d+,)(?:[\\d\\s,-]*))' , 'da' , 'dv' ) def down_many ( dltype , choice , subdir = None ): \"\"\" Download multiple items. \"\"\" choice = util . parse_multi ( choice ) choice = list ( set ( choice )) downsongs = [ g . model [ int ( x ) - 1 ] for x in choice ] temp = g . model [::] g . model . songs = downsongs [::] count = len ( downsongs ) av = \"audio\" if dltype . startswith ( \"da\" ) else \"video\" msg = \"\" def handle_error ( message ): \"\"\" Handle error in download. \"\"\" g . message = message g . content = disp screen . update () time . sleep ( 2 ) g . model . songs . pop ( 0 ) try : for song in downsongs : g . result_count = len ( g . model ) disp = content . generate_songlist_display () title = \"Download Queue ( %s ): %s \\n\\n \" % ( av , c . w ) disp = re . sub ( r \"(Num\\s*?Title.*?\\n)\" , title , disp ) g . content = disp screen . update () try : filename = _make_fname ( song , None , av = av , subdir = subdir ) except IOError as e : handle_error ( \"Error for %s : %s \" % ( song . title , str ( e ))) count -= 1 continue except KeyError : handle_error ( \"No audio track for %s \" % song . title ) count -= 1 continue try : _download ( song , filename , url = None , audio = av == \"audio\" ) except HTTPError : handle_error ( \"HTTP Error for %s \" % song . title ) count -= 1 continue g . model . songs . pop ( 0 ) msg = \"Downloaded %s items\" % count g . message = \"Saved to \" + c . g + song . title + c . w except KeyboardInterrupt : msg = \"Downloads interrupted!\" finally : g . model . songs = temp [::] g . message = msg g . result_count = len ( g . model ) g . content = content . generate_songlist_display ()","title":"down_many()"},{"location":"reference/commands/download/#mps_youtube.commands.download.down_plist","text":"Download YouTube playlist. Source code in mps_youtube/commands/download.py @command ( r '(da|dv)pl\\s+ %s ' % PL , 'dapl' , 'dvpl' ) def down_plist ( dltype , parturl ): \"\"\" Download YouTube playlist. \"\"\" plist ( parturl ) dump ( False ) title = g . pafy_pls [ parturl ][ 0 ] . title # Remove double quotes for convenience subdir = util . sanitize_filename ( title . replace ( '\"' , '' )) down_many ( dltype , \"1-\" , subdir = subdir ) msg = g . message plist ( parturl ) g . message = msg","title":"down_plist()"},{"location":"reference/commands/download/#mps_youtube.commands.download.down_user_pls","text":"Download all user playlists. Source code in mps_youtube/commands/download.py @command ( r '(da|dv)upl\\s+(.*)' , 'daupl' , 'dvupl' ) def down_user_pls ( dltype , user ): \"\"\" Download all user playlists. \"\"\" user_pls ( user ) for i in g . ytpls : down_plist ( dltype , i . get ( 'link' )) return","title":"down_user_pls()"},{"location":"reference/commands/download/#mps_youtube.commands.download.download","text":"Download a track or playlist by menu item number. Source code in mps_youtube/commands/download.py @command ( r '(dv|da|d|dl|download)\\s*(\\d{1,4})' , 'da' , 'dv' , 'd' , 'dl' , 'download' ) def download ( dltype , num ): \"\"\" Download a track or playlist by menu item number. \"\"\" # This function needs refactoring! # pylint: disable=R0912 # pylint: disable=R0914 if g . browse_mode == \"ytpl\" and dltype in ( \"da\" , \"dv\" ): plid = g . ytpls [ int ( num ) - 1 ][ \"link\" ] down_plist ( dltype , plid ) return elif g . browse_mode == \"ytpl\" : g . message = \"Use da or dv to specify audio / video playlist download\" g . message = c . y + g . message + c . w g . content = content . generate_songlist_display () return elif g . browse_mode != \"normal\" : g . message = \"Download must refer to a specific video item\" g . message = c . y + g . message + c . w g . content = content . generate_songlist_display () return screen . writestatus ( \"Fetching video info...\" ) song = ( g . model [ int ( num ) - 1 ]) # best = dltype.startswith(\"dv\") or dltype.startswith(\"da\") # # if not best: # # try: # # user prompt for download stream # url, ext, url_au, ext_au = prompt_dl(song) # # except KeyboardInterrupt: # g.message = c.r + \"Download aborted!\" + c.w # g.content = content.generate_songlist_display() # return # # if not url or ext_au == \"abort\": # # abort on invalid stream selection # g.content = content.generate_songlist_display() # g.message = \"%sNo download selected / invalid input%s\" % (c.y, c.w) # return # # else: # # download user selected stream(s) # filename = _make_fname(song, ext) # args = (song, filename, url) # # if url_au and ext_au: # # downloading video and audio stream for muxing # audio = False # filename_au = _make_fname(song, ext_au) # args_au = (song, filename_au, url_au) # # else: # audio = ext in (\"m4a\", \"ogg\") # # kwargs = dict(audio=audio) # # elif best: # # set updownload without prompt # url_au = None # av = \"audio\" if dltype.startswith(\"da\") else \"video\" # audio = av == \"audio\" # filename = _make_fname(song, None, av=av) # args = (song, filename) # kwargs = dict(url=None, audio=audio) try : # perform download(s) # dl_filenames = [args[1]] # f = _download(*args, **kwargs) success = pafy . download_video ( song . ytid , config . DDIR . get ) if success : g . message = \"Saved \\' \" + song . title + \" \\' to \" + c . g + config . DDIR . get + c . w # if url_au: # dl_filenames += [args_au[1]] # _download(*args_au, allow_transcode=False, **kwargs) except KeyboardInterrupt : g . message = c . r + \"Download halted!\" + c . w # try: # for downloaded in dl_filenames: # os.remove(downloaded) # # except IOError: # pass # if url_au: # # multiplex # name, ext = os.path.splitext(args[1]) # tmpvideoname = name + '.' +str(random.randint(10000, 99999)) + ext # os.rename(args[1], tmpvideoname) # mux_cmd = [g.muxapp, \"-i\", tmpvideoname, \"-i\", args_au[1], \"-c\", # \"copy\", name + \".mp4\"] # # try: # subprocess.call(mux_cmd) # g.message = \"Saved to :\" + c.g + mux_cmd[7] + c.w # os.remove(tmpvideoname) # os.remove(args_au[1]) # # except KeyboardInterrupt: # g.message = \"Audio/Video multiplex aborted!\" g . content = content . generate_songlist_display ()","title":"download()"},{"location":"reference/commands/download/#mps_youtube.commands.download.external_download","text":"Perform download using external application. Source code in mps_youtube/commands/download.py def external_download ( song , filename , url ): \"\"\" Perform download using external application. \"\"\" cmd = config . DOWNLOAD_COMMAND . get ddir , basename = config . DDIR . get , os . path . basename ( filename ) cmd_list = shlex . split ( cmd ) def list_string_sub ( orig , repl , lst ): \"\"\" Replace substrings for items in a list. \"\"\" return [ x if orig not in x else x . replace ( orig , repl ) for x in lst ] cmd_list = list_string_sub ( \" %F \" , filename , cmd_list ) cmd_list = list_string_sub ( \" %d \" , ddir , cmd_list ) cmd_list = list_string_sub ( \" %f \" , basename , cmd_list ) cmd_list = list_string_sub ( \" %u \" , url , cmd_list ) cmd_list = list_string_sub ( \" %i \" , song . ytid , cmd_list ) util . dbg ( \"Downloading using: %s \" , \" \" . join ( cmd_list )) subprocess . call ( cmd_list )","title":"external_download()"},{"location":"reference/commands/download/#mps_youtube.commands.download.extract_metadata","text":"Try to determine metadata from video title. Source code in mps_youtube/commands/download.py def extract_metadata ( name ): \"\"\" Try to determine metadata from video title. \"\"\" seps = name . count ( \" - \" ) artist = title = None if seps == 1 : pos = name . find ( \" - \" ) artist = name [: pos ] . strip () title = name [ pos + 3 :] . strip () else : title = name . strip () return dict ( artist = artist , title = title )","title":"extract_metadata()"},{"location":"reference/commands/download/#mps_youtube.commands.download.gen_dl_text","text":"Generate text for dl screen. Source code in mps_youtube/commands/download.py def gen_dl_text ( ddata , song , p ): \"\"\" Generate text for dl screen. \"\"\" hdr = [] hdr . append ( \" %s%s%s \" % ( c . r , song . title , c . w )) author = p . author hdr . append ( c . r + \" Uploaded by \" + author + c . w ) hdr . append ( \" [\" + util . fmt_time ( song . length ) + \"]\" ) hdr . append ( \"\" ) heading = tuple ( \"Item Format Quality Media Size Notes\" . split ()) fmt = \" {0}%-6s %-8s %-13s %-7s %-5s %-16s{1} \" heading = [ fmt . format ( c . w , c . w ) % heading ] heading . append ( \"\" ) content = [] for n , d in enumerate ( ddata ): row = ( n + 1 , d [ 'ext' ], d [ 'quality' ], d [ 'mediatype' ], d [ 'size' ], d [ 'notes' ]) fmt = \" {0}%-6s %-8s %-13s %-7s %5s Mb %-16s{1} \" row = fmt . format ( c . g , c . w ) % row content . append ( row ) content . append ( \"\" ) footer = \"Select [ %s 1- %s%s ] to download or [ %s Enter %s ] to return\" footer = [ footer % ( c . y , len ( content ) - 1 , c . w , c . y , c . w )] return ( content , hdr , heading , footer )","title":"gen_dl_text()"},{"location":"reference/commands/download/#mps_youtube.commands.download.get_dl_data","text":"Get filesize and metadata for all streams, return dict. Source code in mps_youtube/commands/download.py def get_dl_data ( song , mediatype = \"any\" ): \"\"\" Get filesize and metadata for all streams, return dict. \"\"\" def mbsize ( x ): \"\"\" Return size in MB. \"\"\" return str ( int ( x / ( 1024 ** 2 ))) p = util . get_pafy ( song ) dldata = [] text = \" [Fetching stream info] >\" streamlist = [ x for x in p . allstreams ] if mediatype == \"audio\" : streamlist = [ x for x in p . audiostreams ] l = len ( streamlist ) for n , stream in enumerate ( streamlist ): sys . stdout . write ( text + \"-\" * n + \">\" + \" \" * ( l - n - 1 ) + \"< \\r \" ) sys . stdout . flush () try : size = mbsize ( stream . get_filesize ()) except TypeError : util . dbg ( c . r + \"---Error getting stream size\" + c . w ) size = 0 item = { 'mediatype' : stream . mediatype , 'size' : size , 'ext' : stream . extension , 'quality' : stream . quality , 'notes' : stream . notes , 'url' : stream . url } dldata . append ( item ) screen . writestatus ( \"\" ) return dldata , p","title":"get_dl_data()"},{"location":"reference/commands/download/#mps_youtube.commands.download.menu_prompt","text":"Generate a list of choice, returns item from model. Source code in mps_youtube/commands/download.py def menu_prompt ( model , prompt = \" > \" , rows = None , header = None , theading = None , footer = None , force = 0 ): \"\"\" Generate a list of choice, returns item from model. \"\"\" content = \"\" for x in header , theading , rows , footer : if isinstance ( x , list ): for line in x : content += line + \" \\n \" elif isinstance ( x , str ): content += x + \" \\n \" g . content = content screen . update () choice = input ( prompt ) if choice in model : return model [ choice ] elif force : return menu_prompt ( model , prompt , rows , header , theading , footer , force ) elif not choice . strip (): return False , False else : # unrecognised input return False , \"abort\"","title":"menu_prompt()"},{"location":"reference/commands/download/#mps_youtube.commands.download.prompt_dl","text":"Prompt user do choose a stream to dl. Return (url, extension). Source code in mps_youtube/commands/download.py def prompt_dl ( song ): \"\"\" Prompt user do choose a stream to dl. Return (url, extension). \"\"\" # pylint: disable=R0914 dl_data , p = get_dl_data ( song ) dl_text = gen_dl_text ( dl_data , song , p ) model = [ x [ 'url' ] for x in dl_data ] ed = enumerate ( dl_data ) model = { str ( n + 1 ): ( x [ 'url' ], x [ 'ext' ]) for n , x in ed } url , ext = menu_prompt ( model , \"Download number: \" , * dl_text ) url2 = ext2 = None mediatype = [ i for i in dl_data if i [ 'url' ] == url ][ 0 ][ 'mediatype' ] if mediatype == \"video\" and g . muxapp and not config . DOWNLOAD_COMMAND . get : # offer mux if not using external downloader dl_data , p = get_dl_data ( song , mediatype = \"audio\" ) dl_text = gen_dl_text ( dl_data , song , p ) au_choices = \"1\" if len ( dl_data ) == 1 else \"1- %s \" % len ( dl_data ) footer = [ util . F ( '-audio' ) % ext , util . F ( 'select mux' ) % au_choices ] dl_text = tuple ( dl_text [ 0 : 3 ]) + ( footer ,) aext = ( \"ogg\" , \"m4a\" ) model = [ x [ 'url' ] for x in dl_data if x [ 'ext' ] in aext ] ed = enumerate ( dl_data ) model = { str ( n + 1 ): ( x [ 'url' ], x [ 'ext' ]) for n , x in ed } prompt = \"Audio stream: \" url2 , ext2 = menu_prompt ( model , prompt , * dl_text ) return url , ext , url2 , ext2","title":"prompt_dl()"},{"location":"reference/commands/download/#mps_youtube.commands.download.remux_audio","text":"Remux audio file. Insert limited metadata tags. Source code in mps_youtube/commands/download.py def remux_audio ( filename , title ): \"\"\" Remux audio file. Insert limited metadata tags. \"\"\" util . dbg ( \"starting remux\" ) temp_file = filename + \".\" + str ( random . randint ( 10000 , 99999 )) os . rename ( filename , temp_file ) meta = extract_metadata ( title ) metadata = [ \"title= %s \" % meta [ \"title\" ]] if meta [ \"artist\" ]: metadata = [ \"title= %s \" % meta [ \"title\" ], \"-metadata\" , \"artist= %s \" % meta [ \"artist\" ]] cmd = [ g . muxapp , \"-y\" , \"-i\" , temp_file , \"-acodec\" , \"copy\" , \"-metadata\" ] cmd += metadata + [ \"-vn\" , filename ] util . dbg ( cmd ) try : with open ( os . devnull , \"w\" ) as devnull : subprocess . call ( cmd , stdout = devnull , stderr = subprocess . STDOUT ) except OSError : util . dbg ( \"Failed to remux audio using %s \" , g . muxapp ) os . rename ( temp_file , filename ) else : os . unlink ( temp_file ) util . dbg ( \"remuxed audio file using %s \" % g . muxapp )","title":"remux_audio()"},{"location":"reference/commands/download/#mps_youtube.commands.download.transcode","text":"Re encode a download. Source code in mps_youtube/commands/download.py def transcode ( filename , enc_data ): \"\"\" Re encode a download. \"\"\" base = os . path . splitext ( filename )[ 0 ] exe = g . muxapp if g . transcoder_path == \"auto\" else g . transcoder_path # ensure valid executable if not exe or not os . path . exists ( exe ) or not os . access ( exe , os . X_OK ): util . xprint ( \"Encoding failed. Couldn't find a valid encoder :( \\n \" ) time . sleep ( 2 ) return filename command = shlex . split ( enc_data [ 'command' ]) newcom , outfn = command [::], \"\" for n , d in enumerate ( command ): if d == \"ENCODER_PATH\" : newcom [ n ] = exe elif d == \"IN\" : newcom [ n ] = filename elif d == \"OUT\" : newcom [ n ] = outfn = base elif d == \"OUT.EXT\" : newcom [ n ] = outfn = base + \".\" + enc_data [ 'ext' ] returncode = subprocess . call ( newcom ) if returncode == 0 and g . delete_orig : os . unlink ( filename ) return outfn","title":"transcode()"},{"location":"reference/commands/generate_playlist/","text":"Playlist Generation check_sourcefile ( filename ) \u00b6 Check if filename exists and has a non-zero size Source code in mps_youtube/commands/generate_playlist.py def check_sourcefile ( filename ): \"\"\"Check if filename exists and has a non-zero size\"\"\" return path . isfile ( filename ) and path . getsize ( filename ) > 0 create_playlist ( queries , title = '' ) \u00b6 Add a new playlist Create playlist with a random name, get the first match for each title in queries and append it to the playlist Source code in mps_youtube/commands/generate_playlist.py def create_playlist ( queries , title = '' ): \"\"\"Add a new playlist Create playlist with a random name, get the first match for each title in queries and append it to the playlist \"\"\" plname = title . replace ( \" \" , \"-\" ) or random_plname () if not g . userpl . get ( plname ): g . userpl [ plname ] = Playlist ( plname ) for query in queries : g . message = util . F ( 'mkp finding' ) % query screen . update () qresult = find_best_match ( query ) if qresult : g . userpl [ plname ] . songs . append ( qresult ) if g . userpl [ plname ]: playlists . save () description_generator ( text ) \u00b6 Fetches a videos description and parses it for - combinations Source code in mps_youtube/commands/generate_playlist.py def description_generator ( text ): \"\"\" Fetches a videos description and parses it for <artist> - <track> combinations \"\"\" if not isinstance ( g . model , Playlist ): g . message = util . F ( \"mkp desc unknown\" ) return # Use only the first result, for now num = text . replace ( \"--description\" , \"\" ) num = num . replace ( \"-d\" , \"\" ) num = util . number_string_to_list ( num )[ 0 ] query = {} query [ 'id' ] = g . model [ num ] . ytid query [ 'part' ] = 'snippet' query [ 'maxResults' ] = '1' data = pafy . call_gdata ( 'videos' , query )[ 'items' ][ 0 ][ 'snippet' ] title = \"mkp %s \" % data [ 'title' ] data = util . fetch_songs ( data [ 'description' ], data [ 'title' ]) columns = [ { \"name\" : \"idx\" , \"size\" : 3 , \"heading\" : \"Num\" }, { \"name\" : \"artist\" , \"size\" : 30 , \"heading\" : \"Artist\" }, { \"name\" : \"title\" , \"size\" : \"remaining\" , \"heading\" : \"Title\" }, ] def run_m ( idx ): \"\"\" Create playlist based on the results selected \"\"\" create_playlist ( idx , title ) if data : data = [ listview . ListSongtitle ( x ) for x in data ] g . content = listview . ListView ( columns , data , run_m ) g . message = util . F ( \"mkp desc which data\" ) else : g . message = util . F ( \"mkp no valid\" ) return find_best_match ( query ) \u00b6 Find the best(first) Source code in mps_youtube/commands/generate_playlist.py def find_best_match ( query ): \"\"\"Find the best(first)\"\"\" # This assumes that the first match is the best one qs = search . generate_search_qs ( query ) wdata = pafy . call_gdata ( 'search' , qs ) results = search . get_tracks_from_json ( wdata ) if results : res , score = album_search . _best_song_match ( results , query , 0.1 , 1.0 , 0.0 ) return res generate_playlist ( sourcefile ) \u00b6 Generate a playlist from video titles in sourcefile Source code in mps_youtube/commands/generate_playlist.py @command ( r 'mkp\\s*(.{1,100})' , 'mkp' ) def generate_playlist ( sourcefile ): \"\"\"Generate a playlist from video titles in sourcefile\"\"\" # Hooks into this, check if the argument --description is present if \"--description\" in sourcefile or \"-d\" in sourcefile : description_generator ( sourcefile ) return expanded_sourcefile = path . expanduser ( sourcefile ) if not check_sourcefile ( expanded_sourcefile ): g . message = util . F ( 'mkp empty' ) % expanded_sourcefile else : queries = read_sourcefile ( expanded_sourcefile ) g . message = util . F ( 'mkp parsed' ) % ( len ( queries ), sourcefile ) if queries : create_playlist ( queries ) g . message = util . F ( 'pl help' ) g . content = content . playlists_display () random_plname () \u00b6 Generates a random alphanumeric string of 6 characters Source code in mps_youtube/commands/generate_playlist.py def random_plname (): \"\"\"Generates a random alphanumeric string of 6 characters\"\"\" n_chars = 6 return '' . join ( choice ( string . ascii_lowercase + string . digits ) for _ in range ( n_chars )) read_sourcefile ( filename ) \u00b6 Read each line as a query from filename Source code in mps_youtube/commands/generate_playlist.py def read_sourcefile ( filename ): \"\"\"Read each line as a query from filename\"\"\" with open ( filename ) as srcfl : queries = list () for item in srcfl . readlines (): clean_item = str ( item ) . strip () if not clean_item : continue queries . append ( clean_item ) return queries","title":"generate_playlist.py"},{"location":"reference/commands/generate_playlist/#mps_youtube.commands.generate_playlist.check_sourcefile","text":"Check if filename exists and has a non-zero size Source code in mps_youtube/commands/generate_playlist.py def check_sourcefile ( filename ): \"\"\"Check if filename exists and has a non-zero size\"\"\" return path . isfile ( filename ) and path . getsize ( filename ) > 0","title":"check_sourcefile()"},{"location":"reference/commands/generate_playlist/#mps_youtube.commands.generate_playlist.create_playlist","text":"Add a new playlist Create playlist with a random name, get the first match for each title in queries and append it to the playlist Source code in mps_youtube/commands/generate_playlist.py def create_playlist ( queries , title = '' ): \"\"\"Add a new playlist Create playlist with a random name, get the first match for each title in queries and append it to the playlist \"\"\" plname = title . replace ( \" \" , \"-\" ) or random_plname () if not g . userpl . get ( plname ): g . userpl [ plname ] = Playlist ( plname ) for query in queries : g . message = util . F ( 'mkp finding' ) % query screen . update () qresult = find_best_match ( query ) if qresult : g . userpl [ plname ] . songs . append ( qresult ) if g . userpl [ plname ]: playlists . save ()","title":"create_playlist()"},{"location":"reference/commands/generate_playlist/#mps_youtube.commands.generate_playlist.description_generator","text":"Fetches a videos description and parses it for - combinations Source code in mps_youtube/commands/generate_playlist.py def description_generator ( text ): \"\"\" Fetches a videos description and parses it for <artist> - <track> combinations \"\"\" if not isinstance ( g . model , Playlist ): g . message = util . F ( \"mkp desc unknown\" ) return # Use only the first result, for now num = text . replace ( \"--description\" , \"\" ) num = num . replace ( \"-d\" , \"\" ) num = util . number_string_to_list ( num )[ 0 ] query = {} query [ 'id' ] = g . model [ num ] . ytid query [ 'part' ] = 'snippet' query [ 'maxResults' ] = '1' data = pafy . call_gdata ( 'videos' , query )[ 'items' ][ 0 ][ 'snippet' ] title = \"mkp %s \" % data [ 'title' ] data = util . fetch_songs ( data [ 'description' ], data [ 'title' ]) columns = [ { \"name\" : \"idx\" , \"size\" : 3 , \"heading\" : \"Num\" }, { \"name\" : \"artist\" , \"size\" : 30 , \"heading\" : \"Artist\" }, { \"name\" : \"title\" , \"size\" : \"remaining\" , \"heading\" : \"Title\" }, ] def run_m ( idx ): \"\"\" Create playlist based on the results selected \"\"\" create_playlist ( idx , title ) if data : data = [ listview . ListSongtitle ( x ) for x in data ] g . content = listview . ListView ( columns , data , run_m ) g . message = util . F ( \"mkp desc which data\" ) else : g . message = util . F ( \"mkp no valid\" ) return","title":"description_generator()"},{"location":"reference/commands/generate_playlist/#mps_youtube.commands.generate_playlist.find_best_match","text":"Find the best(first) Source code in mps_youtube/commands/generate_playlist.py def find_best_match ( query ): \"\"\"Find the best(first)\"\"\" # This assumes that the first match is the best one qs = search . generate_search_qs ( query ) wdata = pafy . call_gdata ( 'search' , qs ) results = search . get_tracks_from_json ( wdata ) if results : res , score = album_search . _best_song_match ( results , query , 0.1 , 1.0 , 0.0 ) return res","title":"find_best_match()"},{"location":"reference/commands/generate_playlist/#mps_youtube.commands.generate_playlist.generate_playlist","text":"Generate a playlist from video titles in sourcefile Source code in mps_youtube/commands/generate_playlist.py @command ( r 'mkp\\s*(.{1,100})' , 'mkp' ) def generate_playlist ( sourcefile ): \"\"\"Generate a playlist from video titles in sourcefile\"\"\" # Hooks into this, check if the argument --description is present if \"--description\" in sourcefile or \"-d\" in sourcefile : description_generator ( sourcefile ) return expanded_sourcefile = path . expanduser ( sourcefile ) if not check_sourcefile ( expanded_sourcefile ): g . message = util . F ( 'mkp empty' ) % expanded_sourcefile else : queries = read_sourcefile ( expanded_sourcefile ) g . message = util . F ( 'mkp parsed' ) % ( len ( queries ), sourcefile ) if queries : create_playlist ( queries ) g . message = util . F ( 'pl help' ) g . content = content . playlists_display ()","title":"generate_playlist()"},{"location":"reference/commands/generate_playlist/#mps_youtube.commands.generate_playlist.random_plname","text":"Generates a random alphanumeric string of 6 characters Source code in mps_youtube/commands/generate_playlist.py def random_plname (): \"\"\"Generates a random alphanumeric string of 6 characters\"\"\" n_chars = 6 return '' . join ( choice ( string . ascii_lowercase + string . digits ) for _ in range ( n_chars ))","title":"random_plname()"},{"location":"reference/commands/generate_playlist/#mps_youtube.commands.generate_playlist.read_sourcefile","text":"Read each line as a query from filename Source code in mps_youtube/commands/generate_playlist.py def read_sourcefile ( filename ): \"\"\"Read each line as a query from filename\"\"\" with open ( filename ) as srcfl : queries = list () for item in srcfl . readlines (): clean_item = str ( item ) . strip () if not clean_item : continue queries . append ( clean_item ) return queries","title":"read_sourcefile()"},{"location":"reference/commands/lastfm/","text":"init_network ( verbose = True ) \u00b6 Initialize the global pylast network variable Source code in mps_youtube/commands/lastfm.py @command ( r 'lastfm_connect' , 'lastfm_connect' ) def init_network ( verbose = True ): \"\"\" Initialize the global pylast network variable \"\"\" if not has_pylast : if verbose : pylast_url = 'https://github.com/pylast/pylast' g . message = '\"pylast\" module not found \\n see %s ' % ( pylast_url ) return # TODO: Add option to read lastfm config from file or env variable key = config . LASTFM_API_KEY . get secret = config . LASTFM_API_SECRET . get password = config . LASTFM_PASSWORD . get # already hashed username = config . LASTFM_USERNAME . get if not ( key and secret and password and username ): if verbose : util . xprint ( \"Not all Last.fm credentials were set.\" ) return try : g . lastfm_network = pylast . LastFMNetwork ( api_key = key , api_secret = secret , username = username , password_hash = password ) if verbose : g . message = \"Last.fm authentication successful!\" except ( pylast . WSError , pylast . MalformedResponseError , pylast . NetworkError ) as e : if verbose : g . message = \"Last.fm connection error: %s \" % ( str ( e )) scrobble_track ( artist , album , track ) \u00b6 Scrobble a track to the user's Last.fm account Source code in mps_youtube/commands/lastfm.py def scrobble_track ( artist , album , track ): \"\"\" Scrobble a track to the user's Last.fm account \"\"\" if not g . lastfm_network : return unix_timestamp = int ( time . mktime ( datetime . datetime . now () . timetuple ())) try : g . lastfm_network . scrobble ( artist = artist , title = track , album = album , timestamp = unix_timestamp ) except ( pylast . WSError , pylast . MalformedResponseError , pylast . NetworkError ): return set_now_playing ( artist , track ) \u00b6 Set the current track as \"now playing\" on the user's Last.fm account Source code in mps_youtube/commands/lastfm.py def set_now_playing ( artist , track ): \"\"\" Set the current track as \"now playing\" on the user's Last.fm account \"\"\" if not g . lastfm_network : return try : g . lastfm_network . update_now_playing ( artist = artist , title = track ) except ( pylast . WSError , pylast . MalformedResponseError , pylast . NetworkError ): return","title":"lastfm.py"},{"location":"reference/commands/lastfm/#mps_youtube.commands.lastfm.init_network","text":"Initialize the global pylast network variable Source code in mps_youtube/commands/lastfm.py @command ( r 'lastfm_connect' , 'lastfm_connect' ) def init_network ( verbose = True ): \"\"\" Initialize the global pylast network variable \"\"\" if not has_pylast : if verbose : pylast_url = 'https://github.com/pylast/pylast' g . message = '\"pylast\" module not found \\n see %s ' % ( pylast_url ) return # TODO: Add option to read lastfm config from file or env variable key = config . LASTFM_API_KEY . get secret = config . LASTFM_API_SECRET . get password = config . LASTFM_PASSWORD . get # already hashed username = config . LASTFM_USERNAME . get if not ( key and secret and password and username ): if verbose : util . xprint ( \"Not all Last.fm credentials were set.\" ) return try : g . lastfm_network = pylast . LastFMNetwork ( api_key = key , api_secret = secret , username = username , password_hash = password ) if verbose : g . message = \"Last.fm authentication successful!\" except ( pylast . WSError , pylast . MalformedResponseError , pylast . NetworkError ) as e : if verbose : g . message = \"Last.fm connection error: %s \" % ( str ( e ))","title":"init_network()"},{"location":"reference/commands/lastfm/#mps_youtube.commands.lastfm.scrobble_track","text":"Scrobble a track to the user's Last.fm account Source code in mps_youtube/commands/lastfm.py def scrobble_track ( artist , album , track ): \"\"\" Scrobble a track to the user's Last.fm account \"\"\" if not g . lastfm_network : return unix_timestamp = int ( time . mktime ( datetime . datetime . now () . timetuple ())) try : g . lastfm_network . scrobble ( artist = artist , title = track , album = album , timestamp = unix_timestamp ) except ( pylast . WSError , pylast . MalformedResponseError , pylast . NetworkError ): return","title":"scrobble_track()"},{"location":"reference/commands/lastfm/#mps_youtube.commands.lastfm.set_now_playing","text":"Set the current track as \"now playing\" on the user's Last.fm account Source code in mps_youtube/commands/lastfm.py def set_now_playing ( artist , track ): \"\"\" Set the current track as \"now playing\" on the user's Last.fm account \"\"\" if not g . lastfm_network : return try : g . lastfm_network . update_now_playing ( artist = artist , title = track ) except ( pylast . WSError , pylast . MalformedResponseError , pylast . NetworkError ): return","title":"set_now_playing()"},{"location":"reference/commands/local_playlist/","text":"add_rm_all ( action ) \u00b6 Add all displayed songs to current playlist. remove all displayed songs from view. Source code in mps_youtube/commands/local_playlist.py @command ( r '(rm|add)\\s(?:\\*|all)' , 'rm' , 'add' ) def add_rm_all ( action ): \"\"\" Add all displayed songs to current playlist. remove all displayed songs from view. \"\"\" if action == \"rm\" : g . model . songs . clear () msg = c . b + \"Cleared all songs\" + c . w g . content = content . generate_songlist_display ( zeromsg = msg ) elif action == \"add\" : size = len ( g . model ) songlist_rm_add ( \"add\" , \"-\" + str ( size )) ls () \u00b6 List user saved playlists. Source code in mps_youtube/commands/local_playlist.py @command ( r 'ls' , 'ls' ) def ls (): \"\"\" List user saved playlists. \"\"\" if not g . userpl : g . message = util . F ( 'no playlists' ) g . content = g . content or \\ content . generate_songlist_display ( zeromsg = g . message ) else : g . content = content . playlists_display () g . message = util . F ( 'pl help' ) open_save_view ( action , name ) \u00b6 Open, save or view a playlist by name. Get closest name match. Source code in mps_youtube/commands/local_playlist.py @command ( r '(open|save|view)\\s*( %s )' % WORD , 'open' , 'save' , 'view' ) def open_save_view ( action , name ): \"\"\" Open, save or view a playlist by name. Get closest name match. \"\"\" name = name . replace ( \" \" , \"-\" ) if action == \"open\" or action == \"view\" : saved = g . userpl . get ( name ) if not saved : name = util . get_near_name ( name , g . userpl ) saved = g . userpl . get ( name ) elif action == \"open\" : g . active . songs = list ( saved . songs ) g . last_opened = name msg = util . F ( \"pl loaded\" ) % name paginatesongs ( g . active , msg = msg ) elif action == \"view\" : g . last_opened = \"\" msg = util . F ( \"pl viewed\" ) % name paginatesongs ( list ( saved . songs ), msg = msg ) elif not saved and action in \"view open\" . split (): g . message = util . F ( \"pl not found\" ) % name g . content = content . playlists_display () elif action == \"save\" : if not g . model : g . message = \"Nothing to save. \" + util . F ( 'advise search' ) g . content = content . generate_songlist_display () else : g . userpl [ name ] = Playlist ( name , list ( g . model . songs )) g . message = util . F ( 'pl saved' ) % name playlists . save () g . content = content . generate_songlist_display () open_view_bynum ( action , num ) \u00b6 Open or view a saved playlist by number. Source code in mps_youtube/commands/local_playlist.py @command ( r '(open|view)\\s*(\\d{1,4})' , 'open' , 'view' ) def open_view_bynum ( action , num ): \"\"\" Open or view a saved playlist by number. \"\"\" srt = sorted ( g . userpl ) name = srt [ int ( num ) - 1 ] open_save_view ( action , name ) playlist_add ( nums , playlist ) \u00b6 Add selected song nums to saved playlist. Source code in mps_youtube/commands/local_playlist.py @command ( r 'add\\s*(-?\\d[-,\\d\\s]{1,250})( %s )' % WORD , 'add' ) def playlist_add ( nums , playlist ): \"\"\" Add selected song nums to saved playlist. \"\"\" nums = util . parse_multi ( nums ) # Replacing spaces with hyphens before checking if playlist already exist. # See https://github.com/mps-youtube/mps-youtube/issues/1046. playlist = playlist . replace ( \" \" , \"-\" ) if not g . userpl . get ( playlist ): g . userpl [ playlist ] = Playlist ( playlist ) for songnum in nums : g . userpl [ playlist ] . songs . append ( g . model [ songnum - 1 ]) dur = g . userpl [ playlist ] . duration f = ( len ( nums ), playlist , len ( g . userpl [ playlist ]), dur ) g . message = util . F ( 'added to saved pl' ) % f if nums : playlists . save () g . content = content . generate_songlist_display () playlist_remove ( name ) \u00b6 Delete a saved playlist by name - or purge working playlist if *all. Source code in mps_youtube/commands/local_playlist.py @command ( r 'rmp\\s*(\\d+| %s )' % WORD , 'rmp' ) def playlist_remove ( name ): \"\"\" Delete a saved playlist by name - or purge working playlist if *all.\"\"\" if name . isdigit () or g . userpl . get ( name ): if name . isdigit (): name = int ( name ) - 1 name = sorted ( g . userpl )[ name ] playlists . delete ( name ) g . message = \"Deleted playlist %s%s%s \" % ( c . y , name , c . w ) g . content = content . playlists_display () #playlists.save() else : g . message = util . F ( 'pl not found advise ls' ) % name g . content = content . playlists_display () playlist_rename ( playlists_ ) \u00b6 Rename a playlist using mv command. Source code in mps_youtube/commands/local_playlist.py @command ( r 'mv\\s*( %s \\s+ %s )' % ( WORD , WORD ), 'mv' ) def playlist_rename ( playlists_ ): \"\"\" Rename a playlist using mv command. \"\"\" # Deal with old playlist names that permitted spaces a , b = \"\" , playlists_ . split ( \" \" ) while a not in g . userpl : a = ( a + \" \" + ( b . pop ( 0 ))) . strip () if not b and a not in g . userpl : g . message = util . F ( 'no pl match for rename' ) g . content = g . content or content . playlists_display () return b = \"-\" . join ( b ) g . userpl [ b ] = Playlist ( b ) g . userpl [ b ] . songs = list ( g . userpl [ a ] . songs ) playlist_remove ( a ) g . message = util . F ( 'pl renamed' ) % ( a , b ) playlists . save () playlist_rename_idx ( _id , name ) \u00b6 Rename a playlist by ID. Source code in mps_youtube/commands/local_playlist.py @command ( r 'mv\\s*(\\d{1,3})\\s*( %s )' % WORD , 'mv' ) def playlist_rename_idx ( _id , name ): \"\"\" Rename a playlist by ID. \"\"\" _id = int ( _id ) - 1 playlist_rename ( sorted ( g . userpl )[ _id ] + \" \" + name ) save_last () \u00b6 Save command with no playlist name. Source code in mps_youtube/commands/local_playlist.py @command ( r 'save' , 'save' ) def save_last (): \"\"\" Save command with no playlist name. \"\"\" if g . last_opened : open_save_view ( \"save\" , g . last_opened ) else : saveas = \"\" # save using artist name in postion 1 if g . model : saveas = g . model [ 0 ] . title [: 18 ] . strip () saveas = re . sub ( r \"[^-\\w]\" , \"-\" , saveas , flags = re . UNICODE ) # loop to find next available name post = 0 while g . userpl . get ( saveas ): post += 1 saveas = g . model [ 0 ] . title [: 18 ] . strip () + \"-\" + str ( post ) # Playlists are not allowed to start with a digit # TODO: Possibly change this, but ban purely numerical names saveas = saveas . lstrip ( \"0123456789\" ) open_save_view ( \"save\" , saveas ) vp () \u00b6 View current working playlist. Source code in mps_youtube/commands/local_playlist.py @command ( r 'vp' , 'vp' ) def vp (): \"\"\" View current working playlist. \"\"\" msg = util . F ( 'current pl' ) txt = util . F ( 'advise add' ) if g . model else util . F ( 'advise search' ) failmsg = util . F ( 'pl empty' ) + \" \" + txt paginatesongs ( g . active , msg = msg , failmsg = failmsg )","title":"local_playlist.py"},{"location":"reference/commands/local_playlist/#mps_youtube.commands.local_playlist.add_rm_all","text":"Add all displayed songs to current playlist. remove all displayed songs from view. Source code in mps_youtube/commands/local_playlist.py @command ( r '(rm|add)\\s(?:\\*|all)' , 'rm' , 'add' ) def add_rm_all ( action ): \"\"\" Add all displayed songs to current playlist. remove all displayed songs from view. \"\"\" if action == \"rm\" : g . model . songs . clear () msg = c . b + \"Cleared all songs\" + c . w g . content = content . generate_songlist_display ( zeromsg = msg ) elif action == \"add\" : size = len ( g . model ) songlist_rm_add ( \"add\" , \"-\" + str ( size ))","title":"add_rm_all()"},{"location":"reference/commands/local_playlist/#mps_youtube.commands.local_playlist.ls","text":"List user saved playlists. Source code in mps_youtube/commands/local_playlist.py @command ( r 'ls' , 'ls' ) def ls (): \"\"\" List user saved playlists. \"\"\" if not g . userpl : g . message = util . F ( 'no playlists' ) g . content = g . content or \\ content . generate_songlist_display ( zeromsg = g . message ) else : g . content = content . playlists_display () g . message = util . F ( 'pl help' )","title":"ls()"},{"location":"reference/commands/local_playlist/#mps_youtube.commands.local_playlist.open_save_view","text":"Open, save or view a playlist by name. Get closest name match. Source code in mps_youtube/commands/local_playlist.py @command ( r '(open|save|view)\\s*( %s )' % WORD , 'open' , 'save' , 'view' ) def open_save_view ( action , name ): \"\"\" Open, save or view a playlist by name. Get closest name match. \"\"\" name = name . replace ( \" \" , \"-\" ) if action == \"open\" or action == \"view\" : saved = g . userpl . get ( name ) if not saved : name = util . get_near_name ( name , g . userpl ) saved = g . userpl . get ( name ) elif action == \"open\" : g . active . songs = list ( saved . songs ) g . last_opened = name msg = util . F ( \"pl loaded\" ) % name paginatesongs ( g . active , msg = msg ) elif action == \"view\" : g . last_opened = \"\" msg = util . F ( \"pl viewed\" ) % name paginatesongs ( list ( saved . songs ), msg = msg ) elif not saved and action in \"view open\" . split (): g . message = util . F ( \"pl not found\" ) % name g . content = content . playlists_display () elif action == \"save\" : if not g . model : g . message = \"Nothing to save. \" + util . F ( 'advise search' ) g . content = content . generate_songlist_display () else : g . userpl [ name ] = Playlist ( name , list ( g . model . songs )) g . message = util . F ( 'pl saved' ) % name playlists . save () g . content = content . generate_songlist_display ()","title":"open_save_view()"},{"location":"reference/commands/local_playlist/#mps_youtube.commands.local_playlist.open_view_bynum","text":"Open or view a saved playlist by number. Source code in mps_youtube/commands/local_playlist.py @command ( r '(open|view)\\s*(\\d{1,4})' , 'open' , 'view' ) def open_view_bynum ( action , num ): \"\"\" Open or view a saved playlist by number. \"\"\" srt = sorted ( g . userpl ) name = srt [ int ( num ) - 1 ] open_save_view ( action , name )","title":"open_view_bynum()"},{"location":"reference/commands/local_playlist/#mps_youtube.commands.local_playlist.playlist_add","text":"Add selected song nums to saved playlist. Source code in mps_youtube/commands/local_playlist.py @command ( r 'add\\s*(-?\\d[-,\\d\\s]{1,250})( %s )' % WORD , 'add' ) def playlist_add ( nums , playlist ): \"\"\" Add selected song nums to saved playlist. \"\"\" nums = util . parse_multi ( nums ) # Replacing spaces with hyphens before checking if playlist already exist. # See https://github.com/mps-youtube/mps-youtube/issues/1046. playlist = playlist . replace ( \" \" , \"-\" ) if not g . userpl . get ( playlist ): g . userpl [ playlist ] = Playlist ( playlist ) for songnum in nums : g . userpl [ playlist ] . songs . append ( g . model [ songnum - 1 ]) dur = g . userpl [ playlist ] . duration f = ( len ( nums ), playlist , len ( g . userpl [ playlist ]), dur ) g . message = util . F ( 'added to saved pl' ) % f if nums : playlists . save () g . content = content . generate_songlist_display ()","title":"playlist_add()"},{"location":"reference/commands/local_playlist/#mps_youtube.commands.local_playlist.playlist_remove","text":"Delete a saved playlist by name - or purge working playlist if *all. Source code in mps_youtube/commands/local_playlist.py @command ( r 'rmp\\s*(\\d+| %s )' % WORD , 'rmp' ) def playlist_remove ( name ): \"\"\" Delete a saved playlist by name - or purge working playlist if *all.\"\"\" if name . isdigit () or g . userpl . get ( name ): if name . isdigit (): name = int ( name ) - 1 name = sorted ( g . userpl )[ name ] playlists . delete ( name ) g . message = \"Deleted playlist %s%s%s \" % ( c . y , name , c . w ) g . content = content . playlists_display () #playlists.save() else : g . message = util . F ( 'pl not found advise ls' ) % name g . content = content . playlists_display ()","title":"playlist_remove()"},{"location":"reference/commands/local_playlist/#mps_youtube.commands.local_playlist.playlist_rename","text":"Rename a playlist using mv command. Source code in mps_youtube/commands/local_playlist.py @command ( r 'mv\\s*( %s \\s+ %s )' % ( WORD , WORD ), 'mv' ) def playlist_rename ( playlists_ ): \"\"\" Rename a playlist using mv command. \"\"\" # Deal with old playlist names that permitted spaces a , b = \"\" , playlists_ . split ( \" \" ) while a not in g . userpl : a = ( a + \" \" + ( b . pop ( 0 ))) . strip () if not b and a not in g . userpl : g . message = util . F ( 'no pl match for rename' ) g . content = g . content or content . playlists_display () return b = \"-\" . join ( b ) g . userpl [ b ] = Playlist ( b ) g . userpl [ b ] . songs = list ( g . userpl [ a ] . songs ) playlist_remove ( a ) g . message = util . F ( 'pl renamed' ) % ( a , b ) playlists . save ()","title":"playlist_rename()"},{"location":"reference/commands/local_playlist/#mps_youtube.commands.local_playlist.playlist_rename_idx","text":"Rename a playlist by ID. Source code in mps_youtube/commands/local_playlist.py @command ( r 'mv\\s*(\\d{1,3})\\s*( %s )' % WORD , 'mv' ) def playlist_rename_idx ( _id , name ): \"\"\" Rename a playlist by ID. \"\"\" _id = int ( _id ) - 1 playlist_rename ( sorted ( g . userpl )[ _id ] + \" \" + name )","title":"playlist_rename_idx()"},{"location":"reference/commands/local_playlist/#mps_youtube.commands.local_playlist.save_last","text":"Save command with no playlist name. Source code in mps_youtube/commands/local_playlist.py @command ( r 'save' , 'save' ) def save_last (): \"\"\" Save command with no playlist name. \"\"\" if g . last_opened : open_save_view ( \"save\" , g . last_opened ) else : saveas = \"\" # save using artist name in postion 1 if g . model : saveas = g . model [ 0 ] . title [: 18 ] . strip () saveas = re . sub ( r \"[^-\\w]\" , \"-\" , saveas , flags = re . UNICODE ) # loop to find next available name post = 0 while g . userpl . get ( saveas ): post += 1 saveas = g . model [ 0 ] . title [: 18 ] . strip () + \"-\" + str ( post ) # Playlists are not allowed to start with a digit # TODO: Possibly change this, but ban purely numerical names saveas = saveas . lstrip ( \"0123456789\" ) open_save_view ( \"save\" , saveas )","title":"save_last()"},{"location":"reference/commands/local_playlist/#mps_youtube.commands.local_playlist.vp","text":"View current working playlist. Source code in mps_youtube/commands/local_playlist.py @command ( r 'vp' , 'vp' ) def vp (): \"\"\" View current working playlist. \"\"\" msg = util . F ( 'current pl' ) txt = util . F ( 'advise add' ) if g . model else util . F ( 'advise search' ) failmsg = util . F ( 'pl empty' ) + \" \" + txt paginatesongs ( g . active , msg = msg , failmsg = failmsg )","title":"vp()"},{"location":"reference/commands/misc/","text":"clear_history () \u00b6 Clears the user's play history Source code in mps_youtube/commands/misc.py @command ( r 'history clear' , 'history clear' ) def clear_history (): \"\"\" Clears the user's play history \"\"\" g . userhist [ 'history' ] . songs = [] history . save () g . message = \"History cleared\" g . content = logo () clearcache () \u00b6 Clear cached items - for debugging use. Source code in mps_youtube/commands/misc.py @command ( r 'clearcache' ) def clearcache (): \"\"\" Clear cached items - for debugging use. \"\"\" g . pafs = {} g . streams = {} util . dbg ( \" %s cache cleared %s \" , c . p , c . w ) g . message = \"cache cleared\" clipcopy_stream ( num ) \u00b6 Copy content stream url to clipboard. Source code in mps_youtube/commands/misc.py @command ( r 'X\\s*(\\d+)' , 'X' ) def clipcopy_stream ( num ): \"\"\" Copy content stream url to clipboard. \"\"\" if g . browse_mode == \"normal\" : item = ( g . model [ int ( num ) - 1 ]) details = player . stream_details ( item )[ 1 ] stream = details [ 'url' ] else : g . message = \"clipboard copy not valid in this mode\" g . content = generate_songlist_display () return if has_pyperclip : try : pyperclip . copy ( stream ) g . message = c . y + stream + c . w + \" copied\" g . content = generate_songlist_display () except Exception as e : g . content = generate_songlist_display () g . message = stream + \" \\n Error - couldn't copy to clipboard. \\n \" + \\ '' . join ( traceback . format_exception_only ( type ( e ), e )) else : g . message = \"pyperclip module must be installed for clipboard support \\n \" g . message += \"see https://pypi.python.org/pypi/pyperclip/\" g . content = generate_songlist_display () clipcopy_video ( num ) \u00b6 Copy video/playlist url to clipboard. Source code in mps_youtube/commands/misc.py @command ( r 'x\\s*(\\d+)' , 'x' ) def clipcopy_video ( num ): \"\"\" Copy video/playlist url to clipboard. \"\"\" if g . browse_mode == \"ytpl\" : p = g . ytpls [ int ( num ) - 1 ] link = \"https://youtube.com/playlist?list= %s \" % p [ 'link' ] elif g . browse_mode == \"normal\" : item = ( g . model [ int ( num ) - 1 ]) link = \"https://youtube.com/watch?v= %s \" % item . ytid else : g . message = \"clipboard copy not valid in this mode\" g . content = generate_songlist_display () return if has_pyperclip : try : pyperclip . copy ( link ) g . message = c . y + link + c . w + \" copied\" g . content = generate_songlist_display () except Exception as e : g . content = generate_songlist_display () g . message = link + \" \\n Error - couldn't copy to clipboard. \\n \" + \\ '' . join ( traceback . format_exception_only ( type ( e ), e )) else : g . message = \"pyperclip module must be installed for clipboard support \\n \" g . message += \"see https://pypi.python.org/pypi/pyperclip/\" g . content = generate_songlist_display () comments ( number ) \u00b6 Receive use request to view comments. Source code in mps_youtube/commands/misc.py @command ( r 'c\\s?(\\d{1,4})' , 'c' ) def comments ( number ): \"\"\" Receive use request to view comments. \"\"\" if g . browse_mode == \"normal\" : item = g . model [ int ( number ) - 1 ] fetch_comments ( item ) else : g . content = generate_songlist_display () g . message = \"Comments only available for video items\" fetch_comments ( item ) \u00b6 Fetch comments for item using gdata. Source code in mps_youtube/commands/misc.py def fetch_comments ( item ): \"\"\" Fetch comments for item using gdata. \"\"\" # pylint: disable=R0912 # pylint: disable=R0914 ytid , title = item . ytid , item . title util . dbg ( \"Fetching comments for %s \" , c . c ( \"y\" , ytid )) screen . writestatus ( \"Fetching comments for %s \" % c . c ( \"y\" , title [: 55 ])) # qs = {'textFormat': 'plainText', # 'videoId': ytid, # 'maxResults': 50, # 'part': 'snippet'} # jsdata = None try : all_comments = pafy . get_comments ( ytid ) except Exception : raise # coms = [x.get('snippet', {}) for x in jsdata.get('items', [])] # skip blanks # coms = [x for x in coms # if len(x.get('topLevelComment', {}).get('snippet', {}).get('textDisplay', '').strip())] if not len ( all_comments ): g . message = \"No comments for %s \" % item . title [: 50 ] g . content = generate_songlist_display () return commentstext = '' for n , com in enumerate ( all_comments , 1 ): # snippet = com.get('topLevelComment', {}).get('snippet', {}) commentstext += _format_comment ( n , len ( all_comments ), com [ 'author' ][ 'name' ], com [ 'published' ], com [ 'content' ]) # todo fetch comment replies # if com.get('replyCount') > 0: # replies = _fetch_commentreplies(com.get('topLevelComment').get('id')) # for n, com in enumerate(reversed(replies), 1): # commentstext += _format_comment(com.get('snippet', {}), # n, len(replies), True) g . current_page = 0 g . content = content . StringContent ( commentstext ) quits ( showlogo = True ) \u00b6 Exit the program. Source code in mps_youtube/commands/misc.py @command ( r '(?:q|quit|exit)' , 'quit' , 'exit' ) def quits ( showlogo = True ): \"\"\" Exit the program. \"\"\" if has_readline and config . INPUT_HISTORY . get : readline . write_history_file ( g . READLINE_FILE ) util . dbg ( \"Saved history file\" ) cache . save () screen . clear () msg = logo ( c . r , version = __version__ ) if showlogo else \"\" msg += util . F ( \"exitmsg\" , 2 ) if config . CHECKUPDATE . get and showlogo : try : url = \"https://raw.githubusercontent.com/iamtalhaasghar/yewtube/master/setup.py\" v = urlopen ( url , timeout = 1 ) . read () . decode () v = re . search ( r '__version__\\s*=\\s*\"\\s*([\\d\\.]+)\\s*\"\\s*' , v , re . MULTILINE ) if v : v = v . group ( 1 ) if v > __version__ : msg += \" \\n\\n A newer version is available ( %s ). Use `help new` command to check what's changed. \\n \" % v except ( URLError , HTTPError , socket . timeout ): util . dbg ( \"check update timed out\" ) screen . msgexit ( msg ) recent_history () \u00b6 Display the recent user's played songs Source code in mps_youtube/commands/misc.py @command ( r 'history recent' , 'history recent' ) def recent_history (): \"\"\" Display the recent user's played songs \"\"\" view_history ( duplicates = False ) show_help ( choice ) \u00b6 Print help message. Source code in mps_youtube/commands/misc.py @command ( r '(?:help|h)(?:\\s+([-_a-zA-Z]+))?' , 'help' ) def show_help ( choice ): \"\"\" Print help message. \"\"\" g . content = get_help ( choice ) stream_info ( num ) \u00b6 Get stream information. Source code in mps_youtube/commands/misc.py @command ( r 's\\s*(\\d{1,4})' , 's' ) def stream_info ( num ): \"\"\" Get stream information. \"\"\" if g . browse_mode == \"normal\" : g . content = logo ( c . b ) screen . update () screen . writestatus ( \"Fetching stream metadata..\" ) item = ( g . model [ int ( num ) - 1 ]) streams . get ( item ) p = util . get_pafy ( item ) setattr ( p , 'ytid' , p . videoid ) details = player . stream_details ( p )[ 1 ] screen . writestatus ( \"Fetched\" ) out = \" \\n\\n \" + c . ul + \"Stream Info\" + c . w + \" \\n \" out += \" \\n Extension : \" + details [ 'ext' ] out += \" \\n Size : \" + str ( details [ 'size' ]) out += \" \\n Quality : \" + details [ 'quality' ] out += \" \\n Raw bitrate : \" + str ( details [ 'rawbitrate' ]) out += \" \\n Media type : \" + details [ 'mtype' ] out += \" \\n Link : \" + details [ 'url' ] out += \" \\n\\n %s [ %s Press enter to go back %s ] %s \" % ( c . y , c . w , c . y , c . w ) g . content = out video_info ( num ) \u00b6 Get video information. Source code in mps_youtube/commands/misc.py @command ( r 'i\\s*(\\d{1,4})' , 'i' ) def video_info ( num ): \"\"\" Get video information. \"\"\" if g . browse_mode == \"ytpl\" : p = g . ytpls [ int ( num ) - 1 ] # fetch the playlist item as it has more metadata if p [ 'link' ] in g . pafy_pls : ytpl = g . pafy_pls [ p [ 'link' ]][ 0 ] else : g . content = logo ( col = c . g ) g . message = \"Fetching playlist info..\" screen . update () util . dbg ( \" %s Fetching playlist using pafy %s \" , c . y , c . w ) ytpl = pafy . get_playlist2 ( p [ 'link' ]) g . pafy_pls [ p [ 'link' ]] = ( ytpl , util . IterSlicer ( ytpl )) ytpl_desc = ytpl . description g . content = generate_songlist_display () created = util . yt_datetime_local ( p [ 'created' ]) updated = util . yt_datetime_local ( p [ 'updated' ]) out = c . ul + \"Playlist Info\" + c . w + \" \\n\\n \" out += p [ 'title' ] out += \" \\n \" + ytpl_desc out += ( \" \\n\\n Author : \" + p [ 'author' ]) out += \" \\n Size : \" + str ( p [ 'size' ]) + \" videos\" out += \" \\n Created : \" + created [ 1 ] + \" \" + created [ 2 ] out += \" \\n Updated : \" + updated [ 1 ] + \" \" + updated [ 2 ] out += \" \\n ID : \" + str ( p [ 'link' ]) out += ( \" \\n\\n %s [ %s Press enter to go back %s ] %s \" % ( c . y , c . w , c . y , c . w )) g . content = out elif g . browse_mode == \"normal\" : g . content = logo ( c . b ) screen . update () screen . writestatus ( \"Fetching video metadata..\" ) item = ( g . model [ int ( num ) - 1 ]) streams . get ( item ) p = pafy . get_video_info ( item . ytid ) #pub = datetime.strptime(str(p.published), \"%Y-%m-%d %H:%M:%SZ\") #pub = util.utc2local(pub) screen . writestatus ( \"Fetched\" ) out = c . ul + \"Video Info\" + c . w + \" \\n\\n \" out += p [ 'title' ] or \"\" out += \" \\n\\n Description: \\n\\n \" + str ( p . get ( 'description' , \"\" )) + \" \\n \" out += \" \\n Keywords: \" + str ( p [ 'keywords' ]) + \" \\n \" out += \" \\n Is Live Now : \" + str ( p [ 'isLiveNow' ]) out += \" \\n Duration : \" + str ( timedelta ( seconds = int ( p [ 'duration' ][ 'secondsText' ]))) out += \" \\n View count : \" + \" {:,} \" . format ( int ( p [ 'viewCount' ][ 'text' ])) out += \" \\n Author : \" + str ( p [ 'channel' ][ 'name' ] + ' ~ ' + p [ 'channel' ][ 'link' ]) out += \" \\n Published Date : \" + str ( p [ 'publishDate' ]) out += \" \\n Uploaded Date : \" + str ( p [ 'uploadDate' ]) out += \" \\n Rating : \" + str ( p [ 'averageRating' ]) out += \" \\n Likes : \" + \" {:,} \" . format ( p . get ( 'likes' , 0 )) out += \" \\n Dislikes : \" + \" {:,} \" . format ( p . get ( 'dislikes' , 0 )) out += \" \\n Category : \" + str ( p [ 'category' ]) out += \" \\n Family Safe : \" + str ( p [ 'isFamilySafe' ]) out += \" \\n Link : \" + str ( p [ 'link' ]) if config . SHOW_QRCODE . get : out += \" \\n \" + qrcode_display ( \"https://youtube.com/watch?v= %s \" % p . videoid ) out += \" \\n\\n %s [ %s Press enter to go back %s ] %s \" % ( c . y , c . w , c . y , c . w ) g . content = out view_history ( duplicates = True ) \u00b6 Display the user's play history Source code in mps_youtube/commands/misc.py @command ( r 'history' , 'history' ) def view_history ( duplicates = True ): \"\"\" Display the user's play history \"\"\" history = g . userhist . get ( 'history' ) #g.last_opened = \"\" try : hist_list = list ( reversed ( history . songs )) message = \"Viewing play history\" if not duplicates : # List unique elements and preserve order. seen = set () seen_add = seen . add # it makes calls to add() faster hist_list = [ x for x in hist_list if not ( x . ytid in seen or seen_add ( x . ytid ))] message = \"Viewing recent played songs\" paginatesongs ( hist_list ) g . message = message except AttributeError : g . content = logo ( c . r ) g . message = \"History empty\" if not config . HISTORY . get : g . message += \" \\t {1} History recording is currently off {0} \" . format ( c . w , c . y )","title":"misc.py"},{"location":"reference/commands/misc/#mps_youtube.commands.misc.clear_history","text":"Clears the user's play history Source code in mps_youtube/commands/misc.py @command ( r 'history clear' , 'history clear' ) def clear_history (): \"\"\" Clears the user's play history \"\"\" g . userhist [ 'history' ] . songs = [] history . save () g . message = \"History cleared\" g . content = logo ()","title":"clear_history()"},{"location":"reference/commands/misc/#mps_youtube.commands.misc.clearcache","text":"Clear cached items - for debugging use. Source code in mps_youtube/commands/misc.py @command ( r 'clearcache' ) def clearcache (): \"\"\" Clear cached items - for debugging use. \"\"\" g . pafs = {} g . streams = {} util . dbg ( \" %s cache cleared %s \" , c . p , c . w ) g . message = \"cache cleared\"","title":"clearcache()"},{"location":"reference/commands/misc/#mps_youtube.commands.misc.clipcopy_stream","text":"Copy content stream url to clipboard. Source code in mps_youtube/commands/misc.py @command ( r 'X\\s*(\\d+)' , 'X' ) def clipcopy_stream ( num ): \"\"\" Copy content stream url to clipboard. \"\"\" if g . browse_mode == \"normal\" : item = ( g . model [ int ( num ) - 1 ]) details = player . stream_details ( item )[ 1 ] stream = details [ 'url' ] else : g . message = \"clipboard copy not valid in this mode\" g . content = generate_songlist_display () return if has_pyperclip : try : pyperclip . copy ( stream ) g . message = c . y + stream + c . w + \" copied\" g . content = generate_songlist_display () except Exception as e : g . content = generate_songlist_display () g . message = stream + \" \\n Error - couldn't copy to clipboard. \\n \" + \\ '' . join ( traceback . format_exception_only ( type ( e ), e )) else : g . message = \"pyperclip module must be installed for clipboard support \\n \" g . message += \"see https://pypi.python.org/pypi/pyperclip/\" g . content = generate_songlist_display ()","title":"clipcopy_stream()"},{"location":"reference/commands/misc/#mps_youtube.commands.misc.clipcopy_video","text":"Copy video/playlist url to clipboard. Source code in mps_youtube/commands/misc.py @command ( r 'x\\s*(\\d+)' , 'x' ) def clipcopy_video ( num ): \"\"\" Copy video/playlist url to clipboard. \"\"\" if g . browse_mode == \"ytpl\" : p = g . ytpls [ int ( num ) - 1 ] link = \"https://youtube.com/playlist?list= %s \" % p [ 'link' ] elif g . browse_mode == \"normal\" : item = ( g . model [ int ( num ) - 1 ]) link = \"https://youtube.com/watch?v= %s \" % item . ytid else : g . message = \"clipboard copy not valid in this mode\" g . content = generate_songlist_display () return if has_pyperclip : try : pyperclip . copy ( link ) g . message = c . y + link + c . w + \" copied\" g . content = generate_songlist_display () except Exception as e : g . content = generate_songlist_display () g . message = link + \" \\n Error - couldn't copy to clipboard. \\n \" + \\ '' . join ( traceback . format_exception_only ( type ( e ), e )) else : g . message = \"pyperclip module must be installed for clipboard support \\n \" g . message += \"see https://pypi.python.org/pypi/pyperclip/\" g . content = generate_songlist_display ()","title":"clipcopy_video()"},{"location":"reference/commands/misc/#mps_youtube.commands.misc.comments","text":"Receive use request to view comments. Source code in mps_youtube/commands/misc.py @command ( r 'c\\s?(\\d{1,4})' , 'c' ) def comments ( number ): \"\"\" Receive use request to view comments. \"\"\" if g . browse_mode == \"normal\" : item = g . model [ int ( number ) - 1 ] fetch_comments ( item ) else : g . content = generate_songlist_display () g . message = \"Comments only available for video items\"","title":"comments()"},{"location":"reference/commands/misc/#mps_youtube.commands.misc.fetch_comments","text":"Fetch comments for item using gdata. Source code in mps_youtube/commands/misc.py def fetch_comments ( item ): \"\"\" Fetch comments for item using gdata. \"\"\" # pylint: disable=R0912 # pylint: disable=R0914 ytid , title = item . ytid , item . title util . dbg ( \"Fetching comments for %s \" , c . c ( \"y\" , ytid )) screen . writestatus ( \"Fetching comments for %s \" % c . c ( \"y\" , title [: 55 ])) # qs = {'textFormat': 'plainText', # 'videoId': ytid, # 'maxResults': 50, # 'part': 'snippet'} # jsdata = None try : all_comments = pafy . get_comments ( ytid ) except Exception : raise # coms = [x.get('snippet', {}) for x in jsdata.get('items', [])] # skip blanks # coms = [x for x in coms # if len(x.get('topLevelComment', {}).get('snippet', {}).get('textDisplay', '').strip())] if not len ( all_comments ): g . message = \"No comments for %s \" % item . title [: 50 ] g . content = generate_songlist_display () return commentstext = '' for n , com in enumerate ( all_comments , 1 ): # snippet = com.get('topLevelComment', {}).get('snippet', {}) commentstext += _format_comment ( n , len ( all_comments ), com [ 'author' ][ 'name' ], com [ 'published' ], com [ 'content' ]) # todo fetch comment replies # if com.get('replyCount') > 0: # replies = _fetch_commentreplies(com.get('topLevelComment').get('id')) # for n, com in enumerate(reversed(replies), 1): # commentstext += _format_comment(com.get('snippet', {}), # n, len(replies), True) g . current_page = 0 g . content = content . StringContent ( commentstext )","title":"fetch_comments()"},{"location":"reference/commands/misc/#mps_youtube.commands.misc.quits","text":"Exit the program. Source code in mps_youtube/commands/misc.py @command ( r '(?:q|quit|exit)' , 'quit' , 'exit' ) def quits ( showlogo = True ): \"\"\" Exit the program. \"\"\" if has_readline and config . INPUT_HISTORY . get : readline . write_history_file ( g . READLINE_FILE ) util . dbg ( \"Saved history file\" ) cache . save () screen . clear () msg = logo ( c . r , version = __version__ ) if showlogo else \"\" msg += util . F ( \"exitmsg\" , 2 ) if config . CHECKUPDATE . get and showlogo : try : url = \"https://raw.githubusercontent.com/iamtalhaasghar/yewtube/master/setup.py\" v = urlopen ( url , timeout = 1 ) . read () . decode () v = re . search ( r '__version__\\s*=\\s*\"\\s*([\\d\\.]+)\\s*\"\\s*' , v , re . MULTILINE ) if v : v = v . group ( 1 ) if v > __version__ : msg += \" \\n\\n A newer version is available ( %s ). Use `help new` command to check what's changed. \\n \" % v except ( URLError , HTTPError , socket . timeout ): util . dbg ( \"check update timed out\" ) screen . msgexit ( msg )","title":"quits()"},{"location":"reference/commands/misc/#mps_youtube.commands.misc.recent_history","text":"Display the recent user's played songs Source code in mps_youtube/commands/misc.py @command ( r 'history recent' , 'history recent' ) def recent_history (): \"\"\" Display the recent user's played songs \"\"\" view_history ( duplicates = False )","title":"recent_history()"},{"location":"reference/commands/misc/#mps_youtube.commands.misc.show_help","text":"Print help message. Source code in mps_youtube/commands/misc.py @command ( r '(?:help|h)(?:\\s+([-_a-zA-Z]+))?' , 'help' ) def show_help ( choice ): \"\"\" Print help message. \"\"\" g . content = get_help ( choice )","title":"show_help()"},{"location":"reference/commands/misc/#mps_youtube.commands.misc.stream_info","text":"Get stream information. Source code in mps_youtube/commands/misc.py @command ( r 's\\s*(\\d{1,4})' , 's' ) def stream_info ( num ): \"\"\" Get stream information. \"\"\" if g . browse_mode == \"normal\" : g . content = logo ( c . b ) screen . update () screen . writestatus ( \"Fetching stream metadata..\" ) item = ( g . model [ int ( num ) - 1 ]) streams . get ( item ) p = util . get_pafy ( item ) setattr ( p , 'ytid' , p . videoid ) details = player . stream_details ( p )[ 1 ] screen . writestatus ( \"Fetched\" ) out = \" \\n\\n \" + c . ul + \"Stream Info\" + c . w + \" \\n \" out += \" \\n Extension : \" + details [ 'ext' ] out += \" \\n Size : \" + str ( details [ 'size' ]) out += \" \\n Quality : \" + details [ 'quality' ] out += \" \\n Raw bitrate : \" + str ( details [ 'rawbitrate' ]) out += \" \\n Media type : \" + details [ 'mtype' ] out += \" \\n Link : \" + details [ 'url' ] out += \" \\n\\n %s [ %s Press enter to go back %s ] %s \" % ( c . y , c . w , c . y , c . w ) g . content = out","title":"stream_info()"},{"location":"reference/commands/misc/#mps_youtube.commands.misc.video_info","text":"Get video information. Source code in mps_youtube/commands/misc.py @command ( r 'i\\s*(\\d{1,4})' , 'i' ) def video_info ( num ): \"\"\" Get video information. \"\"\" if g . browse_mode == \"ytpl\" : p = g . ytpls [ int ( num ) - 1 ] # fetch the playlist item as it has more metadata if p [ 'link' ] in g . pafy_pls : ytpl = g . pafy_pls [ p [ 'link' ]][ 0 ] else : g . content = logo ( col = c . g ) g . message = \"Fetching playlist info..\" screen . update () util . dbg ( \" %s Fetching playlist using pafy %s \" , c . y , c . w ) ytpl = pafy . get_playlist2 ( p [ 'link' ]) g . pafy_pls [ p [ 'link' ]] = ( ytpl , util . IterSlicer ( ytpl )) ytpl_desc = ytpl . description g . content = generate_songlist_display () created = util . yt_datetime_local ( p [ 'created' ]) updated = util . yt_datetime_local ( p [ 'updated' ]) out = c . ul + \"Playlist Info\" + c . w + \" \\n\\n \" out += p [ 'title' ] out += \" \\n \" + ytpl_desc out += ( \" \\n\\n Author : \" + p [ 'author' ]) out += \" \\n Size : \" + str ( p [ 'size' ]) + \" videos\" out += \" \\n Created : \" + created [ 1 ] + \" \" + created [ 2 ] out += \" \\n Updated : \" + updated [ 1 ] + \" \" + updated [ 2 ] out += \" \\n ID : \" + str ( p [ 'link' ]) out += ( \" \\n\\n %s [ %s Press enter to go back %s ] %s \" % ( c . y , c . w , c . y , c . w )) g . content = out elif g . browse_mode == \"normal\" : g . content = logo ( c . b ) screen . update () screen . writestatus ( \"Fetching video metadata..\" ) item = ( g . model [ int ( num ) - 1 ]) streams . get ( item ) p = pafy . get_video_info ( item . ytid ) #pub = datetime.strptime(str(p.published), \"%Y-%m-%d %H:%M:%SZ\") #pub = util.utc2local(pub) screen . writestatus ( \"Fetched\" ) out = c . ul + \"Video Info\" + c . w + \" \\n\\n \" out += p [ 'title' ] or \"\" out += \" \\n\\n Description: \\n\\n \" + str ( p . get ( 'description' , \"\" )) + \" \\n \" out += \" \\n Keywords: \" + str ( p [ 'keywords' ]) + \" \\n \" out += \" \\n Is Live Now : \" + str ( p [ 'isLiveNow' ]) out += \" \\n Duration : \" + str ( timedelta ( seconds = int ( p [ 'duration' ][ 'secondsText' ]))) out += \" \\n View count : \" + \" {:,} \" . format ( int ( p [ 'viewCount' ][ 'text' ])) out += \" \\n Author : \" + str ( p [ 'channel' ][ 'name' ] + ' ~ ' + p [ 'channel' ][ 'link' ]) out += \" \\n Published Date : \" + str ( p [ 'publishDate' ]) out += \" \\n Uploaded Date : \" + str ( p [ 'uploadDate' ]) out += \" \\n Rating : \" + str ( p [ 'averageRating' ]) out += \" \\n Likes : \" + \" {:,} \" . format ( p . get ( 'likes' , 0 )) out += \" \\n Dislikes : \" + \" {:,} \" . format ( p . get ( 'dislikes' , 0 )) out += \" \\n Category : \" + str ( p [ 'category' ]) out += \" \\n Family Safe : \" + str ( p [ 'isFamilySafe' ]) out += \" \\n Link : \" + str ( p [ 'link' ]) if config . SHOW_QRCODE . get : out += \" \\n \" + qrcode_display ( \"https://youtube.com/watch?v= %s \" % p . videoid ) out += \" \\n\\n %s [ %s Press enter to go back %s ] %s \" % ( c . y , c . w , c . y , c . w ) g . content = out","title":"video_info()"},{"location":"reference/commands/misc/#mps_youtube.commands.misc.view_history","text":"Display the user's play history Source code in mps_youtube/commands/misc.py @command ( r 'history' , 'history' ) def view_history ( duplicates = True ): \"\"\" Display the user's play history \"\"\" history = g . userhist . get ( 'history' ) #g.last_opened = \"\" try : hist_list = list ( reversed ( history . songs )) message = \"Viewing play history\" if not duplicates : # List unique elements and preserve order. seen = set () seen_add = seen . add # it makes calls to add() faster hist_list = [ x for x in hist_list if not ( x . ytid in seen or seen_add ( x . ytid ))] message = \"Viewing recent played songs\" paginatesongs ( hist_list ) g . message = message except AttributeError : g . content = logo ( c . r ) g . message = \"History empty\" if not config . HISTORY . get : g . message += \" \\t {1} History recording is currently off {0} \" . format ( c . w , c . y )","title":"view_history()"},{"location":"reference/commands/play/","text":"browser_play ( number ) \u00b6 Open a previously searched result in the browser. Source code in mps_youtube/commands/play.py @command ( r 'browserplay\\s(\\d{1,50})' , 'browserplay' ) def browser_play ( number ): \"\"\"Open a previously searched result in the browser.\"\"\" if ( len ( g . model ) == 0 ): g . message = c . r + \"No previous search.\" + c . w g . content = content . logo ( c . r ) return try : index = int ( number ) - 1 if ( 0 <= index < len ( g . model )): base_url = \"https://www.youtube.com/watch?v=\" video = g . model [ index ] url = base_url + video . ytid webbrowser . open ( url ) g . content = g . content or content . generate_songlist_display () else : g . message = c . r + \"Out of range.\" + c . w g . content = g . content or content . generate_songlist_display () return except ( HTTPError , URLError , Exception ) as e : g . message = c . r + str ( e ) + c . w g . content = g . content or content . generate_songlist_display () return play ( pre , choice , post = '' ) \u00b6 Play choice. Use repeat/random if appears in pre/post. Source code in mps_youtube/commands/play.py @command ( r '( %s {0,3})([-,\\d\\s\\[\\]]{1,250})\\s*( %s {0,3})$' % ( RS , RS )) def play ( pre , choice , post = \"\" ): \"\"\" Play choice. Use repeat/random if appears in pre/post. \"\"\" # pylint: disable=R0914 # too many local variables # Im just highjacking this if g.content is a # content.Content class if isinstance ( g . content , content . Content ): play_call = getattr ( g . content , \"_play\" , None ) if callable ( play_call ): play_call ( pre , choice , post ) return if g . browse_mode == \"ytpl\" : if choice . isdigit (): return plist ( g . ytpls [ int ( choice ) - 1 ][ 'link' ]) else : g . message = \"Invalid playlist selection: %s \" % c . y + choice + c . w g . content = content . generate_songlist_display () return if not g . model : g . message = c . r + \"There are no tracks to select\" + c . w g . content = g . content or content . generate_songlist_display () else : shuffle = \"shuffle\" in pre + post repeat = \"repeat\" in pre + post novid = \"-a\" in pre + post fs = \"-f\" in pre + post nofs = \"-w\" in pre + post forcevid = \"-v\" in pre + post if (( novid and fs ) or ( novid and nofs ) or ( nofs and fs ) or ( novid and forcevid )): raise IOError ( \"Conflicting override options specified\" ) override = False override = \"audio\" if novid else override override = \"fullscreen\" if fs else override override = \"window\" if nofs else override if ( not fs ) and ( not nofs ): override = \"forcevid\" if forcevid else override selection = util . parse_multi ( choice ) songlist = [ g . model [ x - 1 ] for x in selection ] # cache next result of displayed items # when selecting a single item if len ( songlist ) == 1 : chosen = selection [ 0 ] - 1 if len ( g . model ) > chosen + 1 : streams . preload ( g . model [ chosen + 1 ], override = override ) if g . scrobble : old_queue = g . scrobble_queue g . scrobble_queue = [ g . scrobble_queue [ x - 1 ] for x in selection ] try : if not config . PLAYER . get or not util . has_exefile ( config . PLAYER . get ): g . message = \"Player not configured! Enter %s set player <player_app> \" \\ \" %s to set a player\" % ( c . g , c . w ) return g . PLAYER_OBJ . play ( songlist , shuffle , repeat , override ) except KeyboardInterrupt : return finally : g . content = content . generate_songlist_display () if g . scrobble : g . scrobble_queue = old_queue if config . AUTOPLAY . get : related ( selection . pop ()) play ( pre , str ( random . randint ( 1 , 15 )), post = \"\" ) play_all ( pre , choice , post = '' ) \u00b6 Play all tracks in model (last displayed). shuffle/repeat if req'd. Source code in mps_youtube/commands/play.py @command ( r '( %s {0,3})(?:\\*|all)\\s*( %s {0,3})' % ( RS , RS )) def play_all ( pre , choice , post = \"\" ): \"\"\" Play all tracks in model (last displayed). shuffle/repeat if req'd.\"\"\" options = pre + choice + post play ( options , \"1-\" + str ( len ( g . model ))) play_pl ( name ) \u00b6 Play a playlist by name. Source code in mps_youtube/commands/play.py @command ( r 'play\\s+( %s |\\d+)' % WORD , 'play' ) def play_pl ( name ): \"\"\" Play a playlist by name. \"\"\" if name . isdigit (): name = int ( name ) name = sorted ( g . userpl )[ name - 1 ] saved = g . userpl . get ( name ) if not saved : name = util . get_near_name ( name , g . userpl ) saved = g . userpl . get ( name ) if saved : g . model . songs = list ( saved . songs ) play_all ( \"\" , \"\" , \"\" ) else : g . message = util . F ( \"pl not found\" ) % name g . content = content . playlists_display () play_url ( url , override ) \u00b6 Open and play a youtube video url. Source code in mps_youtube/commands/play.py @command ( r 'playurl\\s(.*[-_a-zA-Z0-9] {11} [^\\s]*)(\\s-(?:f|a|w))?' , 'playurl' ) def play_url ( url , override ): \"\"\" Open and play a youtube video url. \"\"\" override = override if override else \"_\" g . browse_mode = \"normal\" yt_url ( url , print_title = 1 ) if len ( g . model ) == 1 : play ( override , \"1\" , \"_\" ) if g . command_line : sys . exit ()","title":"play.py"},{"location":"reference/commands/play/#mps_youtube.commands.play.browser_play","text":"Open a previously searched result in the browser. Source code in mps_youtube/commands/play.py @command ( r 'browserplay\\s(\\d{1,50})' , 'browserplay' ) def browser_play ( number ): \"\"\"Open a previously searched result in the browser.\"\"\" if ( len ( g . model ) == 0 ): g . message = c . r + \"No previous search.\" + c . w g . content = content . logo ( c . r ) return try : index = int ( number ) - 1 if ( 0 <= index < len ( g . model )): base_url = \"https://www.youtube.com/watch?v=\" video = g . model [ index ] url = base_url + video . ytid webbrowser . open ( url ) g . content = g . content or content . generate_songlist_display () else : g . message = c . r + \"Out of range.\" + c . w g . content = g . content or content . generate_songlist_display () return except ( HTTPError , URLError , Exception ) as e : g . message = c . r + str ( e ) + c . w g . content = g . content or content . generate_songlist_display () return","title":"browser_play()"},{"location":"reference/commands/play/#mps_youtube.commands.play.play","text":"Play choice. Use repeat/random if appears in pre/post. Source code in mps_youtube/commands/play.py @command ( r '( %s {0,3})([-,\\d\\s\\[\\]]{1,250})\\s*( %s {0,3})$' % ( RS , RS )) def play ( pre , choice , post = \"\" ): \"\"\" Play choice. Use repeat/random if appears in pre/post. \"\"\" # pylint: disable=R0914 # too many local variables # Im just highjacking this if g.content is a # content.Content class if isinstance ( g . content , content . Content ): play_call = getattr ( g . content , \"_play\" , None ) if callable ( play_call ): play_call ( pre , choice , post ) return if g . browse_mode == \"ytpl\" : if choice . isdigit (): return plist ( g . ytpls [ int ( choice ) - 1 ][ 'link' ]) else : g . message = \"Invalid playlist selection: %s \" % c . y + choice + c . w g . content = content . generate_songlist_display () return if not g . model : g . message = c . r + \"There are no tracks to select\" + c . w g . content = g . content or content . generate_songlist_display () else : shuffle = \"shuffle\" in pre + post repeat = \"repeat\" in pre + post novid = \"-a\" in pre + post fs = \"-f\" in pre + post nofs = \"-w\" in pre + post forcevid = \"-v\" in pre + post if (( novid and fs ) or ( novid and nofs ) or ( nofs and fs ) or ( novid and forcevid )): raise IOError ( \"Conflicting override options specified\" ) override = False override = \"audio\" if novid else override override = \"fullscreen\" if fs else override override = \"window\" if nofs else override if ( not fs ) and ( not nofs ): override = \"forcevid\" if forcevid else override selection = util . parse_multi ( choice ) songlist = [ g . model [ x - 1 ] for x in selection ] # cache next result of displayed items # when selecting a single item if len ( songlist ) == 1 : chosen = selection [ 0 ] - 1 if len ( g . model ) > chosen + 1 : streams . preload ( g . model [ chosen + 1 ], override = override ) if g . scrobble : old_queue = g . scrobble_queue g . scrobble_queue = [ g . scrobble_queue [ x - 1 ] for x in selection ] try : if not config . PLAYER . get or not util . has_exefile ( config . PLAYER . get ): g . message = \"Player not configured! Enter %s set player <player_app> \" \\ \" %s to set a player\" % ( c . g , c . w ) return g . PLAYER_OBJ . play ( songlist , shuffle , repeat , override ) except KeyboardInterrupt : return finally : g . content = content . generate_songlist_display () if g . scrobble : g . scrobble_queue = old_queue if config . AUTOPLAY . get : related ( selection . pop ()) play ( pre , str ( random . randint ( 1 , 15 )), post = \"\" )","title":"play()"},{"location":"reference/commands/play/#mps_youtube.commands.play.play_all","text":"Play all tracks in model (last displayed). shuffle/repeat if req'd. Source code in mps_youtube/commands/play.py @command ( r '( %s {0,3})(?:\\*|all)\\s*( %s {0,3})' % ( RS , RS )) def play_all ( pre , choice , post = \"\" ): \"\"\" Play all tracks in model (last displayed). shuffle/repeat if req'd.\"\"\" options = pre + choice + post play ( options , \"1-\" + str ( len ( g . model )))","title":"play_all()"},{"location":"reference/commands/play/#mps_youtube.commands.play.play_pl","text":"Play a playlist by name. Source code in mps_youtube/commands/play.py @command ( r 'play\\s+( %s |\\d+)' % WORD , 'play' ) def play_pl ( name ): \"\"\" Play a playlist by name. \"\"\" if name . isdigit (): name = int ( name ) name = sorted ( g . userpl )[ name - 1 ] saved = g . userpl . get ( name ) if not saved : name = util . get_near_name ( name , g . userpl ) saved = g . userpl . get ( name ) if saved : g . model . songs = list ( saved . songs ) play_all ( \"\" , \"\" , \"\" ) else : g . message = util . F ( \"pl not found\" ) % name g . content = content . playlists_display ()","title":"play_pl()"},{"location":"reference/commands/play/#mps_youtube.commands.play.play_url","text":"Open and play a youtube video url. Source code in mps_youtube/commands/play.py @command ( r 'playurl\\s(.*[-_a-zA-Z0-9] {11} [^\\s]*)(\\s-(?:f|a|w))?' , 'playurl' ) def play_url ( url , override ): \"\"\" Open and play a youtube video url. \"\"\" override = override if override else \"_\" g . browse_mode = \"normal\" yt_url ( url , print_title = 1 ) if len ( g . model ) == 1 : play ( override , \"1\" , \"_\" ) if g . command_line : sys . exit ()","title":"play_url()"},{"location":"reference/commands/search/","text":"cache_userdata ( userterm , username , channel_id ) \u00b6 Cache user name and channel id tuple Source code in mps_youtube/commands/search.py def cache_userdata ( userterm , username , channel_id ): \"\"\" Cache user name and channel id tuple \"\"\" userterm = '' . join ([ t . strip () . lower () for t in userterm . split ( ' ' )]) g . username_query_cache [ userterm ] = ( username , channel_id ) util . dbg ( 'Cache data for username search query \" {} \": {} ( {} )' . format ( userterm , username , channel_id )) while len ( g . username_query_cache ) > 300 : g . username_query_cache . popitem ( last = False ) return ( username , channel_id ) channelfromname ( user ) \u00b6 Query channel id from username. Source code in mps_youtube/commands/search.py def channelfromname ( user ): \"\"\" Query channel id from username. \"\"\" cached = userdata_cached ( user ) if cached : return cached try : channel_id , channel_name = pafy . channel_id_from_name ( user ) return cache_userdata ( user , channel_name , channel_id ) except Exception as e : import traceback traceback . print_exception ( type ( e ), e , e . __traceback__ ) g . message = \"Could not retrieve information for user {} \\n {} \" . format ( c . y + user + c . w , e ) util . dbg ( 'Error during channel request for user {} : \\n {} ' . format ( user , e )) # at this point, we know the channel id associated to a user name return None get_pl_from_json ( pldata ) \u00b6 Process json playlist data. Source code in mps_youtube/commands/search.py def get_pl_from_json ( pldata ): \"\"\" Process json playlist data. \"\"\" try : items = pldata except KeyError : items = [] results = [] for item in items : results . append ( dict ( link = item [ \"id\" ], size = item [ \"videoCount\" ], title = item [ \"title\" ], author = item [ 'channel' ][ \"name\" ], created = item . get ( \"publishedAt\" ), updated = item . get ( 'publishedAt' ), #XXX Not available in API? description = item . get ( \"description\" ))) return results get_track_id_from_json ( item ) \u00b6 Try to extract video Id from various response types Source code in mps_youtube/commands/search.py def get_track_id_from_json ( item ): \"\"\" Try to extract video Id from various response types \"\"\" fields = [ 'contentDetails/videoId' , 'snippet/resourceId/videoId' , 'id/videoId' , 'id' ] for field in fields : node = item for p in field . split ( '/' ): if node and isinstance ( node , dict ): node = node . get ( p ) if node : return node return '' get_tracks_from_json ( jsons ) \u00b6 Get search results from API response Source code in mps_youtube/commands/search.py def get_tracks_from_json ( jsons ): \"\"\" Get search results from API response \"\"\" if len ( jsons ) == 0 : util . dbg ( \"got unexpected data or no search results\" ) return () # populate list of video objects songs = [] for item in jsons : try : ytid = get_track_id_from_json ( item ) duration = util . parse_video_length ( item . get ( 'duration' )) #stats = item.get('statistics', {}) #snippet = item.get('snippet', {}) title = item . get ( 'title' , '' ) . strip () # instantiate video representation in local model cursong = Video ( ytid = ytid , title = title , length = duration ) dislike_data = { 'likes' : 0 , 'dislikes' : 0 , 'rating' : 0 } #pafy.return_dislikes(ytid) likes = int ( dislike_data [ 'likes' ]) dislikes = int ( dislike_data [ 'dislikes' ]) # this is a very poor attempt to calculate a rating value rating = int ( dislike_data [ 'rating' ]) #5.*likes/(likes+dislikes) if (likes+dislikes) > 0 else 0 category = '?' #snippet.get('categoryId') publishedlocaldatetime = item . get ( 'publishedTime' , '?' ) #util.yt_datetime_local(snippet.get('publishedAt', '')) # cache video information in custom global variable store g . meta [ ytid ] = dict ( # tries to get localized title first, fallback to normal title title = title , length = str ( util . fmt_time ( cursong . length )), rating = rating , #str('{}'.format(rating))[:4].ljust(4, \"0\"), uploader = item [ 'channel' ][ 'id' ], uploaderName = item [ 'channel' ][ 'name' ], category = category , aspect = \"custom\" , #XXX uploaded = publishedlocaldatetime , #publishedlocaldatetime[1] if publishedlocaldatetime is not None else None, uploadedTime = publishedlocaldatetime , #,publishedlocaldatetime[2] if publishedlocaldatetime is not None else None, likes = str ( num_repr ( likes )), dislikes = str ( num_repr ( dislikes )), commentCount = '?' , #str(num_repr(int(stats.get('commentCount', 0)))), viewCount = item [ 'viewCount' ][ 'text' ] if 'viewCount' in item . keys () else '?' ) #str(num_repr(int(stats.get('viewCount', 0))))) songs . append ( cursong ) except Exception as e : import traceback traceback . print_exception ( type ( e ), e , e . __traceback__ ) input ( 'Press any key to continue...' ) util . dbg ( json . dumps ( item , indent = 2 )) util . dbg ( 'Error during metadata extraction/instantiation of ' + 'search result {} \\n {} ' . format ( ytid , e )) # return video objects return songs mix ( num ) \u00b6 Retrieves the YouTube mix for the selected video. Source code in mps_youtube/commands/search.py @command ( r 'mix\\s*(\\d{1,4})' , 'mix' ) def mix ( num ): \"\"\" Retrieves the YouTube mix for the selected video. \"\"\" g . content = g . content or content . generate_songlist_display () if g . browse_mode != \"normal\" : g . message = util . F ( 'mix only videos' ) else : item = ( g . model [ int ( num ) - 1 ]) if item is None : g . message = util . F ( 'invalid item' ) return item = util . get_pafy ( item ) # Mix playlists are made up of 'RD' + video_id try : plist ( \"RD\" + item . videoid ) except OSError : g . message = util . F ( 'no mix' ) num_repr ( num ) \u00b6 Return up to four digit string representation of a number, eg 2.6m. Source code in mps_youtube/commands/search.py def num_repr ( num ): \"\"\" Return up to four digit string representation of a number, eg 2.6m. \"\"\" if num <= 9999 : return str ( num ) def digit_count ( x ): \"\"\" Return number of digits. \"\"\" return int ( math . floor ( math . log10 ( x )) + 1 ) digits = digit_count ( num ) sig = 3 if digits % 3 == 0 else 2 rounded = int ( round ( num , int ( sig - digits ))) digits = digit_count ( rounded ) suffix = \"_kmBTqXYX\" [( digits - 1 ) // 3 ] front = 3 if digits % 3 == 0 else digits % 3 if not front == 1 : return str ( rounded )[ 0 : front ] + suffix return str ( rounded )[ 0 ] + \".\" + str ( rounded )[ 1 ] + suffix pl_search ( term , page = 0 , splash = True , is_user = False ) \u00b6 Search for YouTube playlists. term can be query str or dict indicating user playlist search. Source code in mps_youtube/commands/search.py @command ( r '(?:\\.\\.|\\/\\/|pls(?:earch)?\\s)\\s*(.*)' , 'plsearch' ) def pl_search ( term , page = 0 , splash = True , is_user = False ): \"\"\" Search for YouTube playlists. term can be query str or dict indicating user playlist search. \"\"\" if not term or len ( term ) < 2 : g . message = c . r + \"Not enough input\" + c . w g . content = content . generate_songlist_display () return if splash : g . content = content . logo ( c . g ) prog = \"user: \" + term if is_user else term g . message = \"Searching playlists for %s \" % c . y + prog + c . w screen . update () if is_user : ret = channelfromname ( term ) if not ret : # Error return user , channel_id = ret else : # playlist search is done with the above url and param type=playlist logging . info ( \"playlist search for %s \" , prog ) # qs = generate_search_qs(term) # qs['pageToken'] = token(page) # qs['type'] = 'playlist' # if 'videoCategoryId' in qs: # del qs['videoCategoryId'] # Incompatable with type=playlist pldata = pafy . playlist_search ( term ) #id_list = [i.get('id', {}) for i in pldata] result_count = len ( pldata ) #todo: what is the purpose of this code? #qs = {'part': 'contentDetails,snippet','maxResults': 50} if is_user : if page : pass #qs['pageToken'] = token(page) pass #qs['channelId'] = channel_id else : pass #qs['id'] = ','.join(id_list) pldata = pafy . playlist_search ( term ) playlists = get_pl_from_json ( pldata )[: util . getxy () . max_results ] # if is_user: # result_count = pldata['pageInfo']['totalResults'] if playlists : g . last_search_query = ( pl_search , { \"term\" : term , \"is_user\" : is_user }) g . browse_mode = \"ytpl\" g . current_page = page g . result_count = result_count g . ytpls = playlists g . message = \"Playlist results for %s \" % c . y + prog + c . w g . content = content . generate_playlist_display () else : g . message = \"No playlists found for: %s \" % c . y + prog + c . w g . current_page = 0 g . content = content . generate_songlist_display ( zeromsg = g . message ) related ( num ) \u00b6 Show videos related to to vid num. Source code in mps_youtube/commands/search.py @command ( r 'r\\s?(\\d{1,4})' , 'r' ) def related ( num ): \"\"\" Show videos related to to vid num. \"\"\" if g . browse_mode != \"normal\" : g . message = \"Related items must refer to a specific video item\" g . message = c . y + g . message + c . w g . content = content . generate_songlist_display () return g . current_page = 0 item = g . model [ int ( num ) - 1 ] related_search ( item ) related_search ( vitem ) \u00b6 Fetch videos related to vitem vitem = {'description': str, 'length': int, 'title': str, 'ytid': str} Source code in mps_youtube/commands/search.py def related_search ( vitem ): \"\"\" Fetch videos related to vitem vitem = {'description': str, 'length': int, 'title': str, 'ytid': str} \"\"\" t = vitem . title ttitle = t [: 48 ] . strip () + \"..\" if len ( t ) > 49 else t msg = \"Videos related to %s%s%s \" % ( c . y , ttitle , c . w ) failmsg = \"Related to %s%s%s not found\" % ( c . y , vitem . ytid , c . w ) # todo: implement realted search in pafy #_search(ttitle, vitem.title, msg, failmsg) search ( term ) \u00b6 Perform search. Source code in mps_youtube/commands/search.py @command ( r '(?:search|\\.|/)\\s*([^./].{1,500})' , 'search' ) def search ( term ): \"\"\" Perform search. \"\"\" try : # TODO make use of unknowns args , unknown = parser . parse_known_args ( term . split ()) video_duration = args . duration if args . duration else 'any' if args . category : if not args . category [ 0 ] . isdigit (): args . category = g . categories . get ( args . category [ 0 ]) else : args . category = \"\" . join ( args . category ) after = args . after term = ' ' . join ( args . search ) except SystemExit : # <------ argsparse calls exit() g . message = c . b + \"Bad syntax. Enter h for help\" + c . w return if not term or len ( term ) < 2 : g . message = c . r + \"Not enough input\" + c . w g . content = content . generate_songlist_display () return logging . info ( \"search for %s \" , term ) #query = generate_search_qs(term, videoDuration=video_duration, after=after, category=args.category, is_live=args.live) msg = \"Search results for %s%s%s \" % ( c . y , term , c . w ) failmsg = \"Found nothing for %s%s%s \" % ( c . y , term , c . w ) wdata = pafy . search_videos ( term , int ( config . PAGES . get )) _display_search_results ( term , wdata , msg , failmsg ) token ( page ) \u00b6 Returns a page token for a given start index. Source code in mps_youtube/commands/search.py def token ( page ): \"\"\" Returns a page token for a given start index. \"\"\" index = ( page or 0 ) * util . getxy () . max_results k = index // 128 - 1 index -= 128 * k f = [ 8 , index ] if k > 0 or index > 127 : f . append ( k + 1 ) f += [ 16 , 0 ] b64 = base64 . b64encode ( bytes ( f )) . decode ( 'utf8' ) return b64 . strip ( '=' ) user_more ( num ) \u00b6 Show more videos from user of vid num. Source code in mps_youtube/commands/search.py @command ( r 'u\\s?([\\d]{1,4})' , 'u' ) def user_more ( num ): \"\"\" Show more videos from user of vid num. \"\"\" if g . browse_mode != \"normal\" : g . message = \"User uploads must refer to a specific video item\" g . message = c . y + g . message + c . w g . content = content . generate_songlist_display () return g . current_page = 0 item = g . model [ int ( num ) - 1 ] #TODO: Cleaner way of doing this? if item . ytid in g . meta : channel_id = g . meta . get ( item . ytid , {}) . get ( 'uploader' ) user = g . meta . get ( item . ytid , {}) . get ( 'uploaderName' ) else : paf = util . get_pafy ( item ) user , channel_id = channelfromname ( paf . author ) usersearch_id ( user , channel_id , '' ) user_pls ( user ) \u00b6 Retrieve user playlists. Source code in mps_youtube/commands/search.py @command ( r 'u(?:ser)?pl\\s(.*)' , 'userpl' , 'upl' ) def user_pls ( user ): \"\"\" Retrieve user playlists. \"\"\" return usersearch_id ( user , pafy . channel_id_from_name ( user )[ 0 ], '' ) #pl_search(user, is_user=True) userdata_cached ( userterm ) \u00b6 Check if user name search term found in cache Source code in mps_youtube/commands/search.py def userdata_cached ( userterm ): \"\"\" Check if user name search term found in cache \"\"\" userterm = '' . join ([ t . strip () . lower () for t in userterm . split ( ' ' )]) return g . username_query_cache . get ( userterm ) usersearch ( q_user , identify = 'forUsername' ) \u00b6 Fetch uploads by a YouTube user. Source code in mps_youtube/commands/search.py @command ( r 'user\\s+(.+)' , 'user' ) def usersearch ( q_user , identify = 'forUsername' ): \"\"\" Fetch uploads by a YouTube user. \"\"\" user , _ , term = ( x . strip () for x in q_user . partition ( \"/\" )) if identify == 'forUsername' : ret = channelfromname ( user ) if not ret : # Error return user , channel_id = ret else : channel_id = user # at this point, we know the channel id associated to a user name usersearch_id ( user , channel_id , term ) usersearch_id ( user , channel_id , term ) \u00b6 Performs a search within a user's (i.e. a channel's) uploads for an optional search term with the user (i.e. the channel) identified by its ID Source code in mps_youtube/commands/search.py def usersearch_id ( user , channel_id , term ): \"\"\" Performs a search within a user's (i.e. a channel's) uploads for an optional search term with the user (i.e. the channel) identified by its ID \"\"\" #query = generate_search_qs(term) aliases = dict ( views = 'viewCount' ) # The value of the config item is 'views' not 'viewCount' if config . USER_ORDER . get : pass #query['order'] = aliases.get(config.USER_ORDER.get, # config.USER_ORDER.get) #query['channelId'] = channel_id termuser = tuple ([ c . y + x + c . w for x in ( term , user )]) if term : msg = \"Results for {1}{3}{0} (by {2}{4}{0} )\" progtext = \" %s by %s \" % termuser failmsg = \"No matching results for %s (by %s )\" % termuser else : msg = \"Video uploads by {2}{4}{0} \" progtext = termuser [ 1 ] if config . SEARCH_MUSIC : failmsg = \"\"\"User %s not found or has no videos in the Music category. Use 'set search_music False' to show results not in the Music category.\"\"\" % termuser [ 1 ] else : failmsg = \"User %s not found or has no videos.\" % termuser [ 1 ] msg = str ( msg ) . format ( c . w , c . y , c . y , term , user ) results = pafy . all_videos_from_channel ( channel_id ) _display_search_results ( progtext , results , msg , failmsg ) yt_url ( url , print_title = 0 ) \u00b6 Acess videos by urls. Source code in mps_youtube/commands/search.py @command ( r 'url\\s(.*[-_a-zA-Z0-9] {11} .*)' , 'url' ) def yt_url ( url , print_title = 0 ): \"\"\" Acess videos by urls. \"\"\" url_list = url . split () g . model . songs = [] for u in url_list : try : p = pafy . get_video_info ( url . split ( '?v=' )[ 1 ]) #util.get_pafy(u) except ( IOError , ValueError ) as e : g . message = c . r + str ( e ) + c . w g . content = g . content or content . generate_songlist_display ( zeromsg = g . message ) return g . browse_mode = \"normal\" v = Video ( p [ 'id' ], p [ 'title' ], int ( p [ 'duration' ][ 'secondsText' ])) g . model . songs . append ( v ) if not g . command_line : g . content = content . generate_songlist_display () if print_title : util . xprint ( v . title ) yt_url_file ( file_name ) \u00b6 Access a list of urls in a text file Source code in mps_youtube/commands/search.py @command ( r 'url_file\\s(\\S+)' , 'url_file' ) def yt_url_file ( file_name ): \"\"\" Access a list of urls in a text file \"\"\" #Open and read the file try : with open ( file_name , \"r\" ) as fo : output = ' ' . join ([ line . strip () for line in fo if line . strip ()]) except ( IOError ): g . message = c . r + 'Error while opening the file, check the validity of the path' + c . w g . content = g . content or content . generate_songlist_display ( zeromsg = g . message ) return #Finally pass the input to yt_url yt_url ( output )","title":"search.py"},{"location":"reference/commands/search/#mps_youtube.commands.search.cache_userdata","text":"Cache user name and channel id tuple Source code in mps_youtube/commands/search.py def cache_userdata ( userterm , username , channel_id ): \"\"\" Cache user name and channel id tuple \"\"\" userterm = '' . join ([ t . strip () . lower () for t in userterm . split ( ' ' )]) g . username_query_cache [ userterm ] = ( username , channel_id ) util . dbg ( 'Cache data for username search query \" {} \": {} ( {} )' . format ( userterm , username , channel_id )) while len ( g . username_query_cache ) > 300 : g . username_query_cache . popitem ( last = False ) return ( username , channel_id )","title":"cache_userdata()"},{"location":"reference/commands/search/#mps_youtube.commands.search.channelfromname","text":"Query channel id from username. Source code in mps_youtube/commands/search.py def channelfromname ( user ): \"\"\" Query channel id from username. \"\"\" cached = userdata_cached ( user ) if cached : return cached try : channel_id , channel_name = pafy . channel_id_from_name ( user ) return cache_userdata ( user , channel_name , channel_id ) except Exception as e : import traceback traceback . print_exception ( type ( e ), e , e . __traceback__ ) g . message = \"Could not retrieve information for user {} \\n {} \" . format ( c . y + user + c . w , e ) util . dbg ( 'Error during channel request for user {} : \\n {} ' . format ( user , e )) # at this point, we know the channel id associated to a user name return None","title":"channelfromname()"},{"location":"reference/commands/search/#mps_youtube.commands.search.get_pl_from_json","text":"Process json playlist data. Source code in mps_youtube/commands/search.py def get_pl_from_json ( pldata ): \"\"\" Process json playlist data. \"\"\" try : items = pldata except KeyError : items = [] results = [] for item in items : results . append ( dict ( link = item [ \"id\" ], size = item [ \"videoCount\" ], title = item [ \"title\" ], author = item [ 'channel' ][ \"name\" ], created = item . get ( \"publishedAt\" ), updated = item . get ( 'publishedAt' ), #XXX Not available in API? description = item . get ( \"description\" ))) return results","title":"get_pl_from_json()"},{"location":"reference/commands/search/#mps_youtube.commands.search.get_track_id_from_json","text":"Try to extract video Id from various response types Source code in mps_youtube/commands/search.py def get_track_id_from_json ( item ): \"\"\" Try to extract video Id from various response types \"\"\" fields = [ 'contentDetails/videoId' , 'snippet/resourceId/videoId' , 'id/videoId' , 'id' ] for field in fields : node = item for p in field . split ( '/' ): if node and isinstance ( node , dict ): node = node . get ( p ) if node : return node return ''","title":"get_track_id_from_json()"},{"location":"reference/commands/search/#mps_youtube.commands.search.get_tracks_from_json","text":"Get search results from API response Source code in mps_youtube/commands/search.py def get_tracks_from_json ( jsons ): \"\"\" Get search results from API response \"\"\" if len ( jsons ) == 0 : util . dbg ( \"got unexpected data or no search results\" ) return () # populate list of video objects songs = [] for item in jsons : try : ytid = get_track_id_from_json ( item ) duration = util . parse_video_length ( item . get ( 'duration' )) #stats = item.get('statistics', {}) #snippet = item.get('snippet', {}) title = item . get ( 'title' , '' ) . strip () # instantiate video representation in local model cursong = Video ( ytid = ytid , title = title , length = duration ) dislike_data = { 'likes' : 0 , 'dislikes' : 0 , 'rating' : 0 } #pafy.return_dislikes(ytid) likes = int ( dislike_data [ 'likes' ]) dislikes = int ( dislike_data [ 'dislikes' ]) # this is a very poor attempt to calculate a rating value rating = int ( dislike_data [ 'rating' ]) #5.*likes/(likes+dislikes) if (likes+dislikes) > 0 else 0 category = '?' #snippet.get('categoryId') publishedlocaldatetime = item . get ( 'publishedTime' , '?' ) #util.yt_datetime_local(snippet.get('publishedAt', '')) # cache video information in custom global variable store g . meta [ ytid ] = dict ( # tries to get localized title first, fallback to normal title title = title , length = str ( util . fmt_time ( cursong . length )), rating = rating , #str('{}'.format(rating))[:4].ljust(4, \"0\"), uploader = item [ 'channel' ][ 'id' ], uploaderName = item [ 'channel' ][ 'name' ], category = category , aspect = \"custom\" , #XXX uploaded = publishedlocaldatetime , #publishedlocaldatetime[1] if publishedlocaldatetime is not None else None, uploadedTime = publishedlocaldatetime , #,publishedlocaldatetime[2] if publishedlocaldatetime is not None else None, likes = str ( num_repr ( likes )), dislikes = str ( num_repr ( dislikes )), commentCount = '?' , #str(num_repr(int(stats.get('commentCount', 0)))), viewCount = item [ 'viewCount' ][ 'text' ] if 'viewCount' in item . keys () else '?' ) #str(num_repr(int(stats.get('viewCount', 0))))) songs . append ( cursong ) except Exception as e : import traceback traceback . print_exception ( type ( e ), e , e . __traceback__ ) input ( 'Press any key to continue...' ) util . dbg ( json . dumps ( item , indent = 2 )) util . dbg ( 'Error during metadata extraction/instantiation of ' + 'search result {} \\n {} ' . format ( ytid , e )) # return video objects return songs","title":"get_tracks_from_json()"},{"location":"reference/commands/search/#mps_youtube.commands.search.mix","text":"Retrieves the YouTube mix for the selected video. Source code in mps_youtube/commands/search.py @command ( r 'mix\\s*(\\d{1,4})' , 'mix' ) def mix ( num ): \"\"\" Retrieves the YouTube mix for the selected video. \"\"\" g . content = g . content or content . generate_songlist_display () if g . browse_mode != \"normal\" : g . message = util . F ( 'mix only videos' ) else : item = ( g . model [ int ( num ) - 1 ]) if item is None : g . message = util . F ( 'invalid item' ) return item = util . get_pafy ( item ) # Mix playlists are made up of 'RD' + video_id try : plist ( \"RD\" + item . videoid ) except OSError : g . message = util . F ( 'no mix' )","title":"mix()"},{"location":"reference/commands/search/#mps_youtube.commands.search.num_repr","text":"Return up to four digit string representation of a number, eg 2.6m. Source code in mps_youtube/commands/search.py def num_repr ( num ): \"\"\" Return up to four digit string representation of a number, eg 2.6m. \"\"\" if num <= 9999 : return str ( num ) def digit_count ( x ): \"\"\" Return number of digits. \"\"\" return int ( math . floor ( math . log10 ( x )) + 1 ) digits = digit_count ( num ) sig = 3 if digits % 3 == 0 else 2 rounded = int ( round ( num , int ( sig - digits ))) digits = digit_count ( rounded ) suffix = \"_kmBTqXYX\" [( digits - 1 ) // 3 ] front = 3 if digits % 3 == 0 else digits % 3 if not front == 1 : return str ( rounded )[ 0 : front ] + suffix return str ( rounded )[ 0 ] + \".\" + str ( rounded )[ 1 ] + suffix","title":"num_repr()"},{"location":"reference/commands/search/#mps_youtube.commands.search.pl_search","text":"Search for YouTube playlists. term can be query str or dict indicating user playlist search. Source code in mps_youtube/commands/search.py @command ( r '(?:\\.\\.|\\/\\/|pls(?:earch)?\\s)\\s*(.*)' , 'plsearch' ) def pl_search ( term , page = 0 , splash = True , is_user = False ): \"\"\" Search for YouTube playlists. term can be query str or dict indicating user playlist search. \"\"\" if not term or len ( term ) < 2 : g . message = c . r + \"Not enough input\" + c . w g . content = content . generate_songlist_display () return if splash : g . content = content . logo ( c . g ) prog = \"user: \" + term if is_user else term g . message = \"Searching playlists for %s \" % c . y + prog + c . w screen . update () if is_user : ret = channelfromname ( term ) if not ret : # Error return user , channel_id = ret else : # playlist search is done with the above url and param type=playlist logging . info ( \"playlist search for %s \" , prog ) # qs = generate_search_qs(term) # qs['pageToken'] = token(page) # qs['type'] = 'playlist' # if 'videoCategoryId' in qs: # del qs['videoCategoryId'] # Incompatable with type=playlist pldata = pafy . playlist_search ( term ) #id_list = [i.get('id', {}) for i in pldata] result_count = len ( pldata ) #todo: what is the purpose of this code? #qs = {'part': 'contentDetails,snippet','maxResults': 50} if is_user : if page : pass #qs['pageToken'] = token(page) pass #qs['channelId'] = channel_id else : pass #qs['id'] = ','.join(id_list) pldata = pafy . playlist_search ( term ) playlists = get_pl_from_json ( pldata )[: util . getxy () . max_results ] # if is_user: # result_count = pldata['pageInfo']['totalResults'] if playlists : g . last_search_query = ( pl_search , { \"term\" : term , \"is_user\" : is_user }) g . browse_mode = \"ytpl\" g . current_page = page g . result_count = result_count g . ytpls = playlists g . message = \"Playlist results for %s \" % c . y + prog + c . w g . content = content . generate_playlist_display () else : g . message = \"No playlists found for: %s \" % c . y + prog + c . w g . current_page = 0 g . content = content . generate_songlist_display ( zeromsg = g . message )","title":"pl_search()"},{"location":"reference/commands/search/#mps_youtube.commands.search.related","text":"Show videos related to to vid num. Source code in mps_youtube/commands/search.py @command ( r 'r\\s?(\\d{1,4})' , 'r' ) def related ( num ): \"\"\" Show videos related to to vid num. \"\"\" if g . browse_mode != \"normal\" : g . message = \"Related items must refer to a specific video item\" g . message = c . y + g . message + c . w g . content = content . generate_songlist_display () return g . current_page = 0 item = g . model [ int ( num ) - 1 ] related_search ( item )","title":"related()"},{"location":"reference/commands/search/#mps_youtube.commands.search.related_search","text":"Fetch videos related to vitem vitem = {'description': str, 'length': int, 'title': str, 'ytid': str} Source code in mps_youtube/commands/search.py def related_search ( vitem ): \"\"\" Fetch videos related to vitem vitem = {'description': str, 'length': int, 'title': str, 'ytid': str} \"\"\" t = vitem . title ttitle = t [: 48 ] . strip () + \"..\" if len ( t ) > 49 else t msg = \"Videos related to %s%s%s \" % ( c . y , ttitle , c . w ) failmsg = \"Related to %s%s%s not found\" % ( c . y , vitem . ytid , c . w ) # todo: implement realted search in pafy #_search(ttitle, vitem.title, msg, failmsg)","title":"related_search()"},{"location":"reference/commands/search/#mps_youtube.commands.search.search","text":"Perform search. Source code in mps_youtube/commands/search.py @command ( r '(?:search|\\.|/)\\s*([^./].{1,500})' , 'search' ) def search ( term ): \"\"\" Perform search. \"\"\" try : # TODO make use of unknowns args , unknown = parser . parse_known_args ( term . split ()) video_duration = args . duration if args . duration else 'any' if args . category : if not args . category [ 0 ] . isdigit (): args . category = g . categories . get ( args . category [ 0 ]) else : args . category = \"\" . join ( args . category ) after = args . after term = ' ' . join ( args . search ) except SystemExit : # <------ argsparse calls exit() g . message = c . b + \"Bad syntax. Enter h for help\" + c . w return if not term or len ( term ) < 2 : g . message = c . r + \"Not enough input\" + c . w g . content = content . generate_songlist_display () return logging . info ( \"search for %s \" , term ) #query = generate_search_qs(term, videoDuration=video_duration, after=after, category=args.category, is_live=args.live) msg = \"Search results for %s%s%s \" % ( c . y , term , c . w ) failmsg = \"Found nothing for %s%s%s \" % ( c . y , term , c . w ) wdata = pafy . search_videos ( term , int ( config . PAGES . get )) _display_search_results ( term , wdata , msg , failmsg )","title":"search()"},{"location":"reference/commands/search/#mps_youtube.commands.search.token","text":"Returns a page token for a given start index. Source code in mps_youtube/commands/search.py def token ( page ): \"\"\" Returns a page token for a given start index. \"\"\" index = ( page or 0 ) * util . getxy () . max_results k = index // 128 - 1 index -= 128 * k f = [ 8 , index ] if k > 0 or index > 127 : f . append ( k + 1 ) f += [ 16 , 0 ] b64 = base64 . b64encode ( bytes ( f )) . decode ( 'utf8' ) return b64 . strip ( '=' )","title":"token()"},{"location":"reference/commands/search/#mps_youtube.commands.search.user_more","text":"Show more videos from user of vid num. Source code in mps_youtube/commands/search.py @command ( r 'u\\s?([\\d]{1,4})' , 'u' ) def user_more ( num ): \"\"\" Show more videos from user of vid num. \"\"\" if g . browse_mode != \"normal\" : g . message = \"User uploads must refer to a specific video item\" g . message = c . y + g . message + c . w g . content = content . generate_songlist_display () return g . current_page = 0 item = g . model [ int ( num ) - 1 ] #TODO: Cleaner way of doing this? if item . ytid in g . meta : channel_id = g . meta . get ( item . ytid , {}) . get ( 'uploader' ) user = g . meta . get ( item . ytid , {}) . get ( 'uploaderName' ) else : paf = util . get_pafy ( item ) user , channel_id = channelfromname ( paf . author ) usersearch_id ( user , channel_id , '' )","title":"user_more()"},{"location":"reference/commands/search/#mps_youtube.commands.search.user_pls","text":"Retrieve user playlists. Source code in mps_youtube/commands/search.py @command ( r 'u(?:ser)?pl\\s(.*)' , 'userpl' , 'upl' ) def user_pls ( user ): \"\"\" Retrieve user playlists. \"\"\" return usersearch_id ( user , pafy . channel_id_from_name ( user )[ 0 ], '' ) #pl_search(user, is_user=True)","title":"user_pls()"},{"location":"reference/commands/search/#mps_youtube.commands.search.userdata_cached","text":"Check if user name search term found in cache Source code in mps_youtube/commands/search.py def userdata_cached ( userterm ): \"\"\" Check if user name search term found in cache \"\"\" userterm = '' . join ([ t . strip () . lower () for t in userterm . split ( ' ' )]) return g . username_query_cache . get ( userterm )","title":"userdata_cached()"},{"location":"reference/commands/search/#mps_youtube.commands.search.usersearch","text":"Fetch uploads by a YouTube user. Source code in mps_youtube/commands/search.py @command ( r 'user\\s+(.+)' , 'user' ) def usersearch ( q_user , identify = 'forUsername' ): \"\"\" Fetch uploads by a YouTube user. \"\"\" user , _ , term = ( x . strip () for x in q_user . partition ( \"/\" )) if identify == 'forUsername' : ret = channelfromname ( user ) if not ret : # Error return user , channel_id = ret else : channel_id = user # at this point, we know the channel id associated to a user name usersearch_id ( user , channel_id , term )","title":"usersearch()"},{"location":"reference/commands/search/#mps_youtube.commands.search.usersearch_id","text":"Performs a search within a user's (i.e. a channel's) uploads for an optional search term with the user (i.e. the channel) identified by its ID Source code in mps_youtube/commands/search.py def usersearch_id ( user , channel_id , term ): \"\"\" Performs a search within a user's (i.e. a channel's) uploads for an optional search term with the user (i.e. the channel) identified by its ID \"\"\" #query = generate_search_qs(term) aliases = dict ( views = 'viewCount' ) # The value of the config item is 'views' not 'viewCount' if config . USER_ORDER . get : pass #query['order'] = aliases.get(config.USER_ORDER.get, # config.USER_ORDER.get) #query['channelId'] = channel_id termuser = tuple ([ c . y + x + c . w for x in ( term , user )]) if term : msg = \"Results for {1}{3}{0} (by {2}{4}{0} )\" progtext = \" %s by %s \" % termuser failmsg = \"No matching results for %s (by %s )\" % termuser else : msg = \"Video uploads by {2}{4}{0} \" progtext = termuser [ 1 ] if config . SEARCH_MUSIC : failmsg = \"\"\"User %s not found or has no videos in the Music category. Use 'set search_music False' to show results not in the Music category.\"\"\" % termuser [ 1 ] else : failmsg = \"User %s not found or has no videos.\" % termuser [ 1 ] msg = str ( msg ) . format ( c . w , c . y , c . y , term , user ) results = pafy . all_videos_from_channel ( channel_id ) _display_search_results ( progtext , results , msg , failmsg )","title":"usersearch_id()"},{"location":"reference/commands/search/#mps_youtube.commands.search.yt_url","text":"Acess videos by urls. Source code in mps_youtube/commands/search.py @command ( r 'url\\s(.*[-_a-zA-Z0-9] {11} .*)' , 'url' ) def yt_url ( url , print_title = 0 ): \"\"\" Acess videos by urls. \"\"\" url_list = url . split () g . model . songs = [] for u in url_list : try : p = pafy . get_video_info ( url . split ( '?v=' )[ 1 ]) #util.get_pafy(u) except ( IOError , ValueError ) as e : g . message = c . r + str ( e ) + c . w g . content = g . content or content . generate_songlist_display ( zeromsg = g . message ) return g . browse_mode = \"normal\" v = Video ( p [ 'id' ], p [ 'title' ], int ( p [ 'duration' ][ 'secondsText' ])) g . model . songs . append ( v ) if not g . command_line : g . content = content . generate_songlist_display () if print_title : util . xprint ( v . title )","title":"yt_url()"},{"location":"reference/commands/search/#mps_youtube.commands.search.yt_url_file","text":"Access a list of urls in a text file Source code in mps_youtube/commands/search.py @command ( r 'url_file\\s(\\S+)' , 'url_file' ) def yt_url_file ( file_name ): \"\"\" Access a list of urls in a text file \"\"\" #Open and read the file try : with open ( file_name , \"r\" ) as fo : output = ' ' . join ([ line . strip () for line in fo if line . strip ()]) except ( IOError ): g . message = c . r + 'Error while opening the file, check the validity of the path' + c . w g . content = g . content or content . generate_songlist_display ( zeromsg = g . message ) return #Finally pass the input to yt_url yt_url ( output )","title":"yt_url_file()"},{"location":"reference/commands/songlist/","text":"dump ( un ) \u00b6 Show entire playlist. Source code in mps_youtube/commands/songlist.py @command ( r '(un)?dump' , 'dump' , 'undump' ) def dump ( un ): \"\"\" Show entire playlist. \"\"\" func , args = g . last_search_query if func is paginatesongs : paginatesongs ( dumps = ( not un ), ** args ) else : un = \"\" if not un else un g . message = \" %s%s dump %s may only be used on an open YouTube playlist\" g . message = g . message % ( c . y , un , c . w ) g . content = content . generate_songlist_display () nextprev ( np , page = None ) \u00b6 Get next / previous search results. Source code in mps_youtube/commands/songlist.py @command ( r '(n|p)\\s*(\\d{1,2})?' ) def nextprev ( np , page = None ): \"\"\" Get next / previous search results. \"\"\" if isinstance ( g . content , content . PaginatedContent ): page_count = g . content . numPages () function = g . content . getPage args = {} else : page_count = math . ceil ( g . result_count / util . getxy () . max_results ) function , args = g . last_search_query good = False if function : if np == \"n\" : if g . current_page + 1 < page_count : g . current_page += 1 good = True elif np == \"p\" : if page and int ( page ) in range ( 1 , 20 ): g . current_page = int ( page ) - 1 good = True elif g . current_page > 0 : g . current_page -= 1 good = True if good : function ( page = g . current_page , ** args ) else : norp = \"next\" if np == \"n\" else \"previous\" g . message = \"No %s items to display\" % norp if not isinstance ( g . content , content . PaginatedContent ): g . content = content . generate_songlist_display () return good paginatesongs ( func , page = 0 , splash = True , dumps = False , length = None , msg = None , failmsg = None , loadmsg = None ) \u00b6 A utility function for handling lists of songs, so that the pagination and the dump command will work properly. :param func: Either a function taking a start and end index, or a slicable object. Either way, it should produce an iterable of :class: mps_youtube.playlist.Video objects. :param page: The page number to display :param splash: Whether or not to display a splash screen while loading. :param dumps: Used by :func: dump command to load all songs, instead of only those that fit on a page :param length: The total number of songs. It it is not provided, len(func) will be used instead. :param msg: Message to display after loading successfully :param failmsg: Message to display on failure (if no songs are returned by func :param loadmsg: Message to display while loading :type page: int :type splash: bool :type dumps: bool :type length: int :type msg: str :type failmsg: str :type loadmsg: str Source code in mps_youtube/commands/songlist.py def paginatesongs ( func , page = 0 , splash = True , dumps = False , length = None , msg = None , failmsg = None , loadmsg = None ): \"\"\" A utility function for handling lists of songs, so that the pagination and the dump command will work properly. :param func: Either a function taking a start and end index, or a slicable object. Either way, it should produce an iterable of :class:`mps_youtube.playlist.Video` objects. :param page: The page number to display :param splash: Whether or not to display a splash screen while loading. :param dumps: Used by :func:`dump` command to load all songs, instead of only those that fit on a page :param length: The total number of songs. It it is not provided, ``len(func)`` will be used instead. :param msg: Message to display after loading successfully :param failmsg: Message to display on failure (if no songs are returned by func :param loadmsg: Message to display while loading :type page: int :type splash: bool :type dumps: bool :type length: int :type msg: str :type failmsg: str :type loadmsg: str \"\"\" if splash : g . message = loadmsg or '' g . content = content . logo ( col = c . b ) screen . update () max_results = util . getxy () . max_results if dumps : s = 0 e = None else : s = page * max_results e = ( page + 1 ) * max_results if callable ( func ): songs = func ( s , e ) else : songs = func [ s : e ] if length is None : length = len ( func ) args = { 'func' : func , 'length' : length , 'msg' : msg , 'failmsg' : failmsg , 'loadmsg' : loadmsg } g . last_search_query = ( paginatesongs , args ) g . browse_mode = \"normal\" g . current_page = page g . result_count = length g . model . songs = songs g . content = content . generate_songlist_display () g . last_opened = \"\" g . message = msg or '' if not songs : g . message = failmsg or g . message if songs : # preload first result url streams . preload ( songs [ 0 ], delay = 0 ) plist ( parturl ) \u00b6 Retrieve YouTube playlist. Source code in mps_youtube/commands/songlist.py @command ( r 'pl\\s+ %s ' % PL , 'pl' ) def plist ( parturl ): \"\"\" Retrieve YouTube playlist. \"\"\" if parturl in g . pafy_pls : ytpl , plitems = g . pafy_pls [ parturl ] else : util . dbg ( \" %s Fetching playlist using pafy %s \" , c . y , c . w ) ytpl = pafy . get_playlist ( parturl ) plitems = util . IterSlicer ( ytpl [ 'videos' ]) g . pafy_pls [ parturl ] = ( ytpl , plitems ) def pl_seg ( s , e ): return [ Video ( i [ 'id' ], i [ 'title' ], util . parse_video_length ( i [ 'duration' ])) for i in plitems [ s : e ]] msg = \"Showing YouTube playlist %s \" % ( c . y + ytpl [ 'info' ][ 'title' ] + c . w ) loadmsg = \"Retrieving YouTube playlist\" paginatesongs ( pl_seg , length = len ( ytpl [ 'videos' ]), msg = msg , loadmsg = loadmsg ) reverse_playlist () \u00b6 Reverse order of entire loaded playlist. Source code in mps_youtube/commands/songlist.py @command ( r 'reverse all' , 'reverse all' ) def reverse_playlist (): \"\"\" Reverse order of entire loaded playlist. \"\"\" # Prevent crash if no last query if g . last_search_query == ( None , None ) or \\ 'func' not in g . last_search_query [ 1 ]: g . content = content . logo () g . message = \"No playlist loaded\" return songs_list_or_func = g . last_search_query [ 1 ][ 'func' ] if callable ( songs_list_or_func ): songs = reversed ( songs_list_or_func ( 0 , None )) else : songs = reversed ( songs_list_or_func ) paginatesongs ( list ( songs )) g . message = c . y + \"Reversed entire playlist\" + c . w g . content = content . generate_songlist_display () reverse_songs () \u00b6 Reverse order of displayed items. Source code in mps_youtube/commands/songlist.py @command ( r 'reverse' , 'reverse' ) def reverse_songs (): \"\"\" Reverse order of displayed items. \"\"\" g . model . songs = g . model . songs [:: - 1 ] g . message = c . y + \"Reversed displayed songs\" + c . w g . content = content . generate_songlist_display () reverse_songs_range ( lower , upper ) \u00b6 Reverse the songs within a specified range. Source code in mps_youtube/commands/songlist.py @command ( r 'reverse\\s*(\\d{1,4})\\s*-\\s*(\\d{1,4})\\s*' , 'reverse' ) def reverse_songs_range ( lower , upper ): \"\"\" Reverse the songs within a specified range. \"\"\" lower , upper = int ( lower ), int ( upper ) if lower > upper : lower , upper = upper , lower g . model . songs [ lower - 1 : upper ] = reversed ( g . model . songs [ lower - 1 : upper ]) g . message = c . y + \"Reversed range: \" + str ( lower ) + \"-\" + str ( upper ) + c . w g . content = content . generate_songlist_display () shuffle_fn () \u00b6 Shuffle displayed items. Source code in mps_youtube/commands/songlist.py @command ( r 'shuffle' , 'shuffle' ) def shuffle_fn (): \"\"\" Shuffle displayed items. \"\"\" random . shuffle ( g . model . songs ) g . message = c . y + \"Items shuffled\" + c . w g . content = content . generate_songlist_display () songlist_mv_sw ( action , a , b ) \u00b6 Move a song or swap two songs. Source code in mps_youtube/commands/songlist.py @command ( r '(mv|sw)\\s*(\\d{1,4})\\s*[\\s,]\\s*(\\d{1,4})' , 'mv' , 'sw' ) def songlist_mv_sw ( action , a , b ): \"\"\" Move a song or swap two songs. \"\"\" i , j = int ( a ) - 1 , int ( b ) - 1 if action == \"mv\" : g . model . songs . insert ( j , g . model . songs . pop ( i )) g . message = util . F ( 'song move' ) % ( g . model [ j ] . title , b ) elif action == \"sw\" : g . model [ i ], g . model [ j ] = g . model [ j ], g . model [ i ] g . message = util . F ( 'song sw' ) % ( min ( a , b ), max ( a , b )) g . content = content . generate_songlist_display () songlist_rm_add ( action , songrange ) \u00b6 Remove or add tracks. works directly on user input. Source code in mps_youtube/commands/songlist.py @command ( r '(rm|add)\\s*(-?\\d[-,\\d\\s]{,250})' , 'rm' , 'add' ) def songlist_rm_add ( action , songrange ): \"\"\" Remove or add tracks. works directly on user input. \"\"\" selection = util . parse_multi ( songrange ) if action == \"add\" : duplicate_songs = [] for songnum in selection : if g . model [ songnum - 1 ] in g . active : duplicate_songs . append ( str ( songnum )) g . active . songs . append ( g . model [ songnum - 1 ]) d = g . active . duration g . message = util . F ( 'added to pl' ) % ( len ( selection ), len ( g . active ), d ) if duplicate_songs : duplicate_songs = ', ' . join ( sorted ( duplicate_songs )) g . message += ' \\n ' g . message += util . F ( 'duplicate tracks' ) % duplicate_songs elif action == \"rm\" : selection = sorted ( set ( selection ), reverse = True ) removed = str ( tuple ( reversed ( selection ))) . replace ( \",\" , \"\" ) for x in selection : g . model . songs . pop ( x - 1 ) try : g . active . songs . pop ( g . current_page * util . getxy () . max_results + x - 1 ) except IndexError : pass g . message = util . F ( 'songs rm' ) % ( len ( selection ), removed ) g . content = content . generate_songlist_display ()","title":"songlist.py"},{"location":"reference/commands/songlist/#mps_youtube.commands.songlist.dump","text":"Show entire playlist. Source code in mps_youtube/commands/songlist.py @command ( r '(un)?dump' , 'dump' , 'undump' ) def dump ( un ): \"\"\" Show entire playlist. \"\"\" func , args = g . last_search_query if func is paginatesongs : paginatesongs ( dumps = ( not un ), ** args ) else : un = \"\" if not un else un g . message = \" %s%s dump %s may only be used on an open YouTube playlist\" g . message = g . message % ( c . y , un , c . w ) g . content = content . generate_songlist_display ()","title":"dump()"},{"location":"reference/commands/songlist/#mps_youtube.commands.songlist.nextprev","text":"Get next / previous search results. Source code in mps_youtube/commands/songlist.py @command ( r '(n|p)\\s*(\\d{1,2})?' ) def nextprev ( np , page = None ): \"\"\" Get next / previous search results. \"\"\" if isinstance ( g . content , content . PaginatedContent ): page_count = g . content . numPages () function = g . content . getPage args = {} else : page_count = math . ceil ( g . result_count / util . getxy () . max_results ) function , args = g . last_search_query good = False if function : if np == \"n\" : if g . current_page + 1 < page_count : g . current_page += 1 good = True elif np == \"p\" : if page and int ( page ) in range ( 1 , 20 ): g . current_page = int ( page ) - 1 good = True elif g . current_page > 0 : g . current_page -= 1 good = True if good : function ( page = g . current_page , ** args ) else : norp = \"next\" if np == \"n\" else \"previous\" g . message = \"No %s items to display\" % norp if not isinstance ( g . content , content . PaginatedContent ): g . content = content . generate_songlist_display () return good","title":"nextprev()"},{"location":"reference/commands/songlist/#mps_youtube.commands.songlist.paginatesongs","text":"A utility function for handling lists of songs, so that the pagination and the dump command will work properly. :param func: Either a function taking a start and end index, or a slicable object. Either way, it should produce an iterable of :class: mps_youtube.playlist.Video objects. :param page: The page number to display :param splash: Whether or not to display a splash screen while loading. :param dumps: Used by :func: dump command to load all songs, instead of only those that fit on a page :param length: The total number of songs. It it is not provided, len(func) will be used instead. :param msg: Message to display after loading successfully :param failmsg: Message to display on failure (if no songs are returned by func :param loadmsg: Message to display while loading :type page: int :type splash: bool :type dumps: bool :type length: int :type msg: str :type failmsg: str :type loadmsg: str Source code in mps_youtube/commands/songlist.py def paginatesongs ( func , page = 0 , splash = True , dumps = False , length = None , msg = None , failmsg = None , loadmsg = None ): \"\"\" A utility function for handling lists of songs, so that the pagination and the dump command will work properly. :param func: Either a function taking a start and end index, or a slicable object. Either way, it should produce an iterable of :class:`mps_youtube.playlist.Video` objects. :param page: The page number to display :param splash: Whether or not to display a splash screen while loading. :param dumps: Used by :func:`dump` command to load all songs, instead of only those that fit on a page :param length: The total number of songs. It it is not provided, ``len(func)`` will be used instead. :param msg: Message to display after loading successfully :param failmsg: Message to display on failure (if no songs are returned by func :param loadmsg: Message to display while loading :type page: int :type splash: bool :type dumps: bool :type length: int :type msg: str :type failmsg: str :type loadmsg: str \"\"\" if splash : g . message = loadmsg or '' g . content = content . logo ( col = c . b ) screen . update () max_results = util . getxy () . max_results if dumps : s = 0 e = None else : s = page * max_results e = ( page + 1 ) * max_results if callable ( func ): songs = func ( s , e ) else : songs = func [ s : e ] if length is None : length = len ( func ) args = { 'func' : func , 'length' : length , 'msg' : msg , 'failmsg' : failmsg , 'loadmsg' : loadmsg } g . last_search_query = ( paginatesongs , args ) g . browse_mode = \"normal\" g . current_page = page g . result_count = length g . model . songs = songs g . content = content . generate_songlist_display () g . last_opened = \"\" g . message = msg or '' if not songs : g . message = failmsg or g . message if songs : # preload first result url streams . preload ( songs [ 0 ], delay = 0 )","title":"paginatesongs()"},{"location":"reference/commands/songlist/#mps_youtube.commands.songlist.plist","text":"Retrieve YouTube playlist. Source code in mps_youtube/commands/songlist.py @command ( r 'pl\\s+ %s ' % PL , 'pl' ) def plist ( parturl ): \"\"\" Retrieve YouTube playlist. \"\"\" if parturl in g . pafy_pls : ytpl , plitems = g . pafy_pls [ parturl ] else : util . dbg ( \" %s Fetching playlist using pafy %s \" , c . y , c . w ) ytpl = pafy . get_playlist ( parturl ) plitems = util . IterSlicer ( ytpl [ 'videos' ]) g . pafy_pls [ parturl ] = ( ytpl , plitems ) def pl_seg ( s , e ): return [ Video ( i [ 'id' ], i [ 'title' ], util . parse_video_length ( i [ 'duration' ])) for i in plitems [ s : e ]] msg = \"Showing YouTube playlist %s \" % ( c . y + ytpl [ 'info' ][ 'title' ] + c . w ) loadmsg = \"Retrieving YouTube playlist\" paginatesongs ( pl_seg , length = len ( ytpl [ 'videos' ]), msg = msg , loadmsg = loadmsg )","title":"plist()"},{"location":"reference/commands/songlist/#mps_youtube.commands.songlist.reverse_playlist","text":"Reverse order of entire loaded playlist. Source code in mps_youtube/commands/songlist.py @command ( r 'reverse all' , 'reverse all' ) def reverse_playlist (): \"\"\" Reverse order of entire loaded playlist. \"\"\" # Prevent crash if no last query if g . last_search_query == ( None , None ) or \\ 'func' not in g . last_search_query [ 1 ]: g . content = content . logo () g . message = \"No playlist loaded\" return songs_list_or_func = g . last_search_query [ 1 ][ 'func' ] if callable ( songs_list_or_func ): songs = reversed ( songs_list_or_func ( 0 , None )) else : songs = reversed ( songs_list_or_func ) paginatesongs ( list ( songs )) g . message = c . y + \"Reversed entire playlist\" + c . w g . content = content . generate_songlist_display ()","title":"reverse_playlist()"},{"location":"reference/commands/songlist/#mps_youtube.commands.songlist.reverse_songs","text":"Reverse order of displayed items. Source code in mps_youtube/commands/songlist.py @command ( r 'reverse' , 'reverse' ) def reverse_songs (): \"\"\" Reverse order of displayed items. \"\"\" g . model . songs = g . model . songs [:: - 1 ] g . message = c . y + \"Reversed displayed songs\" + c . w g . content = content . generate_songlist_display ()","title":"reverse_songs()"},{"location":"reference/commands/songlist/#mps_youtube.commands.songlist.reverse_songs_range","text":"Reverse the songs within a specified range. Source code in mps_youtube/commands/songlist.py @command ( r 'reverse\\s*(\\d{1,4})\\s*-\\s*(\\d{1,4})\\s*' , 'reverse' ) def reverse_songs_range ( lower , upper ): \"\"\" Reverse the songs within a specified range. \"\"\" lower , upper = int ( lower ), int ( upper ) if lower > upper : lower , upper = upper , lower g . model . songs [ lower - 1 : upper ] = reversed ( g . model . songs [ lower - 1 : upper ]) g . message = c . y + \"Reversed range: \" + str ( lower ) + \"-\" + str ( upper ) + c . w g . content = content . generate_songlist_display ()","title":"reverse_songs_range()"},{"location":"reference/commands/songlist/#mps_youtube.commands.songlist.shuffle_fn","text":"Shuffle displayed items. Source code in mps_youtube/commands/songlist.py @command ( r 'shuffle' , 'shuffle' ) def shuffle_fn (): \"\"\" Shuffle displayed items. \"\"\" random . shuffle ( g . model . songs ) g . message = c . y + \"Items shuffled\" + c . w g . content = content . generate_songlist_display ()","title":"shuffle_fn()"},{"location":"reference/commands/songlist/#mps_youtube.commands.songlist.songlist_mv_sw","text":"Move a song or swap two songs. Source code in mps_youtube/commands/songlist.py @command ( r '(mv|sw)\\s*(\\d{1,4})\\s*[\\s,]\\s*(\\d{1,4})' , 'mv' , 'sw' ) def songlist_mv_sw ( action , a , b ): \"\"\" Move a song or swap two songs. \"\"\" i , j = int ( a ) - 1 , int ( b ) - 1 if action == \"mv\" : g . model . songs . insert ( j , g . model . songs . pop ( i )) g . message = util . F ( 'song move' ) % ( g . model [ j ] . title , b ) elif action == \"sw\" : g . model [ i ], g . model [ j ] = g . model [ j ], g . model [ i ] g . message = util . F ( 'song sw' ) % ( min ( a , b ), max ( a , b )) g . content = content . generate_songlist_display ()","title":"songlist_mv_sw()"},{"location":"reference/commands/songlist/#mps_youtube.commands.songlist.songlist_rm_add","text":"Remove or add tracks. works directly on user input. Source code in mps_youtube/commands/songlist.py @command ( r '(rm|add)\\s*(-?\\d[-,\\d\\s]{,250})' , 'rm' , 'add' ) def songlist_rm_add ( action , songrange ): \"\"\" Remove or add tracks. works directly on user input. \"\"\" selection = util . parse_multi ( songrange ) if action == \"add\" : duplicate_songs = [] for songnum in selection : if g . model [ songnum - 1 ] in g . active : duplicate_songs . append ( str ( songnum )) g . active . songs . append ( g . model [ songnum - 1 ]) d = g . active . duration g . message = util . F ( 'added to pl' ) % ( len ( selection ), len ( g . active ), d ) if duplicate_songs : duplicate_songs = ', ' . join ( sorted ( duplicate_songs )) g . message += ' \\n ' g . message += util . F ( 'duplicate tracks' ) % duplicate_songs elif action == \"rm\" : selection = sorted ( set ( selection ), reverse = True ) removed = str ( tuple ( reversed ( selection ))) . replace ( \",\" , \"\" ) for x in selection : g . model . songs . pop ( x - 1 ) try : g . active . songs . pop ( g . current_page * util . getxy () . max_results + x - 1 ) except IndexError : pass g . message = util . F ( 'songs rm' ) % ( len ( selection ), removed ) g . content = content . generate_songlist_display ()","title":"songlist_rm_add()"},{"location":"reference/commands/spotify_playlist/","text":"generate_credentials () \u00b6 Generate the token. Please respect these credentials :) Source code in mps_youtube/commands/spotify_playlist.py def generate_credentials (): \"\"\"Generate the token. Please respect these credentials :)\"\"\" credentials = oauth2 . SpotifyClientCredentials ( client_id = '6451e12933bb49ed8543d41e3296a88d' , client_secret = '40ef54678fe441bd9acd66f5d5c34e69' ) return credentials search_playlist ( term , spotify = None ) \u00b6 Search for Spotify playlist. Source code in mps_youtube/commands/spotify_playlist.py @command ( r 'splaylist\\s*(.*[-_a-zA-Z0-9].*)?' , 'splaylist' ) def search_playlist ( term , spotify = None ): \"\"\"Search for Spotify playlist. \"\"\" # pylint: disable=R0914,R0912 if has_spotipy : if not term : show_message ( \"Enter playlist url:\" , c . g , update = True ) term = input ( \"> \" ) if not term or len ( term ) < 2 : g . message = c . r + \"Not enough input!\" + c . w g . content = None #content.generate_songlist_display() return if not spotify : credentials = generate_credentials () token = credentials . get_access_token () spotify = spotipy . Spotify ( auth = token ) try : playlist , tracks = grab_playlist ( spotify , term ) except TypeError : tracks = None if not tracks : show_message ( \"Playlist ' %s ' not found!\" % term ) return if not playlist [ 'tracks' ][ 'total' ]: show_message ( \"Playlist ' %s ' by ' %s ' has 0 tracks!\" % ( playlist [ 'name' ], playlist [ 'owner' ][ 'id' ])) return msg = \" %s%s%s by %s%s%s \\n\\n \" % ( c . g , playlist [ 'name' ], c . w , c . g , playlist [ 'owner' ][ 'id' ], c . w ) msg += \"Enter to begin matching or [q] to abort\" g . message = msg g . content = \"Tracks: \\n \" for n , track in enumerate ( tracks , 1 ): trackname = ' {0:<20} - {1} ' . format ( track [ 'artists' ][ 0 ][ 'name' ], track [ 'name' ]) g . content += \" %03s %s \" % ( n , trackname ) g . content += \" \\n \" screen . update () entry = input ( \"Continue? [Enter] > \" ) if entry == \"\" : pass else : show_message ( \"Playlist search abandoned!\" ) return songs = [] screen . clear () itt = _match_tracks ( tracks ) stash = config . SEARCH_MUSIC . get , config . ORDER . get config . SEARCH_MUSIC . value = True config . ORDER . value = \"relevance\" try : songs . extend ( itt ) except KeyboardInterrupt : util . xprint ( \" %s Halted! %s \" % ( c . r , c . w )) finally : config . SEARCH_MUSIC . value , config . ORDER . value = stash if songs : util . xprint ( \" \\n %s / %s songs matched\" % ( len ( songs ), len ( tracks ))) input ( \"Press Enter to continue\" ) msg = \"Contents of playlist %s%s - %s%s %s ( %d / %d ) %s :\" % ( c . y , playlist [ 'owner' ][ 'id' ], playlist [ 'name' ], c . w , c . b , len ( songs ), len ( tracks ), c . w ) failmsg = \"Found no playlist tracks for %s%s%s \" % ( c . y , playlist [ 'name' ], c . w ) paginatesongs ( songs , msg = msg , failmsg = failmsg ) else : g . message = \"spotipy module must be installed for Spotify support \\n \" g . message += \"see https://pypi.python.org/pypi/spotipy/\" search_user ( term ) \u00b6 Search for Spotify user playlists. Source code in mps_youtube/commands/spotify_playlist.py @command ( r 'suser\\s*(.*[-_a-zA-Z0-9].*)?' , 'suser' ) def search_user ( term ): \"\"\"Search for Spotify user playlists. \"\"\" # pylint: disable=R0914,R0912 if has_spotipy : if not term : show_message ( \"Enter username:\" , c . g , update = True ) term = input ( \"> \" ) if not term or len ( term ) < 2 : g . message = c . r + \"Not enough input!\" + c . w g . content = None #content.generate_songlist_display() return credentials = generate_credentials () token = credentials . get_access_token () spotify = spotipy . Spotify ( auth = token ) playlists = spotify . user_playlists ( term ) links = [] check = 1 g . content = \"Playlists: \\n \" while True : for playlist in playlists [ 'items' ]: if playlist [ 'name' ] is not None : g . content += ( u ' {0:>2} . {1:<30} ( {2} tracks)' . format ( check , playlist [ 'name' ], playlist [ 'tracks' ][ 'total' ])) g . content += \" \\n \" links . append ( playlist ) check += 1 if playlists [ 'next' ]: playlists = spotify . next ( playlists ) else : break g . message = c . g + \"Choose your playlist:\" + c . w screen . update () choice = int ( input ( \"> \" )) playlist = links [ choice - 1 ] search_playlist ( playlist [ 'external_urls' ][ 'spotify' ], spotify = spotify ) else : g . message = \"spotipy module must be installed for Spotify support \\n \" g . message += \"see https://pypi.python.org/pypi/spotipy/\" show_message ( message , col = '' , update = False ) \u00b6 Show message using col, update screen if required. Source code in mps_youtube/commands/spotify_playlist.py def show_message ( message , col = c . r , update = False ): \"\"\" Show message using col, update screen if required. \"\"\" g . content = content . generate_songlist_display () g . message = col + message + c . w if update : screen . update ()","title":"spotify_playlist.py"},{"location":"reference/commands/spotify_playlist/#mps_youtube.commands.spotify_playlist.generate_credentials","text":"Generate the token. Please respect these credentials :) Source code in mps_youtube/commands/spotify_playlist.py def generate_credentials (): \"\"\"Generate the token. Please respect these credentials :)\"\"\" credentials = oauth2 . SpotifyClientCredentials ( client_id = '6451e12933bb49ed8543d41e3296a88d' , client_secret = '40ef54678fe441bd9acd66f5d5c34e69' ) return credentials","title":"generate_credentials()"},{"location":"reference/commands/spotify_playlist/#mps_youtube.commands.spotify_playlist.search_playlist","text":"Search for Spotify playlist. Source code in mps_youtube/commands/spotify_playlist.py @command ( r 'splaylist\\s*(.*[-_a-zA-Z0-9].*)?' , 'splaylist' ) def search_playlist ( term , spotify = None ): \"\"\"Search for Spotify playlist. \"\"\" # pylint: disable=R0914,R0912 if has_spotipy : if not term : show_message ( \"Enter playlist url:\" , c . g , update = True ) term = input ( \"> \" ) if not term or len ( term ) < 2 : g . message = c . r + \"Not enough input!\" + c . w g . content = None #content.generate_songlist_display() return if not spotify : credentials = generate_credentials () token = credentials . get_access_token () spotify = spotipy . Spotify ( auth = token ) try : playlist , tracks = grab_playlist ( spotify , term ) except TypeError : tracks = None if not tracks : show_message ( \"Playlist ' %s ' not found!\" % term ) return if not playlist [ 'tracks' ][ 'total' ]: show_message ( \"Playlist ' %s ' by ' %s ' has 0 tracks!\" % ( playlist [ 'name' ], playlist [ 'owner' ][ 'id' ])) return msg = \" %s%s%s by %s%s%s \\n\\n \" % ( c . g , playlist [ 'name' ], c . w , c . g , playlist [ 'owner' ][ 'id' ], c . w ) msg += \"Enter to begin matching or [q] to abort\" g . message = msg g . content = \"Tracks: \\n \" for n , track in enumerate ( tracks , 1 ): trackname = ' {0:<20} - {1} ' . format ( track [ 'artists' ][ 0 ][ 'name' ], track [ 'name' ]) g . content += \" %03s %s \" % ( n , trackname ) g . content += \" \\n \" screen . update () entry = input ( \"Continue? [Enter] > \" ) if entry == \"\" : pass else : show_message ( \"Playlist search abandoned!\" ) return songs = [] screen . clear () itt = _match_tracks ( tracks ) stash = config . SEARCH_MUSIC . get , config . ORDER . get config . SEARCH_MUSIC . value = True config . ORDER . value = \"relevance\" try : songs . extend ( itt ) except KeyboardInterrupt : util . xprint ( \" %s Halted! %s \" % ( c . r , c . w )) finally : config . SEARCH_MUSIC . value , config . ORDER . value = stash if songs : util . xprint ( \" \\n %s / %s songs matched\" % ( len ( songs ), len ( tracks ))) input ( \"Press Enter to continue\" ) msg = \"Contents of playlist %s%s - %s%s %s ( %d / %d ) %s :\" % ( c . y , playlist [ 'owner' ][ 'id' ], playlist [ 'name' ], c . w , c . b , len ( songs ), len ( tracks ), c . w ) failmsg = \"Found no playlist tracks for %s%s%s \" % ( c . y , playlist [ 'name' ], c . w ) paginatesongs ( songs , msg = msg , failmsg = failmsg ) else : g . message = \"spotipy module must be installed for Spotify support \\n \" g . message += \"see https://pypi.python.org/pypi/spotipy/\"","title":"search_playlist()"},{"location":"reference/commands/spotify_playlist/#mps_youtube.commands.spotify_playlist.search_user","text":"Search for Spotify user playlists. Source code in mps_youtube/commands/spotify_playlist.py @command ( r 'suser\\s*(.*[-_a-zA-Z0-9].*)?' , 'suser' ) def search_user ( term ): \"\"\"Search for Spotify user playlists. \"\"\" # pylint: disable=R0914,R0912 if has_spotipy : if not term : show_message ( \"Enter username:\" , c . g , update = True ) term = input ( \"> \" ) if not term or len ( term ) < 2 : g . message = c . r + \"Not enough input!\" + c . w g . content = None #content.generate_songlist_display() return credentials = generate_credentials () token = credentials . get_access_token () spotify = spotipy . Spotify ( auth = token ) playlists = spotify . user_playlists ( term ) links = [] check = 1 g . content = \"Playlists: \\n \" while True : for playlist in playlists [ 'items' ]: if playlist [ 'name' ] is not None : g . content += ( u ' {0:>2} . {1:<30} ( {2} tracks)' . format ( check , playlist [ 'name' ], playlist [ 'tracks' ][ 'total' ])) g . content += \" \\n \" links . append ( playlist ) check += 1 if playlists [ 'next' ]: playlists = spotify . next ( playlists ) else : break g . message = c . g + \"Choose your playlist:\" + c . w screen . update () choice = int ( input ( \"> \" )) playlist = links [ choice - 1 ] search_playlist ( playlist [ 'external_urls' ][ 'spotify' ], spotify = spotify ) else : g . message = \"spotipy module must be installed for Spotify support \\n \" g . message += \"see https://pypi.python.org/pypi/spotipy/\"","title":"search_user()"},{"location":"reference/commands/spotify_playlist/#mps_youtube.commands.spotify_playlist.show_message","text":"Show message using col, update screen if required. Source code in mps_youtube/commands/spotify_playlist.py def show_message ( message , col = c . r , update = False ): \"\"\" Show message using col, update screen if required. \"\"\" g . content = content . generate_songlist_display () g . message = col + message + c . w if update : screen . update ()","title":"show_message()"},{"location":"reference/listview/__init__/","text":"DOCSTING COMES HERE ListView ( PaginatedContent ) \u00b6 Content Agnostic Numbered List This class, using ListViewItems as abstractions you can give it a list of data and which columns to show and it will show it. Todo Currently we rely on the commands/play code to send information about which elements are being picked. Column format: {\"name\": \"idx\", \"size\": 3, \"heading\": \"Num\"} name: The method name that will be called from the ListViewItem !!! size \"How much size is allocated to the columns,\" see ListView.content for more information about the dynamic options heading: The text shown in the header \"idx\" is generated in the content function, not by the ListViewItem Source code in mps_youtube/listview/__init__.py class ListView ( content . PaginatedContent ): \"\"\" Content Agnostic Numbered List This class, using ListViewItems as abstractions you can give it a list of data and which columns to show and it will show it. Todo: Currently we rely on the commands/play code to send information about which elements are being picked. Attributes: func The function that will be run on the selected items objects List of objects(or a ContentQuery object) columns A list of Hashes containing information about which columns to show page Current Page Column format: {\"name\": \"idx\", \"size\": 3, \"heading\": \"Num\"} name: The method name that will be called from the ListViewItem size: How much size is allocated to the columns, see ListView.content for more information about the dynamic options heading: The text shown in the header \"idx\" is generated in the content function, not by the ListViewItem \"\"\" func = None objects = None columns = None page = 0 def __init__ ( self , columns , objects , function_call = None ): \"\"\" \"\"\" self . func = function_call self . objects = objects self . columns = columns self . object_type = None # Ensure single type of object types = len ( set ([ obj . __class__ for obj in objects ])) if types == 0 : raise BaseException ( \"No objects in list\" ) if types > 1 : raise BaseException ( \"More than one kind of objects in list\" ) self . object_type = [ obj . __class__ for obj in objects ][ 0 ] def numPages ( self ): \"\"\" Returns # of pages \"\"\" return max ( 1 , math . ceil ( len ( self . objects ) / self . views_per_page ())) def getPage ( self , page ): self . page = page return self . content () def _page_slice ( self ): chgt = self . views_per_page () return slice ( self . page * chgt , ( self . page + 1 ) * chgt ) def content ( self ): \"\"\" Generates content =============== Dynamic fields =============== Column.size may instead of an integer be a string containing either \"length\" or \"remaining\". Length is for time formats like 20:40 Remaining will allocate all remaining space to that column. TODO: Make it so set columns can set \"remaining\" ? \"\"\" # Sums all ints, deal with strings later remaining = ( util . getxy () . width ) - sum ( 1 + ( x [ 'size' ] if x [ 'size' ] and x [ 'size' ] . __class__ == int else 0 ) for x in self . columns ) - ( len ( self . columns )) lengthsize = 0 if \"length\" in [ x [ 'size' ] for x in self . columns ]: max_l = max (( getattr ( x , \"length\" )() for x in self . objects )) lengthsize = 8 if max_l > 35999 else 7 lengthsize = 6 if max_l < 6000 else lengthsize for col in self . columns : if col [ 'size' ] == \"remaining\" : col [ 'size' ] = remaining - lengthsize if col [ 'size' ] == \"length\" : col [ 'size' ] = lengthsize for num , column in enumerate ( self . columns ): column [ 'idx' ] = num column [ 'sign' ] = \"-\" if not column [ 'name' ] == \"length\" else \"\" fmt = [ \"% {}{} s \" . format ( x [ 'sign' ], x [ 'size' ]) for x in self . columns ] fmtrow = fmt [ 0 : 1 ] + [ \" %s \" ] + fmt [ 2 :] fmt , fmtrow = \"\" . join ( fmt ) . strip (), \"\" . join ( fmtrow ) . strip () titles = tuple ([ x [ 'heading' ][: x [ 'size' ]] for x in self . columns ]) out = \" \\n \" + ( c . ul + fmt % titles + c . w ) + \" \\n \" for num , obj in enumerate ( self . objects [ self . _page_slice ()]): col = ( c . r if num % 2 == 0 else c . p ) idx = num + ( self . views_per_page () * self . page ) + 1 line = '' for column in self . columns : fieldsize , field = column [ 'size' ], column [ 'name' ] direction = \"<\" if column [ 'sign' ] == \"-\" else \">\" if field == \"idx\" : field = \" %2d \" % idx else : field = getattr ( obj , field )( fieldsize ) field = str ( field ) if field . __class__ != str else field line += util . uea_pad ( fieldsize , field , direction ) if column != self . columns [ - 1 ]: line += \" \" line = col + line + c . w out += line + \" \\n \" return out def _play ( self , _ , choice , __ ): # pre, choice, post \"\"\" Handles what happends when a user selects something from the list Currently this functions hooks into commands/play \"\"\" uids = [] for splitted_choice in choice . split ( \",\" ): cho = splitted_choice . strip () if cho . isdigit (): uids . append ( int ( cho ) - 1 ) else : cho = cho . split ( \"-\" ) if cho [ 0 ] . isdigit () and cho [ 1 ] . isdigit (): uids += list ( range ( int ( cho [ 0 ]) - 1 , int ( cho [ 1 ]))) var = getattr ( self . object_type , \"return_field\" )() self . func ([ getattr ( self . objects [ x ], var )() for x in uids ]) def views_per_page ( self ): \"\"\" Determines how many views can be per page \"\"\" return util . getxy () . max_results content ( self ) \u00b6 Generates content =============== Dynamic fields =============== Column.size may instead of an integer be a string containing either \"length\" or \"remaining\". Length is for time formats like 20:40 Remaining will allocate all remaining space to that column. TODO: Make it so set columns can set \"remaining\" ? Source code in mps_youtube/listview/__init__.py def content ( self ): \"\"\" Generates content =============== Dynamic fields =============== Column.size may instead of an integer be a string containing either \"length\" or \"remaining\". Length is for time formats like 20:40 Remaining will allocate all remaining space to that column. TODO: Make it so set columns can set \"remaining\" ? \"\"\" # Sums all ints, deal with strings later remaining = ( util . getxy () . width ) - sum ( 1 + ( x [ 'size' ] if x [ 'size' ] and x [ 'size' ] . __class__ == int else 0 ) for x in self . columns ) - ( len ( self . columns )) lengthsize = 0 if \"length\" in [ x [ 'size' ] for x in self . columns ]: max_l = max (( getattr ( x , \"length\" )() for x in self . objects )) lengthsize = 8 if max_l > 35999 else 7 lengthsize = 6 if max_l < 6000 else lengthsize for col in self . columns : if col [ 'size' ] == \"remaining\" : col [ 'size' ] = remaining - lengthsize if col [ 'size' ] == \"length\" : col [ 'size' ] = lengthsize for num , column in enumerate ( self . columns ): column [ 'idx' ] = num column [ 'sign' ] = \"-\" if not column [ 'name' ] == \"length\" else \"\" fmt = [ \"% {}{} s \" . format ( x [ 'sign' ], x [ 'size' ]) for x in self . columns ] fmtrow = fmt [ 0 : 1 ] + [ \" %s \" ] + fmt [ 2 :] fmt , fmtrow = \"\" . join ( fmt ) . strip (), \"\" . join ( fmtrow ) . strip () titles = tuple ([ x [ 'heading' ][: x [ 'size' ]] for x in self . columns ]) out = \" \\n \" + ( c . ul + fmt % titles + c . w ) + \" \\n \" for num , obj in enumerate ( self . objects [ self . _page_slice ()]): col = ( c . r if num % 2 == 0 else c . p ) idx = num + ( self . views_per_page () * self . page ) + 1 line = '' for column in self . columns : fieldsize , field = column [ 'size' ], column [ 'name' ] direction = \"<\" if column [ 'sign' ] == \"-\" else \">\" if field == \"idx\" : field = \" %2d \" % idx else : field = getattr ( obj , field )( fieldsize ) field = str ( field ) if field . __class__ != str else field line += util . uea_pad ( fieldsize , field , direction ) if column != self . columns [ - 1 ]: line += \" \" line = col + line + c . w out += line + \" \\n \" return out numPages ( self ) \u00b6 Returns # of pages Source code in mps_youtube/listview/__init__.py def numPages ( self ): \"\"\" Returns # of pages \"\"\" return max ( 1 , math . ceil ( len ( self . objects ) / self . views_per_page ())) views_per_page ( self ) \u00b6 Determines how many views can be per page Source code in mps_youtube/listview/__init__.py def views_per_page ( self ): \"\"\" Determines how many views can be per page \"\"\" return util . getxy () . max_results","title":"__init__.py"},{"location":"reference/listview/__init__/#mps_youtube.listview.__init__.ListView","text":"Content Agnostic Numbered List This class, using ListViewItems as abstractions you can give it a list of data and which columns to show and it will show it. Todo Currently we rely on the commands/play code to send information about which elements are being picked. Column format: {\"name\": \"idx\", \"size\": 3, \"heading\": \"Num\"} name: The method name that will be called from the ListViewItem !!! size \"How much size is allocated to the columns,\" see ListView.content for more information about the dynamic options heading: The text shown in the header \"idx\" is generated in the content function, not by the ListViewItem Source code in mps_youtube/listview/__init__.py class ListView ( content . PaginatedContent ): \"\"\" Content Agnostic Numbered List This class, using ListViewItems as abstractions you can give it a list of data and which columns to show and it will show it. Todo: Currently we rely on the commands/play code to send information about which elements are being picked. Attributes: func The function that will be run on the selected items objects List of objects(or a ContentQuery object) columns A list of Hashes containing information about which columns to show page Current Page Column format: {\"name\": \"idx\", \"size\": 3, \"heading\": \"Num\"} name: The method name that will be called from the ListViewItem size: How much size is allocated to the columns, see ListView.content for more information about the dynamic options heading: The text shown in the header \"idx\" is generated in the content function, not by the ListViewItem \"\"\" func = None objects = None columns = None page = 0 def __init__ ( self , columns , objects , function_call = None ): \"\"\" \"\"\" self . func = function_call self . objects = objects self . columns = columns self . object_type = None # Ensure single type of object types = len ( set ([ obj . __class__ for obj in objects ])) if types == 0 : raise BaseException ( \"No objects in list\" ) if types > 1 : raise BaseException ( \"More than one kind of objects in list\" ) self . object_type = [ obj . __class__ for obj in objects ][ 0 ] def numPages ( self ): \"\"\" Returns # of pages \"\"\" return max ( 1 , math . ceil ( len ( self . objects ) / self . views_per_page ())) def getPage ( self , page ): self . page = page return self . content () def _page_slice ( self ): chgt = self . views_per_page () return slice ( self . page * chgt , ( self . page + 1 ) * chgt ) def content ( self ): \"\"\" Generates content =============== Dynamic fields =============== Column.size may instead of an integer be a string containing either \"length\" or \"remaining\". Length is for time formats like 20:40 Remaining will allocate all remaining space to that column. TODO: Make it so set columns can set \"remaining\" ? \"\"\" # Sums all ints, deal with strings later remaining = ( util . getxy () . width ) - sum ( 1 + ( x [ 'size' ] if x [ 'size' ] and x [ 'size' ] . __class__ == int else 0 ) for x in self . columns ) - ( len ( self . columns )) lengthsize = 0 if \"length\" in [ x [ 'size' ] for x in self . columns ]: max_l = max (( getattr ( x , \"length\" )() for x in self . objects )) lengthsize = 8 if max_l > 35999 else 7 lengthsize = 6 if max_l < 6000 else lengthsize for col in self . columns : if col [ 'size' ] == \"remaining\" : col [ 'size' ] = remaining - lengthsize if col [ 'size' ] == \"length\" : col [ 'size' ] = lengthsize for num , column in enumerate ( self . columns ): column [ 'idx' ] = num column [ 'sign' ] = \"-\" if not column [ 'name' ] == \"length\" else \"\" fmt = [ \"% {}{} s \" . format ( x [ 'sign' ], x [ 'size' ]) for x in self . columns ] fmtrow = fmt [ 0 : 1 ] + [ \" %s \" ] + fmt [ 2 :] fmt , fmtrow = \"\" . join ( fmt ) . strip (), \"\" . join ( fmtrow ) . strip () titles = tuple ([ x [ 'heading' ][: x [ 'size' ]] for x in self . columns ]) out = \" \\n \" + ( c . ul + fmt % titles + c . w ) + \" \\n \" for num , obj in enumerate ( self . objects [ self . _page_slice ()]): col = ( c . r if num % 2 == 0 else c . p ) idx = num + ( self . views_per_page () * self . page ) + 1 line = '' for column in self . columns : fieldsize , field = column [ 'size' ], column [ 'name' ] direction = \"<\" if column [ 'sign' ] == \"-\" else \">\" if field == \"idx\" : field = \" %2d \" % idx else : field = getattr ( obj , field )( fieldsize ) field = str ( field ) if field . __class__ != str else field line += util . uea_pad ( fieldsize , field , direction ) if column != self . columns [ - 1 ]: line += \" \" line = col + line + c . w out += line + \" \\n \" return out def _play ( self , _ , choice , __ ): # pre, choice, post \"\"\" Handles what happends when a user selects something from the list Currently this functions hooks into commands/play \"\"\" uids = [] for splitted_choice in choice . split ( \",\" ): cho = splitted_choice . strip () if cho . isdigit (): uids . append ( int ( cho ) - 1 ) else : cho = cho . split ( \"-\" ) if cho [ 0 ] . isdigit () and cho [ 1 ] . isdigit (): uids += list ( range ( int ( cho [ 0 ]) - 1 , int ( cho [ 1 ]))) var = getattr ( self . object_type , \"return_field\" )() self . func ([ getattr ( self . objects [ x ], var )() for x in uids ]) def views_per_page ( self ): \"\"\" Determines how many views can be per page \"\"\" return util . getxy () . max_results","title":"ListView"},{"location":"reference/listview/__init__/#mps_youtube.listview.__init__.ListView.content","text":"Generates content =============== Dynamic fields =============== Column.size may instead of an integer be a string containing either \"length\" or \"remaining\". Length is for time formats like 20:40 Remaining will allocate all remaining space to that column. TODO: Make it so set columns can set \"remaining\" ? Source code in mps_youtube/listview/__init__.py def content ( self ): \"\"\" Generates content =============== Dynamic fields =============== Column.size may instead of an integer be a string containing either \"length\" or \"remaining\". Length is for time formats like 20:40 Remaining will allocate all remaining space to that column. TODO: Make it so set columns can set \"remaining\" ? \"\"\" # Sums all ints, deal with strings later remaining = ( util . getxy () . width ) - sum ( 1 + ( x [ 'size' ] if x [ 'size' ] and x [ 'size' ] . __class__ == int else 0 ) for x in self . columns ) - ( len ( self . columns )) lengthsize = 0 if \"length\" in [ x [ 'size' ] for x in self . columns ]: max_l = max (( getattr ( x , \"length\" )() for x in self . objects )) lengthsize = 8 if max_l > 35999 else 7 lengthsize = 6 if max_l < 6000 else lengthsize for col in self . columns : if col [ 'size' ] == \"remaining\" : col [ 'size' ] = remaining - lengthsize if col [ 'size' ] == \"length\" : col [ 'size' ] = lengthsize for num , column in enumerate ( self . columns ): column [ 'idx' ] = num column [ 'sign' ] = \"-\" if not column [ 'name' ] == \"length\" else \"\" fmt = [ \"% {}{} s \" . format ( x [ 'sign' ], x [ 'size' ]) for x in self . columns ] fmtrow = fmt [ 0 : 1 ] + [ \" %s \" ] + fmt [ 2 :] fmt , fmtrow = \"\" . join ( fmt ) . strip (), \"\" . join ( fmtrow ) . strip () titles = tuple ([ x [ 'heading' ][: x [ 'size' ]] for x in self . columns ]) out = \" \\n \" + ( c . ul + fmt % titles + c . w ) + \" \\n \" for num , obj in enumerate ( self . objects [ self . _page_slice ()]): col = ( c . r if num % 2 == 0 else c . p ) idx = num + ( self . views_per_page () * self . page ) + 1 line = '' for column in self . columns : fieldsize , field = column [ 'size' ], column [ 'name' ] direction = \"<\" if column [ 'sign' ] == \"-\" else \">\" if field == \"idx\" : field = \" %2d \" % idx else : field = getattr ( obj , field )( fieldsize ) field = str ( field ) if field . __class__ != str else field line += util . uea_pad ( fieldsize , field , direction ) if column != self . columns [ - 1 ]: line += \" \" line = col + line + c . w out += line + \" \\n \" return out","title":"content()"},{"location":"reference/listview/__init__/#mps_youtube.listview.__init__.ListView.numPages","text":"Returns # of pages Source code in mps_youtube/listview/__init__.py def numPages ( self ): \"\"\" Returns # of pages \"\"\" return max ( 1 , math . ceil ( len ( self . objects ) / self . views_per_page ()))","title":"numPages()"},{"location":"reference/listview/__init__/#mps_youtube.listview.__init__.ListView.views_per_page","text":"Determines how many views can be per page Source code in mps_youtube/listview/__init__.py def views_per_page ( self ): \"\"\" Determines how many views can be per page \"\"\" return util . getxy () . max_results","title":"views_per_page()"},{"location":"reference/listview/base/","text":"ListViewItem \u00b6 Base class for items Used by Listview Source code in mps_youtube/listview/base.py class ListViewItem : \"\"\" Base class for items Used by Listview \"\"\" data = None def __init__ ( self , data ): self . data = data def __getattr__ ( self , key ): return self . data [ key ] if key in self . data . keys () else None def length ( self , _ = 0 ): \"\"\" Returns length of ListViewItem A LVI has to return something for length even if the item does not have one. \"\"\" return 0 length ( self , _ = 0 ) \u00b6 Returns length of ListViewItem A LVI has to return something for length even if the item does not have one. Source code in mps_youtube/listview/base.py def length ( self , _ = 0 ): \"\"\" Returns length of ListViewItem A LVI has to return something for length even if the item does not have one. \"\"\" return 0","title":"base.py"},{"location":"reference/listview/base/#mps_youtube.listview.base.ListViewItem","text":"Base class for items Used by Listview Source code in mps_youtube/listview/base.py class ListViewItem : \"\"\" Base class for items Used by Listview \"\"\" data = None def __init__ ( self , data ): self . data = data def __getattr__ ( self , key ): return self . data [ key ] if key in self . data . keys () else None def length ( self , _ = 0 ): \"\"\" Returns length of ListViewItem A LVI has to return something for length even if the item does not have one. \"\"\" return 0","title":"ListViewItem"},{"location":"reference/listview/base/#mps_youtube.listview.base.ListViewItem.length","text":"Returns length of ListViewItem A LVI has to return something for length even if the item does not have one. Source code in mps_youtube/listview/base.py def length ( self , _ = 0 ): \"\"\" Returns length of ListViewItem A LVI has to return something for length even if the item does not have one. \"\"\" return 0","title":"length()"},{"location":"reference/listview/livestream/","text":"ListLiveStream ( ListViewItem ) \u00b6 Class exposing necessary components of a live stream Source code in mps_youtube/listview/livestream.py class ListLiveStream ( ListViewItem ): \"\"\" Class exposing necessary components of a live stream \"\"\" # pylint: disable=unused-argument def ytid ( self , lngt = 10 ): \"\"\" Exposes ytid(string) \"\"\" return self . data . get ( \"id\" ) . get ( \"videoId\" ) def ret ( self ): \"\"\" Returns content.video compatible tuple \"\"\" return ( self . ytid (), self . title (), self . length ()) def title ( self , lngt = 10 ): \"\"\" exposes title \"\"\" return util . uea_pad ( lngt , self . data . get ( \"snippet\" ) . get ( \"title\" )) def description ( self , lngt = 10 ): \"\"\" exposes description \"\"\" return util . uea_pad ( lngt , self . data . get ( \"snippet\" ) . get ( \"description\" )) @staticmethod def return_field (): \"\"\" ret \"\"\" return \"ret\" description ( self , lngt = 10 ) \u00b6 exposes description Source code in mps_youtube/listview/livestream.py def description ( self , lngt = 10 ): \"\"\" exposes description \"\"\" return util . uea_pad ( lngt , self . data . get ( \"snippet\" ) . get ( \"description\" )) ret ( self ) \u00b6 Returns content.video compatible tuple Source code in mps_youtube/listview/livestream.py def ret ( self ): \"\"\" Returns content.video compatible tuple \"\"\" return ( self . ytid (), self . title (), self . length ()) return_field () staticmethod \u00b6 ret Source code in mps_youtube/listview/livestream.py @staticmethod def return_field (): \"\"\" ret \"\"\" return \"ret\" title ( self , lngt = 10 ) \u00b6 exposes title Source code in mps_youtube/listview/livestream.py def title ( self , lngt = 10 ): \"\"\" exposes title \"\"\" return util . uea_pad ( lngt , self . data . get ( \"snippet\" ) . get ( \"title\" )) ytid ( self , lngt = 10 ) \u00b6 Exposes ytid(string) Source code in mps_youtube/listview/livestream.py def ytid ( self , lngt = 10 ): \"\"\" Exposes ytid(string) \"\"\" return self . data . get ( \"id\" ) . get ( \"videoId\" )","title":"livestream.py"},{"location":"reference/listview/livestream/#mps_youtube.listview.livestream.ListLiveStream","text":"Class exposing necessary components of a live stream Source code in mps_youtube/listview/livestream.py class ListLiveStream ( ListViewItem ): \"\"\" Class exposing necessary components of a live stream \"\"\" # pylint: disable=unused-argument def ytid ( self , lngt = 10 ): \"\"\" Exposes ytid(string) \"\"\" return self . data . get ( \"id\" ) . get ( \"videoId\" ) def ret ( self ): \"\"\" Returns content.video compatible tuple \"\"\" return ( self . ytid (), self . title (), self . length ()) def title ( self , lngt = 10 ): \"\"\" exposes title \"\"\" return util . uea_pad ( lngt , self . data . get ( \"snippet\" ) . get ( \"title\" )) def description ( self , lngt = 10 ): \"\"\" exposes description \"\"\" return util . uea_pad ( lngt , self . data . get ( \"snippet\" ) . get ( \"description\" )) @staticmethod def return_field (): \"\"\" ret \"\"\" return \"ret\"","title":"ListLiveStream"},{"location":"reference/listview/livestream/#mps_youtube.listview.livestream.ListLiveStream.description","text":"exposes description Source code in mps_youtube/listview/livestream.py def description ( self , lngt = 10 ): \"\"\" exposes description \"\"\" return util . uea_pad ( lngt , self . data . get ( \"snippet\" ) . get ( \"description\" ))","title":"description()"},{"location":"reference/listview/livestream/#mps_youtube.listview.livestream.ListLiveStream.ret","text":"Returns content.video compatible tuple Source code in mps_youtube/listview/livestream.py def ret ( self ): \"\"\" Returns content.video compatible tuple \"\"\" return ( self . ytid (), self . title (), self . length ())","title":"ret()"},{"location":"reference/listview/livestream/#mps_youtube.listview.livestream.ListLiveStream.return_field","text":"ret Source code in mps_youtube/listview/livestream.py @staticmethod def return_field (): \"\"\" ret \"\"\" return \"ret\"","title":"return_field()"},{"location":"reference/listview/livestream/#mps_youtube.listview.livestream.ListLiveStream.title","text":"exposes title Source code in mps_youtube/listview/livestream.py def title ( self , lngt = 10 ): \"\"\" exposes title \"\"\" return util . uea_pad ( lngt , self . data . get ( \"snippet\" ) . get ( \"title\" ))","title":"title()"},{"location":"reference/listview/livestream/#mps_youtube.listview.livestream.ListLiveStream.ytid","text":"Exposes ytid(string) Source code in mps_youtube/listview/livestream.py def ytid ( self , lngt = 10 ): \"\"\" Exposes ytid(string) \"\"\" return self . data . get ( \"id\" ) . get ( \"videoId\" )","title":"ytid()"},{"location":"reference/listview/songtitle/","text":"ListSongtitle ( ListViewItem ) \u00b6 Describes a user Source code in mps_youtube/listview/songtitle.py class ListSongtitle ( ListViewItem ): \"\"\" Describes a user \"\"\" # pylint: disable=unused-argument _checked = False _certainty = 1.0 def __init__ ( self , data , certainty = 1.0 ): self . _checked = True self . _certainty = certainty super ( ListSongtitle , self ) . __init__ ( data ) def artist ( self , l = 10 ): \"\"\" Get artist \"\"\" return u . uea_pad ( l , self . data [ 0 ]) def title ( self , l = 10 ): \"\"\" Get title \"\"\" return u . uea_pad ( l , self . data [ 1 ]) def checked ( self , l = 10 ): \"\"\" String from for checked \"\"\" return \" X \" if self . _checked else \" \" def certainty ( self ): \"\"\" Float \"\"\" return self . _certainty def is_checked ( self ): \"\"\" Returns true if checked \"\"\" return self . _checked def toggle ( self ): \"\"\" Toggle checked status \"\"\" self . _checked = not self . _checked def ret ( self ): \"\"\" Used in the ListView play function \"\"\" return \" %s - %s \" % ( self . artist () . strip (), self . title () . strip ()) @staticmethod def return_field (): \"\"\" Determines which function will be called on selected items \"\"\" return \"ret\" artist ( self , l = 10 ) \u00b6 Get artist Source code in mps_youtube/listview/songtitle.py def artist ( self , l = 10 ): \"\"\" Get artist \"\"\" return u . uea_pad ( l , self . data [ 0 ]) certainty ( self ) \u00b6 Float Source code in mps_youtube/listview/songtitle.py def certainty ( self ): \"\"\" Float \"\"\" return self . _certainty checked ( self , l = 10 ) \u00b6 String from for checked Source code in mps_youtube/listview/songtitle.py def checked ( self , l = 10 ): \"\"\" String from for checked \"\"\" return \" X \" if self . _checked else \" \" is_checked ( self ) \u00b6 Returns true if checked Source code in mps_youtube/listview/songtitle.py def is_checked ( self ): \"\"\" Returns true if checked \"\"\" return self . _checked ret ( self ) \u00b6 Used in the ListView play function Source code in mps_youtube/listview/songtitle.py def ret ( self ): \"\"\" Used in the ListView play function \"\"\" return \" %s - %s \" % ( self . artist () . strip (), self . title () . strip ()) return_field () staticmethod \u00b6 Determines which function will be called on selected items Source code in mps_youtube/listview/songtitle.py @staticmethod def return_field (): \"\"\" Determines which function will be called on selected items \"\"\" return \"ret\" title ( self , l = 10 ) \u00b6 Get title Source code in mps_youtube/listview/songtitle.py def title ( self , l = 10 ): \"\"\" Get title \"\"\" return u . uea_pad ( l , self . data [ 1 ]) toggle ( self ) \u00b6 Toggle checked status Source code in mps_youtube/listview/songtitle.py def toggle ( self ): \"\"\" Toggle checked status \"\"\" self . _checked = not self . _checked","title":"songtitle.py"},{"location":"reference/listview/songtitle/#mps_youtube.listview.songtitle.ListSongtitle","text":"Describes a user Source code in mps_youtube/listview/songtitle.py class ListSongtitle ( ListViewItem ): \"\"\" Describes a user \"\"\" # pylint: disable=unused-argument _checked = False _certainty = 1.0 def __init__ ( self , data , certainty = 1.0 ): self . _checked = True self . _certainty = certainty super ( ListSongtitle , self ) . __init__ ( data ) def artist ( self , l = 10 ): \"\"\" Get artist \"\"\" return u . uea_pad ( l , self . data [ 0 ]) def title ( self , l = 10 ): \"\"\" Get title \"\"\" return u . uea_pad ( l , self . data [ 1 ]) def checked ( self , l = 10 ): \"\"\" String from for checked \"\"\" return \" X \" if self . _checked else \" \" def certainty ( self ): \"\"\" Float \"\"\" return self . _certainty def is_checked ( self ): \"\"\" Returns true if checked \"\"\" return self . _checked def toggle ( self ): \"\"\" Toggle checked status \"\"\" self . _checked = not self . _checked def ret ( self ): \"\"\" Used in the ListView play function \"\"\" return \" %s - %s \" % ( self . artist () . strip (), self . title () . strip ()) @staticmethod def return_field (): \"\"\" Determines which function will be called on selected items \"\"\" return \"ret\"","title":"ListSongtitle"},{"location":"reference/listview/songtitle/#mps_youtube.listview.songtitle.ListSongtitle.artist","text":"Get artist Source code in mps_youtube/listview/songtitle.py def artist ( self , l = 10 ): \"\"\" Get artist \"\"\" return u . uea_pad ( l , self . data [ 0 ])","title":"artist()"},{"location":"reference/listview/songtitle/#mps_youtube.listview.songtitle.ListSongtitle.certainty","text":"Float Source code in mps_youtube/listview/songtitle.py def certainty ( self ): \"\"\" Float \"\"\" return self . _certainty","title":"certainty()"},{"location":"reference/listview/songtitle/#mps_youtube.listview.songtitle.ListSongtitle.checked","text":"String from for checked Source code in mps_youtube/listview/songtitle.py def checked ( self , l = 10 ): \"\"\" String from for checked \"\"\" return \" X \" if self . _checked else \" \"","title":"checked()"},{"location":"reference/listview/songtitle/#mps_youtube.listview.songtitle.ListSongtitle.is_checked","text":"Returns true if checked Source code in mps_youtube/listview/songtitle.py def is_checked ( self ): \"\"\" Returns true if checked \"\"\" return self . _checked","title":"is_checked()"},{"location":"reference/listview/songtitle/#mps_youtube.listview.songtitle.ListSongtitle.ret","text":"Used in the ListView play function Source code in mps_youtube/listview/songtitle.py def ret ( self ): \"\"\" Used in the ListView play function \"\"\" return \" %s - %s \" % ( self . artist () . strip (), self . title () . strip ())","title":"ret()"},{"location":"reference/listview/songtitle/#mps_youtube.listview.songtitle.ListSongtitle.return_field","text":"Determines which function will be called on selected items Source code in mps_youtube/listview/songtitle.py @staticmethod def return_field (): \"\"\" Determines which function will be called on selected items \"\"\" return \"ret\"","title":"return_field()"},{"location":"reference/listview/songtitle/#mps_youtube.listview.songtitle.ListSongtitle.title","text":"Get title Source code in mps_youtube/listview/songtitle.py def title ( self , l = 10 ): \"\"\" Get title \"\"\" return u . uea_pad ( l , self . data [ 1 ])","title":"title()"},{"location":"reference/listview/songtitle/#mps_youtube.listview.songtitle.ListSongtitle.toggle","text":"Toggle checked status Source code in mps_youtube/listview/songtitle.py def toggle ( self ): \"\"\" Toggle checked status \"\"\" self . _checked = not self . _checked","title":"toggle()"},{"location":"reference/listview/user/","text":"ListUser ( ListViewItem ) \u00b6 Describes a user Source code in mps_youtube/listview/user.py class ListUser ( ListViewItem ): \"\"\" Describes a user \"\"\" # pylint: disable=unused-argument def id ( self , length = 0 ): \"\"\" Returns YTID \"\"\" return self . data . get ( \"id\" ) def name ( self , length = 10 ): \"\"\" Returns channel name \"\"\" return u . uea_pad ( length , self . data . get ( \"title\" )) def description ( self , length = 10 ): \"\"\" Channel description\"\"\" return u . uea_pad ( length , self . data [ \"descriptionSnippet\" ][ 0 ][ 'text' ] if self . data [ 'descriptionSnippet' ] is not None else 'No description found' ) def kind ( self , length = 10 ): \"\"\" Returns the youtube datatype Example: youtube#channel, youtube#video \"\"\" return self . data . get ( \"type\" ) def ret ( self ): \"\"\" Used in the ListView play function \"\"\" return ( self . name (), self . id (), \"\" ) @staticmethod def return_field (): \"\"\" Determines which function will be called on selected items \"\"\" return \"ret\" description ( self , length = 10 ) \u00b6 Channel description Source code in mps_youtube/listview/user.py def description ( self , length = 10 ): \"\"\" Channel description\"\"\" return u . uea_pad ( length , self . data [ \"descriptionSnippet\" ][ 0 ][ 'text' ] if self . data [ 'descriptionSnippet' ] is not None else 'No description found' ) id ( self , length = 0 ) \u00b6 Returns YTID Source code in mps_youtube/listview/user.py def id ( self , length = 0 ): \"\"\" Returns YTID \"\"\" return self . data . get ( \"id\" ) kind ( self , length = 10 ) \u00b6 Returns the youtube datatype Example: youtube#channel, youtube#video Source code in mps_youtube/listview/user.py def kind ( self , length = 10 ): \"\"\" Returns the youtube datatype Example: youtube#channel, youtube#video \"\"\" return self . data . get ( \"type\" ) name ( self , length = 10 ) \u00b6 Returns channel name Source code in mps_youtube/listview/user.py def name ( self , length = 10 ): \"\"\" Returns channel name \"\"\" return u . uea_pad ( length , self . data . get ( \"title\" )) ret ( self ) \u00b6 Used in the ListView play function Source code in mps_youtube/listview/user.py def ret ( self ): \"\"\" Used in the ListView play function \"\"\" return ( self . name (), self . id (), \"\" ) return_field () staticmethod \u00b6 Determines which function will be called on selected items Source code in mps_youtube/listview/user.py @staticmethod def return_field (): \"\"\" Determines which function will be called on selected items \"\"\" return \"ret\"","title":"user.py"},{"location":"reference/listview/user/#mps_youtube.listview.user.ListUser","text":"Describes a user Source code in mps_youtube/listview/user.py class ListUser ( ListViewItem ): \"\"\" Describes a user \"\"\" # pylint: disable=unused-argument def id ( self , length = 0 ): \"\"\" Returns YTID \"\"\" return self . data . get ( \"id\" ) def name ( self , length = 10 ): \"\"\" Returns channel name \"\"\" return u . uea_pad ( length , self . data . get ( \"title\" )) def description ( self , length = 10 ): \"\"\" Channel description\"\"\" return u . uea_pad ( length , self . data [ \"descriptionSnippet\" ][ 0 ][ 'text' ] if self . data [ 'descriptionSnippet' ] is not None else 'No description found' ) def kind ( self , length = 10 ): \"\"\" Returns the youtube datatype Example: youtube#channel, youtube#video \"\"\" return self . data . get ( \"type\" ) def ret ( self ): \"\"\" Used in the ListView play function \"\"\" return ( self . name (), self . id (), \"\" ) @staticmethod def return_field (): \"\"\" Determines which function will be called on selected items \"\"\" return \"ret\"","title":"ListUser"},{"location":"reference/listview/user/#mps_youtube.listview.user.ListUser.description","text":"Channel description Source code in mps_youtube/listview/user.py def description ( self , length = 10 ): \"\"\" Channel description\"\"\" return u . uea_pad ( length , self . data [ \"descriptionSnippet\" ][ 0 ][ 'text' ] if self . data [ 'descriptionSnippet' ] is not None else 'No description found' )","title":"description()"},{"location":"reference/listview/user/#mps_youtube.listview.user.ListUser.id","text":"Returns YTID Source code in mps_youtube/listview/user.py def id ( self , length = 0 ): \"\"\" Returns YTID \"\"\" return self . data . get ( \"id\" )","title":"id()"},{"location":"reference/listview/user/#mps_youtube.listview.user.ListUser.kind","text":"Returns the youtube datatype Example: youtube#channel, youtube#video Source code in mps_youtube/listview/user.py def kind ( self , length = 10 ): \"\"\" Returns the youtube datatype Example: youtube#channel, youtube#video \"\"\" return self . data . get ( \"type\" )","title":"kind()"},{"location":"reference/listview/user/#mps_youtube.listview.user.ListUser.name","text":"Returns channel name Source code in mps_youtube/listview/user.py def name ( self , length = 10 ): \"\"\" Returns channel name \"\"\" return u . uea_pad ( length , self . data . get ( \"title\" ))","title":"name()"},{"location":"reference/listview/user/#mps_youtube.listview.user.ListUser.ret","text":"Used in the ListView play function Source code in mps_youtube/listview/user.py def ret ( self ): \"\"\" Used in the ListView play function \"\"\" return ( self . name (), self . id (), \"\" )","title":"ret()"},{"location":"reference/listview/user/#mps_youtube.listview.user.ListUser.return_field","text":"Determines which function will be called on selected items Source code in mps_youtube/listview/user.py @staticmethod def return_field (): \"\"\" Determines which function will be called on selected items \"\"\" return \"ret\"","title":"return_field()"},{"location":"reference/players/GenericPlayer/","text":"GenericPlayer ( CmdPlayer ) \u00b6 Source code in mps_youtube/players/GenericPlayer.py class GenericPlayer ( CmdPlayer ): def __init__ ( self , player ): self . player = player def _generate_real_playerargs ( self ): '''Generates player arguments to called using Popen ''' args = config . PLAYERARGS . get . strip () . split () ############################################ # Define your arguments below this line ########################################### return [ self . player ] + args + [ self . stream [ 'url' ]] def clean_up ( self ): ''' Cleans up temp files after process exits. ''' pass def launch_player ( self , cmd ): ################################################## # Change this however you want with open ( os . devnull , \"w\" ) as devnull : self . p = subprocess . Popen ( cmd , shell = False , stderr = devnull ) self . p . wait () ################################################## # Donot forget self.next() self . next () def _help ( self , short = True ): ''' Help keys shown when the song is played. See mpv.py for reference. ''' pass clean_up ( self ) \u00b6 Cleans up temp files after process exits. Source code in mps_youtube/players/GenericPlayer.py def clean_up ( self ): ''' Cleans up temp files after process exits. ''' pass","title":"GenericPlayer.py"},{"location":"reference/players/GenericPlayer/#mps_youtube.players.GenericPlayer.GenericPlayer","text":"Source code in mps_youtube/players/GenericPlayer.py class GenericPlayer ( CmdPlayer ): def __init__ ( self , player ): self . player = player def _generate_real_playerargs ( self ): '''Generates player arguments to called using Popen ''' args = config . PLAYERARGS . get . strip () . split () ############################################ # Define your arguments below this line ########################################### return [ self . player ] + args + [ self . stream [ 'url' ]] def clean_up ( self ): ''' Cleans up temp files after process exits. ''' pass def launch_player ( self , cmd ): ################################################## # Change this however you want with open ( os . devnull , \"w\" ) as devnull : self . p = subprocess . Popen ( cmd , shell = False , stderr = devnull ) self . p . wait () ################################################## # Donot forget self.next() self . next () def _help ( self , short = True ): ''' Help keys shown when the song is played. See mpv.py for reference. ''' pass","title":"GenericPlayer"},{"location":"reference/players/GenericPlayer/#mps_youtube.players.GenericPlayer.GenericPlayer.clean_up","text":"Cleans up temp files after process exits. Source code in mps_youtube/players/GenericPlayer.py def clean_up ( self ): ''' Cleans up temp files after process exits. ''' pass","title":"clean_up()"},{"location":"reference/players/__init__/","text":"","title":"__init__.py"},{"location":"reference/players/mplayer/","text":"","title":"mplayer.py"},{"location":"reference/players/mpv/","text":"","title":"mpv.py"},{"location":"reference/players/vlc/","text":"","title":"vlc.py"}]}